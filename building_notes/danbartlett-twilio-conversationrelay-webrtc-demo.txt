Directory structure:
└── danbartlett-twilio-conversationrelay-webrtc-demo/
    ├── README.md
    ├── client/
    │   ├── package.json
    │   ├── public/
    │   │   └── index.html
    │   └── src/
    │       ├── ConversationRelayClient.js
    │       ├── index.js
    │       ├── styles.css
    │       ├── helpers/
    │       │   ├── clientDataHelper.js
    │       │   └── utils.js
    │       ├── jotaiState/
    │       │   └── appState.js
    │       ├── styles/
    │       │   ├── ConversationRelayClient.css
    │       │   ├── index.css
    │       │   └── MessageLog.css
    │       ├── templates/
    │       │   └── audiovisualizer.js
    │       └── ui-components/
    │           ├── AppHeader.js
    │           ├── Main.js
    │           ├── StartCard.js
    │           ├── Wrapper.js
    │           ├── Audiovisualizer/
    │           │   └── Audiovisualizer.js
    │           ├── BotConfiguration/
    │           │   ├── BotProperties.js
    │           │   └── UseCaseCombo.js
    │           ├── CallHistory/
    │           │   ├── CallHistory.js
    │           │   ├── CallList.js
    │           │   ├── CallRecord.js
    │           │   ├── MessageLog.js
    │           │   └── SelectedCall.js
    │           ├── Transcription/
    │           │   ├── MessageLog.js
    │           │   └── Transcript.js
    │           ├── UseCases/
    │           │   ├── AddUseCaseForm.js
    │           │   ├── UseCaseCombo.js
    │           │   ├── UseCaseRecord.js
    │           │   └── UseCases.js
    │           └── Users/
    │               ├── AddUserForm.js
    │               ├── UserRecord.js
    │               └── Users.js
    ├── data/
    │   ├── tts-providers.json
    │   ├── use-cases.json
    │   ├── users.json.sample
    │   └── use-cases/
    │       ├── build-use-case.mjs
    │       ├── package.json
    │       ├── albert-einstein/
    │       │   ├── conversationrelay.mjs
    │       │   ├── dtmf.mjs
    │       │   ├── prompt.mjs
    │       │   ├── properties.mjs
    │       │   └── tools.mjs
    │       ├── apartment-search/
    │       │   ├── README.md
    │       │   ├── conversationrelay.mjs
    │       │   ├── data.apartments.json
    │       │   ├── data.appointments.json
    │       │   ├── data.appointments.refresh.mjs
    │       │   ├── dtmf.mjs
    │       │   ├── prompt.mjs
    │       │   ├── properties.mjs
    │       │   └── tools.mjs
    │       ├── restaurant-ordering/
    │       │   ├── conversationrelay.mjs
    │       │   ├── dtmf.mjs
    │       │   ├── prompt.mjs
    │       │   ├── properties.mjs
    │       │   └── tools.mjs
    │       ├── rhyming-parrot/
    │       │   ├── conversationrelay.mjs
    │       │   ├── dtmf.mjs
    │       │   ├── prompt.mjs
    │       │   ├── properties.mjs
    │       │   └── tools.mjs
    │       ├── tool-calling-example/
    │       │   ├── conversationrelay.mjs
    │       │   ├── dtmf.mjs
    │       │   ├── prompt.mjs
    │       │   ├── properties.mjs
    │       │   └── tools.mjs
    │       └── utilities/
    │           └── random-data-generator.mjs
    └── server/
        ├── index.mjs
        ├── package.json
        ├── start-local-server.sh.sample
        ├── lib/
        │   ├── database-helpers.mjs
        │   ├── default-websocket-handler.mjs
        │   ├── invoke-bedrock.mjs
        │   ├── invoke-open-ai.mjs
        │   ├── llm-formatting-helpers.mjs
        │   ├── package.json
        │   ├── prepare-and-call-llm.mjs
        │   ├── setup-call-post-handler.mjs
        │   └── tools/
        │       ├── save-tool-result.mjs
        │       ├── twilio-send-email.cjs
        │       ├── twilio-send-message.cjs
        │       ├── apartment-search/
        │       │   ├── apartment-search-utils.mjs
        │       │   ├── check-availability.mjs
        │       │   ├── check-existing-appointments.mjs
        │       │   ├── common-inquiries.mjs
        │       │   ├── list-available-apartments.mjs
        │       │   ├── schedule-tour.mjs
        │       │   ├── send-appointment-confirmation-sms.mjs
        │       │   ├── send-message.mjs
        │       │   └── tools.mjs
        │       ├── restaurant-ordering/
        │       │   ├── check-restaurant-delivery-time.mjs
        │       │   ├── check-restaurant-pick-up-time.mjs
        │       │   ├── place-order.mjs
        │       │   ├── send-email.mjs
        │       │   ├── send-message.mjs
        │       │   └── tools.mjs
        │       └── tool-calling-example/
        │           ├── get-joke.mjs
        │           ├── get-quote.mjs
        │           ├── get-zip-code.mjs
        │           ├── send-email.mjs
        │           ├── send-message.mjs
        │           ├── tool-calling-example-resources.mjs
        │           └── tools.mjs
        ├── routes/
        │   ├── client-app.js
        │   ├── client-data.js
        │   ├── client-token.js
        │   └── twiml.js
        └── services/
            └── twilio-service.cjs

================================================
FILE: README.md
================================================
# ConversationRelay WebRTC Demo

## [Read the Twilio blog that goes with this repo: Add Voice AI to your website with the Twilio Voice JavaScript SDK and ConversationRelay]( https://www.twilio.com/en-us/blog/developers/tutorials/product/voice-ai-conversationrelay-twilio-voice-sdk ) 

## Setup Instructions

1) Clone or Download the repo

2) Build the client =>  `cd client; npm install; npm run build`

3) Start ngrok (port 3000), copy your ngrok url

4) Create a Twilio API Key

5) Create a Twilio TwiML APP and point the url to POST to your ngrok url + "/twiml" (https://your-subdomain.ngrok.app/twiml)

6) Copy the file server/start-local-server.sh.sample to server/start-local-server.sh => `cp server/start-local-server.sh.sample server/start-local-server.sh.sample` and set YOUR environment variables in `server/start-local-server.sh`

7) Make a copy of the user.json file => `cp data/users.json.sample data/users.json`

8) Start server => `cd server; npm install; ./start-local-server.sh`

9) Point your web browser to http://localhost:3000, and start working with ConversationRelay! 


## Bonus Material

### Break it down for me – how do I add an AI application to my website and app?

With this repo, you can deploy a sample application that connects a WebRTC client to a Voice Application using Twilio. You can certainly use this code as a starting point to building your own application. From a high level this application (1) registers as voice client, (2) starts a ConversationRelay session, and (3) handles inbound and outbound websockets to orchestrate text  If you want to dig into the code, here is where you should start::

### For Registering a Voice Client

* /client/src/ui-components/Main.js → contains key functions to register a voice client and make a voice call.
* /client/src/ui-components/StartCard.js → contains the TALK-TO-AGENT button.
* /server/services/twilio-service.cjs, /server/routes/client-token.js → backend functions used to register voice clients.

### For Starting a ConversationRelay Session

* /server/lib/setup-call-post-handler → Generates TwiML needed to start a ConversationRelay session.

### For Handling Inbound Websockets (Text-to-Speect), LLM Interaction and stream text back to Twilio over websockets (Speech-to-Text)

* /server/lib/default-websocket-handler.mjs → Primary handler from websocket messages coming from Twilio ConversationRelay.
* /server/lib/prepare-and-call-llm.mjs → Function used to initially call to LLM.

There are of course other key files that make this a working application, but the files listed above handle the core functionality needed to connect your voice AI applications.



================================================
FILE: client/package.json
================================================
{
  "name": "react.dev",
  "version": "0.0.0",
  "main": "/src/index.js",
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "dependencies": {
    "@twilio-paste/core": "^20.18.1",
    "@twilio-paste/icons": "^12.9.0",
    "@twilio/voice-sdk": "^2.12.1",
    "axios": "^1.9.0",
    "jotai": "^2.12.5",
    "nanoid": "^5.1.5",
    "react": "^18.3.1",
    "react-audio-visualize": "^1.2.0",
    "react-audio-voice-recorder": "^2.2.0",
    "react-dom": "^18.3.1",
    "react-international-phone": "^4.4.0",
    "react-scripts": "5.0.1",
    "react-use-websocket": "^4.8.1",
    "uuid": "^11.1.0"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}



================================================
FILE: client/public/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ConverstionRelay - WebRTC Demo</title>
</head>
<body>
  <div id="root"></div>
</body>
</html>


================================================
FILE: client/src/ConversationRelayClient.js
================================================
import { useState, useRef } from "react";
import axios from "axios";
import { Device } from "@twilio/voice-sdk";
import "./styles/ConversationRelayClient.css";
import audiovisualizer from "./templates/audiovisualizer";
// import AudioDevices from "./components/AudioDevices";
// import ReactAudioVisualizer from "./components/ReactAudioVisualizer";
import LatencyVisualizer from "./components/LatencyVisualizer";
// import AudioProcessor from "./AudioProcessor.ts";

import { PhoneInput } from "react-international-phone";
import "react-international-phone/style.css";

// Twilio Paste
import { Theme } from "@twilio-paste/core/dist/theme";
import {
  Box,
  Heading,
  Label,
  Button,
  Stack,
  InPageNavigation,
  InPageNavigationItem,
} from "@twilio-paste/core";

// import { Switch } from "@twilio-paste/core";

import UseCasePicker from "./components/UseCasePicker";

export const ConversationRelayClient = () => {
  const [device, setDevice] = useState();
  const [loading, setLoading] = useState(true);
  // const [noiseCancellation, setNoiseCancellation] = useState(false);
  const [phone, setPhone] = useState("");
  const [whichPage, setWhichPage] = useState(true);
  const [personalized, setPersonalized] = useState(false);

  let voiceToken = useRef("");
  // const processor = new AudioProcessor();

  const registerTwilioDeviceHandlers = (device) => {
    device.on("incoming", function (conn) {
      console.log(
        "Call incoming: " +
          conn.parameters.From +
          ", Call SID: " +
          conn.parameters.CallSid +
          ""
      );
    });

    device.on("registered", (dev) => {
      console.log("Device ready to receive incoming calls\n");
    });

    device.on("unregistered", (dev) => {
      console.log("Device unregistered\n");
      setDevice(undefined);
    });

    device.on("tokenWillExpire", (dev) => {
      console.log("Device token is expiring\n");
    });

    device.on("error", (dev) => {
      console.log("Device encountered error\n", dev);
      setDevice(undefined);
    });

    device.on("destroyed", (dev) => {
      console.log("Device destroyed\n");
      setDevice(undefined);
    });
  };

  // const enableAudioProcessor = async () => {
  //   if (!device.audio._processor) {
  //     await device.audio.addProcessor(processor);
  //     console.log("Added audio processor");
  //     setNoiseCancellation(true); // this is causing the issue
  //   } else {
  //     console.log("Audio processor already enabled");
  //   }
  // };

  // const disableAudioProcessor = async () => {
  //   if (device.audio._processor) {
  //     await device.audio.removeProcessor(device.audio._processor);
  //     console.log("Disabled audio processor");
  //     setNoiseCancellation(false); // this is causing the issue
  //   } else {
  //     console.log("No audio processor to remove");
  //   }
  // };

  const createVoiceDevice = async () => {
    const myDevice = await new Device(voiceToken.current, {
      logLevel: 5,
      codecPreferences: ["opus", "pcmu"],
    });
    setDevice(myDevice);
    setLoading(false);
    myDevice.register();
    registerTwilioDeviceHandlers(myDevice);
    //audiovisualizer.setupAudioVisualizerCanvas();
  };

  const registerVoiceClient = async (phone) => {
    if (!voiceToken.current) {
      try {
        const registerVoiceClientURL =
          process.env.REACT_APP_REGISTER_VOICE_CLIENT_URL;
        const res = await axios.get(registerVoiceClientURL + "?phone=" + phone);
        voiceToken.current = res.data;
        createVoiceDevice();
      } catch (e) {
        console.log(e);
      }
    }
  };

  return (
    <Theme.Provider theme="Twilio">
      <Box paddingX="space100">
        <Theme.Provider theme="Twilio">
          <Box display="flex" flexDirection="column">
            <Box padding="space50">
              <Heading as="h2" variant="heading20">
                ConversationRelay Client
                {/* <AudioDevices /> */}
              </Heading>
              {/* <DBProfile /> */}
              {loading ? (
                <div>
                  {/* <Label required>Enter Phone Number</Label> */}
                  <Stack orientation="horizontal" spacing="space40">
                    {/* <PhoneInput
                      defaultCountry="us"
                      value={phone}
                      onChange={(phone) => setPhone(phone)}
                    /> */}
                    <Button
                      variant="destructive"
                      onClick={() => registerVoiceClient("browser-client")}
                    >
                      🤷‍♂️ Ask a Question
                    </Button>
                  </Stack>
                </div>
              ) : (
                <div>
                  {/* <Switch
                    value={noiseCancellation}
                    onClick={(e) => {
                      noiseCancellation === false
                        ? enableAudioProcessor()
                        : disableAudioProcessor();
                    }}
                  >
                    Enable Noise Cancellation
                  </Switch> */}
                </div>
              )}

              {/*} <InPageNavigation>
                <InPageNavigationItem
                  currentPage={whichPage}
                  onClick={() => {
                    setWhichPage(true);
                    setPersonalized(false);
                  }}
                >
                  A/B Testing
                </InPageNavigationItem>
                <InPageNavigationItem
                  currentPage={!whichPage}
                  onClick={() => {
                    setWhichPage(false);
                    setPersonalized(true);
                  }}
                >
                  Personalized Agent
                </InPageNavigationItem>
              </InPageNavigation> */}
              {whichPage ? (
                <div>
                  <UseCasePicker
                    personalized={personalized}
                    device={device}
                    loading={loading}
                  />
                  <Label htmlFor="audio-visualizer">Audio Visualizer</Label>
                  <canvas id="audio-visualizer"></canvas>
                </div>
              ) : (
                <div>
                  <UseCasePicker
                    personalized={personalized}
                    device={device}
                    loading={loading}
                  />
                  <Label htmlFor="audio-visualizer">Audio Visualizer</Label>
                  <canvas id="audio-visualizer"></canvas>
                </div>
              )}

              {/* <ReactAudioVisualizer /> */}
              {/* <LatencyVisualizer /> */}
            </Box>
          </Box>
        </Theme.Provider>
      </Box>
    </Theme.Provider>
  );
};

export default ConversationRelayClient;



================================================
FILE: client/src/index.js
================================================
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";

import {Provider } from "jotai"

import "./styles.css";
import Wrapper from "./ui-components/Wrapper";

console.log(
  "Starting ConversationRelayClient => ",
  process.env.REACT_APP_REGISTER_VOICE_CLIENT_URL
);
const root = createRoot(document.getElementById("root"));
root.render(
  <StrictMode>
    <Provider>
      <Wrapper />
    </Provider>
  </StrictMode>
);



================================================
FILE: client/src/styles.css
================================================
* {
  box-sizing: border-box;
}

body {
  font-family: sans-serif;
  margin: 20px;
  padding: 0;
}

h1 {
  margin-top: 0;
  font-size: 22px;
}

h2 {
  margin-top: 0;
  font-size: 20px;
}

h3 {
  margin-top: 0;
  font-size: 18px;
}

h4 {
  margin-top: 0;
  font-size: 16px;
}

h5 {
  margin-top: 0;
  font-size: 14px;
}

h6 {
  margin-top: 0;
  font-size: 12px;
}

code {
  font-size: 1.2em;
}

ul {
  padding-inline-start: 20px;
}

* {
  box-sizing: border-box;
}

body {
  font-family: sans-serif;
  margin: 20px;
  padding: 0;
}

.square {
  background: #fff;
  border: 1px solid #999;
  float: left;
  font-size: 24px;
  font-weight: bold;
  line-height: 34px;
  height: 34px;
  margin-right: -1px;
  margin-top: -1px;
  padding: 0;
  text-align: center;
  width: 34px;
}

.board-row:after {
  clear: both;
  content: '';
  display: table;
}

.status {
  margin-bottom: 10px;
}
.game {
  display: flex;
  flex-direction: row;
}

.game-info {
  margin-left: 20px;
}



================================================
FILE: client/src/helpers/clientDataHelper.js
================================================


import axios from "axios";

export const updateUserHelper = async(userAttributes) => {

    //  call backend to update user configuration ( server > data > users.json )
    try {
        // Fetch all voices from the backend
        const updateUserURL = process.env.REACT_APP_UPDATE_USER_URL; 
        return await axios.post(updateUserURL,  userAttributes )
        .then((resp) => {
            return resp.data
        })
    } catch (error) {
        return { status: "error", message: error.message };
    }
}


export const createUserHelper = async(userAttributes) => { 

            // //  Call server API to create the user
        const createUrl = process.env.REACT_APP_CREATE_USER_URL
        try {
            return await axios.post(createUrl,  userAttributes )
            .then((resp) => {
                console.log('User created', resp.data);
                return resp.data
                })

            }
         catch (error) {
            console.error('Error creating user', error);
            return { status: "error", message: error.message };
        }
}

export const deleteUserHelper = async(identity) => {
        const deleteUrl = process.env.REACT_APP_DELETE_USER_URL
        try {
            return await axios.post(deleteUrl,  identity )
            .then((resp) => {
                console.log('User deleted', resp.data);
                return resp.data
            })
        } catch (error) {
            console.error('Error creating user', error);
            return { status: "error", message: error.message };
        }    
}


export const deleteCallHelper = async (callSid) => {
    const deleteCallUrl = process.env.REACT_APP_DELETE_SESSION_URL
    console.log('deleteCallHelper', deleteCallUrl, callSid)
    try {
        return await axios.post(deleteCallUrl,  callSid )
        .then((resp) => {
            console.log('Call deleted', resp.data);
            return resp.data
        })
    } catch (error) {
        console.error('Error deleting call', error);
        return { status: "error", message: error.message };
    }
}


export const updateUseCaseHelper = async(useCaseAttributes) => {

    //  call backend to update user configuration ( server > data > users.json )
    try {
        // Fetch all voices from the backend
        const updateUseCaseURL = process.env.REACT_APP_UPDATE_USE_CASE_URL; 
        console.log('updateUseCaseHelper', updateUseCaseURL, useCaseAttributes)
        return await axios.post(updateUseCaseURL,  useCaseAttributes )
        .then((resp) => {
            return resp.data
        })
    } catch (error) {
        return { status: "error", message: error.message };
    }
}

export const deleteUseCaseHelper = async(useCaseAttributes) => {

    //  call backend to update user configuration ( server > data > users.json )
    try {
        // Fetch all voices from the backend
        const deleteUseCaseURL = process.env.REACT_APP_DELETE_USE_CASE_URL; 
        console.log('deleteUseCaseHelper', deleteUseCaseURL, useCaseAttributes)
        return await axios.post(deleteUseCaseURL,  useCaseAttributes )
        .then((resp) => {
            return resp.data
        })
    } catch (error) {
        return { status: "error", message: error.message };
    }
}


================================================
FILE: client/src/helpers/utils.js
================================================
export function setupAnalyzer(stream) {
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  const source = audioContext.createMediaStreamSource(stream);
  const analyser = audioContext.createAnalyser();
  analyser.fftSize = 256;
  source.connect(analyser);
  return analyser;
}



================================================
FILE: client/src/jotaiState/appState.js
================================================
import { atom } from "jotai";

const appPage = atom("demo");
const appDevice = atom(null);
const appCurrentCall = atom(null);

export { appPage, appDevice, appCurrentCall };



================================================
FILE: client/src/styles/ConversationRelayClient.css
================================================
/* .wrapper {
  padding-top: 30px;
} */

#audio-visualizer {
  height: 200px;
  width: 100%;
  border: 1px solid #ccc;
  display: block;
  margin-bottom: 20px; /* Adjust the value as needed */
}

.status-area {
  width: 100%;
  box-sizing: border-box;
  height: calc(100vh - 360px); /* analysis canvas height is 200px */
  font-family: "Consolas", monospace;
  font-size: 9pt;
  user-select: text;
}

body h3 {
  margin-bottom: 25px;
}

.navbar-brand a {
  color: #ffffff;
}

.form-wrapper,
.table-wrapper {
  max-width: 500px;
  margin: 0 auto;
}

.table-wrapper {
  max-width: 700px;
}

.create-link {
  padding: 7px 10px;
  font-size: 1rem;
  line-height: normal;
  border-radius: 0.2rem;
  color: #fff;
  background-color: #58cced;
  border-color: #58cced;
}

.create-link:hover {
  background-color: #4adede;
  border-color: #4adede;
}

.edit-link {
  padding: 7px 10px;
  font-size: 0.875rem;
  line-height: normal;
  border-radius: 0.2rem;
  color: #fff;
  background-color: #28a745;
  border-color: #28a745;
  margin-right: 10px;
  position: relative;
  top: 1px;
}

.edit-link:hover {
  text-decoration: none;
  color: #ffffff;
}

/* Chrome, Safari, Edge, Opera */
input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}



================================================
FILE: client/src/styles/index.css
================================================
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen",
    "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, "Courier New",
    monospace;
}



================================================
FILE: client/src/styles/MessageLog.css
================================================
.message-log {
  padding: 20px;
  margin: 0 auto;
}

/* .message-container {
  display: flex;
  margin-bottom: 16px;
}

.message-container.left {
  justify-content: flex-start;
}

.message-container.right {
  justify-content: flex-end;
} */

.message-container {
  display: flex;
  align-items: flex-end;
  margin-bottom: 16px;
}

.message-container.left {
  flex-direction: row;
}

.message-container.right {
  flex-direction: row-reverse;
}

.message-avatar {
  flex-shrink: 0;
  margin: 0 8px;
}

.message-bubble {
  max-width: 70%;
  padding: 12px 16px;
  border-radius: 12px;
  font-size: 14px;
  position: relative;
  display: flex;
  flex-direction: column;
}

.message-bubble.remote {
  background-color: #f44336;
  color: #ffffff;
}

.message-bubble.local {
  background-color: #2196f3;
  color: #ffffff;
}

.message-meta {
  font-size: 12px;
  color: #ffffff;
  margin-top: 6px;
  text-align: right;
  opacity: 0.8;
}

.interrupt-container {
  display: flex;
  justify-content: center;
  margin: 16px 0;
}

@keyframes pulseInterrupt {
  0% {
    box-shadow: 0 0 0 0 rgba(183, 28, 28, 0.4); /* deep red */
  }
  70% {
    box-shadow: 0 0 0 10px rgba(183, 28, 28, 0); /* fade out */
  }
  100% {
    box-shadow: 0 0 0 0 rgba(183, 28, 28, 0);
  }
}

.interrupt-message {
  background-color: #ffebee; /* light red */
  color: #b71c1c; /* deep red */
  padding: 12px 16px;
  border-radius: 10px;
  max-width: 80%;
  text-align: center;
  font-size: 14px;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
  border: 1px solid #ef9a9a;
  animation: pulseInterrupt 2s infinite;
  margin: 0 auto; /* centers horizontally */
}

.message-bubble.remote {
  background-color: #f44336;
  color: #ffffff;
}

.latency-text {
  background-color: #fdecea; /* light red/pink */
  color: #a94442; /* dark red text */
  font-size: 12px;
  padding: 6px 10px;
  border-radius: 8px;
  position: relative;
  display: flex;
  flex-direction: column;
}



================================================
FILE: client/src/templates/audiovisualizer.js
================================================
// Define the bufferLength
const bufferLength = 256;

// Create a circular buffer to hold the volume levels
let localVolumeBuffer = new Array(bufferLength);
let remoteVolumeBuffer = new Array(bufferLength);
let markerBuffer = new Array(bufferLength).fill(undefined);
let bufferIndex = 0;

let sampleTime = 0;

let canvas;
let canvasContext;
let devicePixelRatio;

// Function to be called in runOnLoad() and window.onresize
function setupAudioVisualizerCanvas() {
  // Get the canvas and its context
  canvas = document.getElementById("audio-visualizer");
  canvasContext = canvas.getContext("2d");

  // Get the device pixel ratio
  devicePixelRatio = window.devicePixelRatio || 1;

  // Scale the canvas by the device pixel ratio
  canvas.width = canvas.clientWidth * devicePixelRatio;
  canvas.height = canvas.clientHeight * devicePixelRatio;

  // Scale the drawing context by the same amount
  canvasContext.scale(devicePixelRatio, devicePixelRatio);

  // console.log("canvas.width: " + canvas.width + ", canvas.height: " + canvas.height + ", devicePixelRatio: " + devicePixelRatio);

  localVolumeBuffer.fill(0);
  remoteVolumeBuffer.fill(0);
}

// Function to draw the audio data
function draw() {
  // Adjust the canvas for the device pixel ratio
  const canvasHeight = canvas.height / devicePixelRatio;
  const barWidth = canvas.width / bufferLength / devicePixelRatio;

  const timeMarkerWidth = barWidth / 8;
  const externalMarkerWidth = barWidth / 4;
  const barGapWidth = barWidth / 32;
  const narrowBarWidth = barWidth - barGapWidth * 2;

  let xPosition = 0;
  let lSampleTime = 0;
  for (let i = 0; i < bufferLength; i++) {
    // The values have been scaled properly
    let localBarHeight = localVolumeBuffer[(bufferIndex + i) % bufferLength];
    let remoteBarHeight = remoteVolumeBuffer[(bufferIndex + i) % bufferLength];

    let markerValue = markerBuffer[(bufferIndex + i) % bufferLength];

    lSampleTime = ((bufferLength - sampleTime - i) * 50) % 1000; // Increment the sample time by 50ms

    const backgroundColor = "rgb(0, 0, 0)";

    // Draw the background rectangle with the selected color
    canvasContext.fillStyle = backgroundColor;
    canvasContext.fillRect(xPosition, 0, barWidth, canvasHeight);

    if (remoteBarHeight > 0) {
      // Draw the remote audio frequency bar in green
      // canvasContext.fillStyle = 'rgb(50, 200, 50)';
      canvasContext.fillStyle = "rgb(36, 200, 56)";
      // canvasContext.fillRect(xPosition, canvasHeight - remoteBarHeight, narrowBarWidth, remoteBarHeight);
      canvasContext.fillRect(
        xPosition + barGapWidth,
        canvasHeight - remoteBarHeight,
        narrowBarWidth,
        remoteBarHeight
      );
    }

    // Let local bar override remote bar
    if (localBarHeight > 0) {
      // Draw the local microphone frequency bar
      // canvasContext.fillStyle = 'rgb(200, 50, 50)';
      canvasContext.fillStyle = "rgb(200, 52, 36)";
      // canvasContext.fillRect(xPosition, canvasHeight - localBarHeight, barWidth, localBarHeight);
      canvasContext.fillRect(
        xPosition + barGapWidth,
        canvasHeight - localBarHeight,
        narrowBarWidth,
        localBarHeight
      );
    }

    // Draw the external marker
    if (markerValue !== undefined) {
      canvasContext.fillStyle = markerValue; // color per requested
      // canvasContext.fillStyle = 'rgb(239, 255, 0)';   // neon yellow
      canvasContext.fillRect(xPosition, 0, externalMarkerWidth, canvasHeight);
    } else if (lSampleTime === 0) {
      // at the start of each second interval, set the background edge color to white
      canvasContext.fillStyle = "rgb(211, 211, 211)";
      canvasContext.fillRect(xPosition, 0, timeMarkerWidth, canvasHeight);
    }

    xPosition += barWidth;
  }
}

// Initialize minInputVolume and maxInputVolume to the extreme opposite values
let minInputVolume = Infinity;
let maxInputVolume = -Infinity;

let minOutputVolume = Infinity;
let maxOutputVolume = -Infinity;

let externalMarker = undefined;

// Add an event listener to the "Call" button
function analyze(call) {
  console.log("Call button clicked");
  // Assuming 'call' is your Twilio Call object
  call.on("volume", function (inputVolume, outputVolume) {
    // inputVolume and outputVolume are between -100 (silence) and 0 (maximum volume)

    // only fill up to 3/4 of the canvas height
    const maxValue = (3 * canvas.height) / (4 * devicePixelRatio);

    // Update minInputVolume and maxInputVolume
    minInputVolume = Math.min(minInputVolume, inputVolume);
    maxInputVolume = Math.max(maxInputVolume, inputVolume);

    // Update minOutputVolume and maxOutputVolume
    minOutputVolume = Math.min(minOutputVolume, outputVolume);
    maxOutputVolume = Math.max(maxOutputVolume, outputVolume);

    // Map inputVolume from the range [minInputVolume, maxInputVolume] to the range [0, 255]
    let volumeLevel =
      ((inputVolume - minInputVolume) / (maxInputVolume - minInputVolume)) *
      maxValue;
    volumeLevel = Math.max(0, Math.min(maxValue, volumeLevel)); // Clamp the value between 0 and 255

    // Map outputVolume from the range [minOutputVolume, maxOutputVolume] to the range [0, 255]
    let remoteVolumeLevel =
      ((outputVolume - minOutputVolume) / (maxOutputVolume - minOutputVolume)) *
      maxValue;
    remoteVolumeLevel = Math.max(0, Math.min(maxValue, remoteVolumeLevel)); // Clamp the value between 0 and 255

    // Add the volume level to the buffer
    localVolumeBuffer[bufferIndex] = volumeLevel;

    // Add the remote volume level to the buffer and update the buffer index
    remoteVolumeBuffer[bufferIndex] = remoteVolumeLevel;

    // Add the external marker to the buffer
    if (externalMarker !== undefined) {
      markerBuffer[bufferIndex] = externalMarker;
      externalMarker = undefined;
    } else {
      // Clear it in case the buffer has rolled over
      markerBuffer[bufferIndex] = undefined;
    }

    // Update the buffer index
    bufferIndex = (bufferIndex + 1) % bufferLength;

    // Increment sampleTime
    sampleTime++;
    if (sampleTime % 20 === 0) {
      // console.log(
      //   "sampleTime: " + sampleTime + ", bufferIndex: " + bufferIndex
      // );
      // console.log("input volume", inputVolume, "output volume", outputVolume);
    }

    // Call the draw function
    draw();
  });
}

export function addMarkerToVisualizer(color) {
  console.log("adding marker to audio visualizer, color: " + color);
  if (color === "orange") {
    externalMarker = "rgb(255, 165, 0)"; // neon orange;
  } else if (color === "green") {
    externalMarker = "rgb(57, 255, 20)"; // neon orange;
  } else {
    externalMarker = "rgb(239, 255, 0)"; // neon yellow;
  }
}

const exports = {
  setupAudioVisualizerCanvas,
  addMarkerToVisualizer,
  analyze,
};

export default exports;


================================================
FILE: client/src/ui-components/AppHeader.js
================================================
import { useState } from "react";
import {
  Box,
  Heading,
  Topbar,
  TopbarActions,
  Button,
  ButtonGroup,
  Tooltip,
  page,
  MenuButton,
  useMenuState,
  Menu,
  MenuItem,
} from "@twilio-paste/core";

import { LogoTwilioIcon } from "@twilio-paste/icons/esm/LogoTwilioIcon";
import { MenuIcon } from "@twilio-paste/icons/esm/MenuIcon";
import { CallActiveIcon } from "@twilio-paste/icons/esm/CallActiveIcon";
import { UsersIcon } from "@twilio-paste/icons/esm/UsersIcon";
import { HistoryIcon } from "@twilio-paste/icons/esm/HistoryIcon";
import { DirectoryIcon } from "@twilio-paste/icons/esm/DirectoryIcon";

const styles = {
  wrapper: { width: "100%" },
  headTwoColumnLayout: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    width: "100%",
    padding: "20px",
  },
  headLeftColumn: {
    width: "200px",
    flexShrink: 0,
    display: "flex",
    alignItems: "center",
  },
  headRightColumn: {
    flex: 1,
    textAlign: "left",
    color: "#ffffff",
  },
};

const AppHeader = (props) => {
  const menu = useMenuState();

  const handlePageClick = (page) => {
    props.setCurrentPage(page);
    menu.hide();
  };

  let layout = (
    <Box>
      <Topbar id="header">
        <TopbarActions justify="start">
          <Box display="flex" alignItems="center">
            <Box paddingRight="space20">
              <LogoTwilioIcon
                size={"sizeIcon50"}
                color="red"
                decorative={false}
                title="Description of icon"
              />
            </Box>
            <Heading
              marginBottom="space0"
              paddingLeft="space30"
              as="h2"
              variant="heading20"
              color={{ color: "#ffffff" }}
            >
              ConversationRelay
            </Heading>
          </Box>
        </TopbarActions>
        <TopbarActions justify="end">
          <Box display={["none", "none", "block"]}>
            <ButtonGroup attached>
              <Tooltip text="Demo ConversationRelay">
                <Button
                  variant="secondary"
                  disabled={props.currentPage === "demo"}
                  onClick={() => handlePageClick("demo")}
                >
                  <CallActiveIcon decorative />
                  Demo
                </Button>
              </Tooltip>
              {/* <Tooltip text="Manage Users">
                <Button
                  variant="secondary"
                  disabled={props.currentPage === "users"}
                  onClick={() => handlePageClick("users")}
                >
                  <UsersIcon decorative />
                  Users
                </Button>
              </Tooltip> */}
              <Tooltip text="Manage AI Experiences">
                <Button
                  variant="secondary"
                  disabled={props.currentPage === "useCases"}
                  onClick={() => handlePageClick("useCases")}
                >
                  <DirectoryIcon decorative />
                  Use Cases
                </Button>
              </Tooltip>
              <Tooltip text="View Previous Calls">
                <Button
                  variant="secondary"
                  disabled={props.currentPage === "calls"}
                  onClick={() => handlePageClick("calls")}
                >
                  <HistoryIcon decorative />
                  Call History
                </Button>
              </Tooltip>
            </ButtonGroup>
          </Box>
          {/* Responsive for mobile hamburger menu */}
          <Box display={["block", "block", "none"]}>
            <MenuButton {...menu} variant="primary_icon">
              <MenuIcon decorative={false} size="sizeIcon80" title="AppMenu" />
            </MenuButton>
            <Menu {...menu} aria-label="App Menu">
              <MenuItem
                {...menu}
                onClick={() => handlePageClick("demo")}
                disabled={props.currentPage === "demo"}
              >
                <Box display="flex" alignItems="center" columnGap="space30">
                  <CallActiveIcon decorative />
                  Demo
                </Box>
              </MenuItem>

              {/* <MenuItem
                {...menu}
                onClick={() => handlePageClick("users")}
                disabled={props.currentPage === "users"}
              >
                <Box display="flex" alignItems="center" columnGap="space30">
                  <UsersIcon decorative />
                  Users
                </Box>
              </MenuItem> */}

              <MenuItem
                {...menu}
                onClick={() => handlePageClick("useCases")}
                disabled={props.currentPage === "useCases"}
              >
                <Box display="flex" alignItems="center" columnGap="space30">
                  <DirectoryIcon decorative />
                  Use Cases
                </Box>
              </MenuItem>

              <MenuItem
                {...menu}
                onClick={() => handlePageClick("calls")}
                disabled={props.currentPage === "calls"}
              >
                <Box display="flex" alignItems="center" columnGap="space30">
                  <HistoryIcon decorative />
                  Call History
                </Box>
              </MenuItem>
            </Menu>
          </Box>
        </TopbarActions>
      </Topbar>
    </Box>
  );
  return layout;
};
export default AppHeader;



================================================
FILE: client/src/ui-components/Main.js
================================================
import { useState, useEffect, useRef } from "react";
import axios from "axios";
import { Device } from "@twilio/voice-sdk";

import { useAtom } from "jotai";
import { appDevice, appCurrentCall } from "../jotaiState/appState";

import { Theme } from "@twilio-paste/core/dist/theme";

import { updateUserHelper } from "../helpers/clientDataHelper";

import { Flex, Box, Grid, Column, Stack, Alert } from "@twilio-paste/core";

import AppHeader from "./AppHeader";
import StartCard from "../ui-components/StartCard";
import BotProperties from "./BotConfiguration/BotProperties";
import Audiovisualizer from "./Audiovisualizer/Audiovisualizer";
import Transcript from "./Transcription/Transcript";
import { setupAnalyzer } from "../helpers/utils";
import { use } from "react";

const styles = {
  wrapper: {
    margin: "20px",
  },
};
const Main = () => {
  const [identity, setIdentity] = useState("browser-client");
  //const [device, setDevice] = useState();

  const [device, setDevice] = useAtom(appDevice); // Jotai state for device
  const [loading, setLoading] = useState(true);
  const [token, setToken] = useState("");

  // Client Websocket
  const transcriptRef = useRef();
  // const [currentCall, setCurrentCall] = useState(null);
  const [currentCall, setCurrentCall] = useAtom(appCurrentCall); // Jotai state for current call

  const [users, setUsers] = useState([]); // all app users ( server > data > users.json )
  const [selectedUser, setSelectedUser] = useState(null); // current app user
  const [useCases, setUseCases] = useState([]); // all use cases defined in the app ( server > data > use-cases.json )
  const [selectedUseCase, setSelectedUseCase] = useState(null); // current use case selected by the user

  // Alert statealert state for updating current user configuration
  const [showAlert, setShowAlert] = useState(false);
  const [alertMessage, setAlertMessage] = useState("");
  const [alertType, setAlertType] = useState("neutral");

  // State to trigger reloading of users and use cases
  const [reload, setReload] = useState(false);

  let voiceToken = useRef("");

  // Setup Audiovisualizer
  let localStream = null; //update useRef / useState
  let remoteStream = null; //update useRef

  const [localAnalyser, setLocalAnalyser] = useState(null);
  const [remoteAnalyser, setRemoteAnalyser] = useState(null);

  // Fetch defined use case from the backend
  useEffect(() => {
    const fetchUseCases = async () => {
      const useCasesURL = process.env.REACT_APP_GET_ALL_USE_CASE_URL;
      try {
        const response = await axios.get(useCasesURL);
        setUseCases(response.data);
      } catch (error) {}
    };
    fetchUseCases();
  }, []);

  // Fetch defined user from the backend
  useEffect(() => {
    const findUser = (users) => {
      const user = users.find((user) => user.key === identity)?.value;
      if (user) {
        setSelectedUser(user);
      } else {
        alert(
          "No user found with the specified identity. Please check the identity and try again."
        );
      }
    };

    // Get all users from backend
    const fetchUsers = async () => {
      const usersURL = process.env.REACT_APP_GET_ALL_USERS_URL;
      try {
        const response = await axios.get(usersURL);
        setUsers(response.data);
        findUser(response.data);
      } catch (error) {
        console.error("Error fetching users: ", error);
      }
    };
    fetchUsers();
  }, [reload]);

  // Register Voice Client & Twilio Device Handlers
  useEffect(() => {
    const registerTwilioDeviceHandlers = (device) => {
      device.on("registered", () => console.log("✅ Device registered"));
      device.on("incoming", (conn) => {
        console.log("📞 Incoming call", conn);
        conn.accept();
      });
      device.on("disconnect", () => console.log("🔌 Disconnected"));
      device.on("error", (e) => console.error("❌ Device error:", e));
      device.on("cancel", () => console.log("❎ Call cancelled"));

      device.on("tokenWillExpire", async (dev) => {
        console.log("Device token is expiring\n");
        const registerVoiceClientURL =
          process.env.REACT_APP_REGISTER_VOICE_CLIENT_URL;
        const res = await axios.get(
          registerVoiceClientURL + "?phone=" + identity
        );
        voiceToken.current = res.data;
        setToken(res.data);
        dev.updateToken(res.data);
      });
    };

    // Create a new Twilio Device instance
    const createVoiceDevice = async () => {
      //  get Token from the backend
      const myDevice = await new Device(voiceToken.current, {
        rtcConfiguration: {
          iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }],
          iceTransportPolicy: "all",
          bundlePolicy: "balanced",
          rtcpMuxPolicy: "require",
          sdpSemantics: "unified-plan",
        },
        audioConstraints: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
        },
        logLevel: 5,
        codecPreferences: ["opus", "pcmu"],
      });
      setDevice(myDevice);

      registerTwilioDeviceHandlers(myDevice);
      myDevice.register();
      setLoading(false);
    };

    // create the get token, create/register device
    const registerVoiceClient = async () => {
      console.log("Registering voice client with phone number: ", identity);
      if (!voiceToken.current) {
        try {
          const registerVoiceClientURL =
            process.env.REACT_APP_REGISTER_VOICE_CLIENT_URL;
          const res = await axios.get(
            registerVoiceClientURL + "?phone=" + identity
          );
          voiceToken.current = res.data;
          setToken(res.data);
          createVoiceDevice();
        } catch (e) {
          console.log(e);
        }
      }
    };
    registerVoiceClient(identity);
  }, []);

      useEffect(() => {
        if (showAlert) {
            const timer = setTimeout(() => {
                setShowAlert(false);
            }, 5000); // Hide alert after 5 seconds
            return () => clearTimeout(timer);
        }
    },[showAlert])

  // Handler to iniitate the Ai conversations
  // forwarded through props to StartCard component
  const placeCall = async (phone) => {
    if (device && !currentCall) {
      console.log("Placing call to: ", phone);
      let params = {
        From: "browser-client",
      };
      const call = await device.connect(params);

      if (call) {
        call.on("accept", (call) => {
          console.log("✅ Call connected");
        });

        // Set local and remote streams for audio visualizer
        call.on("volume", (inputVolume, outputVolume) => {
          if (outputVolume > 0) {
            if (!localStream) {
              localStream = call.getLocalStream();
              setLocalAnalyser(setupAnalyzer(localStream));
            }
          }
          if (inputVolume > 0) {
            if (!remoteStream) {
              remoteStream = call.getRemoteStream();
              setRemoteAnalyser(setupAnalyzer(remoteStream));
            }
          }
        });

        call.on("disconnect", () => {
          console.log("📞 Call ended");
          localStream = null;
          remoteStream = null;
        });
        call.on("error", (err) => console.error("❌ Call error:", err));
      } else {
        console.warn("🚫 No call object returned");
      }
      setCurrentCall(call);

      // Register Client Websocket
      if (transcriptRef.current) {
        console.log("Initializing websocket connection");
        transcriptRef.current.invokeSetupWebsockToController();
      }
    } else {
      console.log("Device not ready");
    }
  };

  // Handler to stop the Ai conversations
  // forwarded through props to StartCard component
  const stopCall = async () => {
    device.disconnectAll();
    setCurrentCall(null);
    if (transcriptRef.current) {
      transcriptRef.current.invokeCloseWebsockToController();
    }
  };

  // handler to update the user configuration
  // forwarded through props to BotProperties > useCaseCombo component
  const updateUser = async (agentParams) => {
    let data = {
      firstName: "Jane",
      lastName: "Doe",
      from: "browser-client",
      role: selectedUser.role,
      identity: selectedUser.identity,
      type: selectedUser.type,
      phone: selectedUser.phone,
      email: selectedUser.email,
      useCase: agentParams.useCase,
      conversationRelayParamsOverride: {
        language: "en-US",
        ttsProvider: agentParams.ttsProvider,
        voice: agentParams.voice,
        transcriptionProvider: agentParams.sttProvider,
        speechModel: agentParams.speechModel,
        interruptible: true        
      },
    };

    let resp = await updateUserHelper(data);
    if (resp.status === "success") {
      setAlertMessage("User configuration updated successfully");
      setAlertType("neutral");
      setShowAlert(true);
    } else {
      setAlertMessage("Failed to update user configuration");
      setAlertType("error");
      setShowAlert(true);
    }
    setReload(!reload);
  };

  // Main layout of the application
  let layout = (
    <div>
      <Box
        style={{ marginTop: 10 }}
        width="100%"
        height="100vh"
        padding="space50"
      >
        {showAlert && (
          <Alert
            variant={alertType}
            onDismiss={() => setShowAlert(false)}
            marginBottom="space40"
          >
            {alertMessage}
          </Alert>
        )}
        <Grid gutter="space40">
          <Column span={[12, 12, 8]}>
            <Box paddingTop="space50">
              <Stack orientation="vertical" spacing="space40">
                <StartCard placeCall={placeCall} stopCall={stopCall} />
                <Audiovisualizer
                  localAnalyser={localAnalyser}
                  remoteAnalyser={remoteAnalyser}
                />
                <Transcript ref={transcriptRef} identity={identity} />
              </Stack>
            </Box>
          </Column>
          <Column span={[12, 12, 4]}>
            <Box paddingTop="space50">
              <BotProperties
                useCases={useCases}
                selectedUser={selectedUser}
                updateUser={updateUser}
              />
            </Box>
          </Column>
        </Grid>
      </Box>
      {/* end Primary Box */}
    </div>
  );
  return layout;
};
export default Main;



================================================
FILE: client/src/ui-components/StartCard.js
================================================
import {
  Stack,
  Card,
  Heading,
  Paragraph,
  Button,
  // Tooltip,
} from "@twilio-paste/core";

import { useState } from "react";

import { StopIcon } from "@twilio-paste/icons/esm/StopIcon";
import { MicrophoneOnIcon } from "@twilio-paste/icons/esm/MicrophoneOnIcon";

const StartCard = (props) => {
  const [pausePressed, setPausePressed] = useState(true);

  //  handler to start the ai conversation
  const handleStartClick = () => {
    props.placeCall("browser-client");
  };

  //  handler to end the ai conversation
  const handleStopClick = () => {
    props.stopCall();
  };

  //  layout for the start card
  let layout = (
    <Stack orientation="vertical" spacing="space40">
      <Card padding="space120">
        <Heading as="h2" variant="heading20">
          ConversationRelay WebRTC Quickstart
        </Heading>
        <Paragraph>
          Connecting to an AI Agent is simple. Press the button below to get
          started.
        </Paragraph>
        <Stack orientation={"horizontal"} spacing="space40">
          <Button
            variant="secondary_icon"
            pressed={pausePressed}
            onClick={() => {
              if (pausePressed) {
                handleStartClick();
              } else {
                handleStopClick();
              }
              setPausePressed(!pausePressed);
            }}
          >
            Talk to ConversationRelay Agent
            {pausePressed ? (
              <MicrophoneOnIcon decorative />
            ) : (
              <StopIcon decorative color="colorTextError" />
            )}
          </Button>
        </Stack>
      </Card>
    </Stack>
  );
  return layout;
};
export default StartCard;



================================================
FILE: client/src/ui-components/Wrapper.js
================================================
import { useEffect } from "react";
import { useAtom } from "jotai";

import { appPage, appDevice, appCurrentCall } from "../jotaiState/appState"
import { Flex, Box } from "@twilio-paste/core";

import { Theme } from "@twilio-paste/core/dist/theme";

import Main from "./Main";
import Users from "./Users/Users";
import UseCases from './UseCases/UseCases'
import CallHistory from "./CallHistory/CallHistory";
import AppHeader from "./AppHeader";

const styles = {
  wrapper: { width: "100%" },

  headTwoColumnLayout: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    width: "100%",
    padding: "20px",
  },
  headLeftColumn: {
    width: "200px",
    flexShrink: 0,
    display: "flex",
    alignItems: "center",
  },
  headRightColumn: {
    flex: 1,
    textAlign: "left",
    color: "#ffffff",
  },
};

const Wrapper = () => {
  const [page, setPage] = useAtom(appPage);
  const [device, setDevice] = useAtom(appDevice);
  const [currentCall, setCurrentCall] = useAtom(appCurrentCall);


  // useEffect to handle device disconnection when page changes
  // This ensures that when the user navigates away from the 'demo' page,
  // the device disconnects from any ongoing calls or connections.
  useEffect(() => {
    if(page !='demo'&& device) {
      device.disconnectAll()
      setCurrentCall(null)

      ;}
  },[page]
)

  // handler to manage page selection
  const showPage = (page) => {
    switch (page) {
      case "demo":
        return <Main />;
      case "users":
        return <Users />;
      case "useCases":
        return <UseCases />;
      case "calls":
        return <CallHistory />;
      default:
        return <Main />;
    }
  };

  // handler to manage page selection
  const handlePageClick = (page) => {
    setPage(page);
  };

  // render component
  let layout = (
    <Theme.Provider theme="Twilio">
      <Flex>
        <Flex grow>
          <Box width="100%">
            <AppHeader currentPage={page} setCurrentPage={handlePageClick} />
            <Box>{showPage(page)}</Box>
          </Box>
        </Flex>
      </Flex>
    </Theme.Provider>
  );
  return layout;
};
export default Wrapper;



================================================
FILE: client/src/ui-components/Audiovisualizer/Audiovisualizer.js
================================================
import React, { useEffect, useRef } from "react";
import { Avatar, Box, Flex, Heading, Card, Button } from "@twilio-paste/core";
import { AgentIcon } from "@twilio-paste/icons/esm/AgentIcon";
import { ProductAutopilotIcon } from "@twilio-paste/icons/esm/ProductAutopilotIcon";

const Audiovisualizer = ({ localAnalyser, remoteAnalyser }) => {
  const canvasRef = useRef();

  useEffect(() => {
    if (!localAnalyser || !remoteAnalyser) return;

    const canvas = canvasRef.current;
    const container = canvas.parentElement;
    const ctx = canvas.getContext("2d");

    remoteAnalyser.fftSize = 1024;
    localAnalyser.fftSize = 1024;
    const localData = new Uint8Array(localAnalyser.frequencyBinCount);
    const remoteData = new Uint8Array(remoteAnalyser.frequencyBinCount);

    const resizeCanvas = () => {
      requestAnimationFrame(() => {
        const { width, height } = container.getBoundingClientRect();
        canvas.width = width;
        canvas.height = height;
      });
    };

    const observer = new ResizeObserver(resizeCanvas);
    observer.observe(container);
    resizeCanvas();

    const draw = () => {
      requestAnimationFrame(draw);

      const width = canvas.width;
      const height = canvas.height;
      const centerY = height / 2;

      ctx.clearRect(0, 0, width, height);

      // Remote analyser
      ctx.fillStyle = "#0E7C3A";
      const remoteBarWidth = (width * 2) / remoteData.length;
      remoteAnalyser.getByteFrequencyData(remoteData);
      remoteData.forEach((val, i) => {
        const barHeight = (val / 255) * centerY;
        const x = i * remoteBarWidth;
        ctx.fillRect(x, centerY - barHeight, remoteBarWidth - 1, barHeight * 2);
      });

      // Local analyser
      ctx.fillStyle = "#2196f3";
      const localBarWidth = (width * 2) / localData.length;
      localAnalyser.getByteFrequencyData(localData);
      const MIN_THRESHOLD = 100;
      localData.forEach((val, i) => {
        const barHeight = val < MIN_THRESHOLD ? 0 : (val / 255) * centerY;
        const x = width - (i + 1) * localBarWidth;
        ctx.fillRect(x, centerY - barHeight, localBarWidth - 1, barHeight * 2);
      });

      ctx.strokeStyle = "#666";
      ctx.beginPath();
      ctx.moveTo(0, centerY);
      ctx.lineTo(width, centerY);
      ctx.stroke();
    };

    draw();

    return () => observer.disconnect();
  }, [localAnalyser, remoteAnalyser]);

  return (
    <Card padding="space120">
      <Heading as="h1" variant="heading30" marginBottom="space40">
        Audio Visualizer
      </Heading>
      <Box width="100%" display={["flex", "flex", "flex"]}>
        <Avatar
          size="sizeIcon110"
          name="ConversationRelay Avatar"
          icon={ProductAutopilotIcon}
          color="decorative30"
        />
        <Box flexGrow={1} paddingX={"space50"}>
          <canvas
            ref={canvasRef}
            style={{
              width: "100%",
              height: "60px",
              display: "block",
            }}
          />
        </Box>
        <Avatar
          size="sizeIcon110"
          name="User Avatar"
          icon={AgentIcon}
          color="decorative20"
        />
      </Box>
    </Card>
  );
};

export default Audiovisualizer;



================================================
FILE: client/src/ui-components/BotConfiguration/BotProperties.js
================================================
import { Stack, Card } from "@twilio-paste/core";
import UseCaseCombo from "./UseCaseCombo";

const BotProperties = (props) => {
  //	layout for the bot properties
  let layout = (
    <Stack orientation="vertical" spacing="space40">
      <Card padding="space120">
        <UseCaseCombo
          useCases={props.useCases}
          selectedUser={props.selectedUser}
          updateUser={props.updateUser}
        />
      </Card>
    </Stack>
  );
  return layout;
};
export default BotProperties;



================================================
FILE: client/src/ui-components/BotConfiguration/UseCaseCombo.js
================================================
import { useState, useEffect } from "react";
import axios from "axios";

import {
  Form,
  FormControl,
  Label,
  Box,
  Select,
  Option,
  Card,
  Button,
  HelpText,
  Modal,
  ModalHeader,
  ModalHeading,
  ModalBody,
  Paragraph,
  Grid,
  Column,
  Heading,
} from "@twilio-paste/core";

//  default transcription and tts providers
//  these are used to populate the dropdowns
//  TODO: these should be fetched from the backend
const transcriptionProviders = [
  { name: "Google", value: "Google" },
  { name: "Deepgram", value: "Deepgram" },
];
const ttsProviders = [
  { name: "Google", value: "Google" },
  { name: "Amazon", value: "Amazon" },
  { name: "Eleven Labs", value: "ElevenLabs" },
];

const UseCaseCombo = (props) => {
  // local component state
  const [useCases, setUseCases] = useState(null);
  const [selectedUseCase, setSelectedUseCase] = useState(
    props.useCases[0] || null
  );
  const [description, setDescription] = useState(props.useCases[0]?.value?.description);

  const [voices, setVoices] = useState(null);
  const [selectedVoices, setSelectedVoices] = useState(null);

  const [selectedSttProvider, setSelectedSttProvider] = useState(null);
  const [selectedTtsProvider, setSelectedTtsProvider] = useState(null);
  const [selectedVoice, setSelectedVoice] = useState(null);
  const [speechModel, setSpeechModel] = useState(null);

  //   dialog state for the tts voice support information
  const [showVoiceDialog, setShowVoiceDialog] = useState(false);

  const [uiChange, setUiChange] = useState(false);

  //    initialize component bases on updates to usecases and selectedUser
  useEffect(() => {
    setUseCases(props.useCases);
    setSelectedUseCase(props.selectedUser?.useCase);

    // set selected parameters based on the selected user configuration
    setSelectedSttProvider(
      props.selectedUser?.conversationRelayParamsOverride?.transcriptionProvider
    );
    setSelectedTtsProvider(
      props.selectedUser?.conversationRelayParamsOverride?.ttsProvider
    );
    setSelectedVoice(
      props.selectedUser?.conversationRelayParamsOverride?.voice
    );
    setSpeechModel(
      props.selectedUser?.conversationRelayParamsOverride?.speechModel
    );
  }, [props.useCases, props.selectedUser]);

  // Fetch all voices from the backend
  useEffect(() => {
    // get all voices from backend ( data > transcriptionProviders.json )
    const getVoices = async () => {
      const voicesURL = process.env.REACT_APP_GET_TRANSCRIPTION_VOICE_URL;

      try {
        // Fetch all voices from the backend
        await axios.get(voicesURL).then((resp) => {
          setVoices(resp.data);
          // set the selected voiced based on the user settings
          const providerVoices = resp.data.find(
            (provider) =>
              provider.key ===
              props.selectedUser?.conversationRelayParamsOverride?.ttsProvider
          );
          setSelectedVoices(providerVoices);
          setSelectedVoice(
            props.selectedUser?.conversationRelayParamsOverride?.voice
          );
        });
      } catch (error) {
        console.error("Error fetching voices: ", error);
      }
    };
    getVoices();
  }, [props.useCases]);

  //    handler updating the use case selection
  const useCaseChange = (e) => {
    setUiChange(true);

    const selectedValue = e.target.value;

    const selectedItem = props.useCases.find(
      (item) => item.key === selectedValue
    );
    console.log("useCaseChange", selectedItem);
    if (selectedItem) {
      setSelectedUseCase(selectedItem.key);
      setSelectedSttProvider(
        selectedItem.value.conversationRelayParams.transcriptionProvider
      );
      setSelectedTtsProvider(
        selectedItem.value.conversationRelayParams.ttsProvider
      );
      setDescription(selectedItem.value.description);

      const providerVoices = voices.find(
        (provider) =>
          provider.key ===
          selectedItem.value.conversationRelayParams.ttsProvider
      );
      console.log("providerVoices", providerVoices);
      setSelectedVoices(providerVoices);
      const selVoice = providerVoices.value.find(
        (voice) =>
          voice.value === selectedItem.value.conversationRelayParams.voice
      );
      setSelectedVoice(selVoice.value);

      // set 'speech model' based on the selected use case
      selectedItem.value.conversationRelayParams.transcriptionProvider ===
      "Google"
        ? setSpeechModel("telephony")
        : setSpeechModel("nova-2-general");
    }
  };

  // handler updating the stt provider selection
  const handle_SttChange = (e) => {
    setUiChange(true);
    setSelectedSttProvider(e.target.value);
    e.target.value === "Google"
      ? setSpeechModel("telephony")
      : setSpeechModel("nova-2-general");
  };
  // handler updating the tts provider selection
  const handle_TtsChange = (e) => {
    setUiChange(true);
    const selectedValue = e.target.value;
    const selectedVoice = voices.find((voice) => voice.key === selectedValue);
    if (selectedVoice) {
      setSelectedTtsProvider(selectedValue);
      setSelectedVoices(selectedVoice);
      setSelectedVoice(selectedVoice?.value[0]?.value);
    }
  };

  // handler updating the voice selection
  const handle_VoiceChange = (e) => {
    setUiChange(true);
    setSelectedVoice(e.target.value);
  };

  // handler updating the user configuration
  // updateUser forward from main.js
  const handleUpdate = () => {
    setUiChange(false);
    props.updateUser({
      voice: selectedVoice,
      ttsProvider: selectedTtsProvider,
      sttProvider: selectedSttProvider,
      useCase: selectedUseCase,
      speechModel: speechModel,
    });
  };

  // handler showing the tts voice modal dialog
  const handleShowVoiceDialog = (e) => {
    e.preventDefault();
    setShowVoiceDialog(true);
  };

  // handler closing the tts voice modal  dialog
  const handleCloseVoiceDialog = (e) => {
    setShowVoiceDialog(false);
  };

  //  layout for the use case combo
  let layout = (
    <Form>
      <FormControl>
        <Heading as="h1" variant="heading30" marginBottom="space40">
          Demo Configuration
        </Heading>
        <Label htmlFor="useCaseSelect" required>
          Select a Use Case
        </Label>
        <Select
          id="useCaseSelect"
          htmlFor="useCaseSelect"
          value={selectedUseCase}
          onChange={(e) => useCaseChange(e)}
        >
          {useCases?.map((useCase) => {
            return (
              <Option key={useCase.key} value={useCase.key}>
                {useCase.value.title}
              </Option>
            );
          })}
        </Select>
        <Box as="div" marginTop="space40">
          <Label>Use Case Description</Label>
          <Paragraph>{description}</Paragraph>
        </Box>
        <Box as="div" marginTop="space40">
          {/* Transcription Provider select component */}
          <Box as={"div"}>
            <Label htmlFor="stt_provider" required>
              Transcription (STT) Provider
            </Label>
            <Select
              id="stt_provider"
              htmlFor="stt_provider"
              value={selectedSttProvider}
              onChange={handle_SttChange}
            >
              {transcriptionProviders.map((item) => {
                return (
                  <Option key={item.value} value={item.value}>
                    {item.name}
                  </Option>
                );
              })}
            </Select>
          </Box>

          {/* TTS Provider Select */}
          <Box as={"div"} marginTop="20px">
            <Label htmlFor="tts_provider" required>
              Text-to-Speech (TTS) Provider
            </Label>
            <Select
              id="tts_provider"
              htmlFor="tts_provider"
              value={selectedTtsProvider}
              onChange={handle_TtsChange}
            >
              {ttsProviders.map((item) => {
                return (
                  <Option key={item.value} value={item.value}>
                    {item.name}
                  </Option>
                );
              })}
            </Select>
          </Box>

          {/* Voice select component */}
          <Box as={"div"} marginTop="20px">
            <Label htmlFor="voice" required>
              Voice
            </Label>
            <Select
              id="voice"
              htmlFor="voice"
              value={selectedVoice}
              onChange={handle_VoiceChange}
            >
              {selectedVoices?.value?.map((item) => {
                return (
                  <Option key={item.value} value={item.value}>
                    {item.name} ({item.language})
                  </Option>
                );
              })}
            </Select>
            <HelpText variant="default">
              <Box
                style={{ textDecoration: "none" }}
                as="a"
                href="#"
                onClick={(e) => handleShowVoiceDialog(e)}
              >
                Voice support information
              </Box>
            </HelpText>
          </Box>

          <Box as={"div"} marginTop="20px">
            {uiChange && (
              <Label>
                <span style={{ color: "red" }}>Configuration has changed</span>
              </Label>
            )}
          </Box>

          <Box as={"div"} marginTop="20px">
            <Button
              style={{ float: "right" }}
              disabled={!uiChange}
              variant={uiChange ? "destructive" : "primary"}
              onClick={(e) => handleUpdate(e)}
            >
              Save Configuration
            </Button>
          </Box>
        </Box>
      </FormControl>

      <Modal
        ariaLabelledby={"voiceDialog"}
        isOpen={showVoiceDialog}
        onDismiss={(e) => handleCloseVoiceDialog(e)}
        size="default"
      >
        <ModalHeader>
          <ModalHeading as="h3" id={"voiceDialog"}>
            ConversationRelay: TTS Voice Support
          </ModalHeading>
        </ModalHeader>
        <ModalBody>
          <Paragraph>
            ConversationRelay supports a wide variety of TTS voices (2000+)
            from several providers (Google, Amazon and Eleven Labs).
          </Paragraph>
          <Paragraph>
            This demo highlights only a small subset of the available voices.
          </Paragraph>
          <Paragraph>
            For complete details on supported providers and genders, languages
            and voice support, please refer to the product documentation.
          </Paragraph>
          <Grid gutter="space40" marginTop="space40">
            <Column span={6}>
              <Box as="div" style={{ textAlign: "center" }}>
                <Box
                  as="a"
                  href="https://www.twilio.com/docs/voice/twiml/say/text-speech#available-voices-and-languages"
                  target="_blank"
                >
                  Google and Amazon Voices
                </Box>
              </Box>
            </Column>
            <Column span={6}>
              <Box as="div" style={{ textAlign: "center" }}>
                <Box
                  as="a"
                  href="https://www.twilio.com/docs/voice/twiml/connect/conversationrelay#additional-tts-voices-available-for-conversationrelay"
                  target="_blank"
                >
                  Eleven Labs Voices
                </Box>
              </Box>
            </Column>
          </Grid>
          <Paragraph>&nbsp;</Paragraph>
        </ModalBody>
      </Modal>
    </Form>
  );
  return layout;
};
export default UseCaseCombo;



================================================
FILE: client/src/ui-components/CallHistory/CallHistory.js
================================================
import {
    Grid, Column, Card
} from '@twilio-paste/core'

import CallList from './CallList'

const CallHistory = () => {
    let layout =  (
        <div  style={{margin: '20px'}}>
            <Grid gutter="space100">
                <Column span={12}>
                    <CallList />
                </Column>
            </Grid>
        </div>
    )
    return layout
}
export default CallHistory;


================================================
FILE: client/src/ui-components/CallHistory/CallList.js
================================================
import { useState, useEffect } from "react";
import axios from "axios";
import {
  Grid,
  Column,
  Alert,
  Tooltip,
  Heading,
  Card,
  Box,
  Input,
  AlertDialog,
  Button,
  Table,
  THead,
  TBody,
  Tr,
  Th,
  Label,
  Paragraph,
} from "@twilio-paste/core";

import { SearchIcon } from "@twilio-paste/icons/esm/SearchIcon";

import SelectedCall from "./SelectedCall";
import CallRecord from "./CallRecord";

import { deleteCallHelper } from "../../helpers/clientDataHelper";

const CallList = () => {
  const [search, setSearch] = useState("");
  const [sessions, setSessions] = useState([]);
  const [filteredSessions, setFilteredSessions] = useState([]);
  const [selectedCall, setSelectedCall] = useState(null);
  const [selectedCallChat, setSelectedCallChat] = useState(null);
  const [reload, setReload] = useState(false);

  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [deleteCall, setDeleteCall] = useState(null);

  // Alert state alert state for updating current user configuration
  const [showAlert, setShowAlert] = useState(false);
  const [alertMessage, setAlertMessage] = useState("");
  const [alertType, setAlertType] = useState("neutral");

  // Fetch all users from the backend when the component mounts or reload state changes
  useEffect(() => {
    //   get all users from the backend
    const fetchSessions = async () => {
      const sessionsURL = process.env.REACT_APP_GET_ALL_SESSIONS_URL;

      try {
        const response = await axios.get(sessionsURL);
        setSessions(response.data);
        setFilteredSessions(response.data);
      } catch (error) {
        console.error("Error fetching users: ", error);
      }
    };
    fetchSessions();
  }, [reload]);

  useEffect(() => {
    const fetchSessionChat = async () => {
      if (selectedCall) {
        const sessionURL =
          process.env.REACT_APP_GET_SESSION_URL +
          `?callSid=${selectedCall.key}`;
        try {
          const response = await axios.get(sessionURL);
          console.log("session data", response.data);
          setSelectedCallChat(response.data.sessionData.sessionChats);
        } catch (error) {
          console.error("Error fetching session chat: ", error);
        }
      }
    };
    fetchSessionChat();
  }, [selectedCall]);

      useEffect(() => {
        if (showAlert) {
            const timer = setTimeout(() => {
                setShowAlert(false);
            }, 5000); // Hide alert after 5 seconds
            return () => clearTimeout(timer);
        }
    },[showAlert])
  // handler to clear search input and reset filtered users
  const clearSearch = () => {
    setSearch("");
    setFilteredSessions(sessions);
  };

  // handler to filter users based on search input
  const handleSearchChange = (event) => {
    setSearch(event.target.value.toLowerCase());
    setFilteredSessions(
      Object.values(sessions).filter((call) =>
        call.value.useCase
          .toLowerCase()
          .includes(event.target.value.toLowerCase())
      )
    );
  };

  // handler to select a user from the list and display their details
  const handleCallSelect = (call) => {
    console.log("handleUserSelect", call);
    setSelectedCall(call);
  };

  // handler to refresh the user list
  const handleRefresh = () => {
    setSelectedCall(null);
    setReload(!reload);
    setAlertMessage("Session list reloaded");
    setAlertType("neutral");
    setShowAlert(true);
  };

  // handler to display the delete user dialog
  const dialogDeleteCall = (call) => {
    setShowDeleteDialog(true);
    setDeleteCall(call);
  };

  const handleCloseDeleteDialog = () => {
    setShowDeleteDialog(false);
    setDeleteCall(null);
  };

  // handler to delete a user from the list
  const handleCallDelete = async () => {
    console.log("handleCallDelete", deleteCall);
    const callSid = { callSid: deleteCall.key };
    //  Call server API to create the user
    let resp = await deleteCallHelper(callSid);

    if (resp.status === "success") {
      setAlertMessage("Session history was successfully deleted");
      setAlertType("neutral");
      setShowAlert(true);
    } else {
      setAlertMessage("An error has occurred deleting this session data.");
      setAlertType("error");
      setShowAlert(true);
    }
    setShowDeleteDialog(false);
    setDeleteCall(null);
    setReload(!reload);
  };

  // handler to create new application users
  const createUser = async (user) => {
    let from = "";
    switch (user.type) {
      case "webRtc":
        from = `client:${user.identity}`;
        break;
      case "sip":
        from = `sip:${user.identity}`;
        break;
      case "phone":
        from = user.identity; // phone number
        break;
      default:
    }

    // structure the submitted user attributes
    const userAttributes = {
      identity: user.identity,
      from: from,
      role: "user",
      type: user.type,
      firstName: user.firstName,
      lastName: user.lastName,
      phone: user.phone,
      email: user.email,
    };
    let resp = await createUserHelper(userAttributes);
    if (resp.status === "success") {
      setAlertMessage("User configuration created successfully");
      setAlertType("neutral");
      setShowAlert(true);
      setReload(!reload);
    } else {
      setAlertMessage("An error has occurred creating this user.");
      setAlertType("error");
      setShowAlert(true);
    }
    dialog.hide();
  };

  // Render the users page
  let layout = (
    <div>
      <Box
        style={{ marginTop: 10 }}
        width="100%"
        height="100vh"
        padding="space50"
      >
        <Grid gutter="space40">
          <Column span={[12, 12, 12]}>
            <div style={{ marginBottom: "10px" }}>
              {/* Display application alerts */}
              {showAlert && (
                <Alert
                  variant={alertType}
                  onDismiss={() => setShowAlert(false)}
                  marginBottom="space40"
                >
                  {alertMessage}
                </Alert>
              )}
            </div>
          </Column>
          <Column span={[12, 12, 4]}>
            <Box paddingTop={"space50"}>
              <Card marginLeft={"100px"} width="100%">
                <Heading as="h3" variant="heading30" marginBottom="space40">
                  Ai Session History
                </Heading>
                <Paragraph marginBottom="space40">
                  Review past Ai Sessions, their details and transcripts.
                </Paragraph>

                <Box overflowY="auto" height="auto" maxHeight="500px">
                  <Box style={{ marginBottom: "20px" }} padding="space20">
                    <Label htmlFor="search">Filter</Label>
                    <Input
                      aria-describedby="search"
                      id="search"
                      name="email_address"
                      type="text"
                      value={search}
                      insertAfter={
                        <Tooltip text="Clear Search" placement="top">
                          <Button variant="link" onClick={clearSearch}>
                            <SearchIcon
                              decorative={false}
                              size="sizeIcon20"
                              title="Get more info"
                              onClick={clearSearch}
                            />
                          </Button>
                        </Tooltip>
                      }
                      onChange={(e) => {
                        handleSearchChange(e);
                      }}
                    />
                  </Box>
                  <Table>
                    <THead stickyHeader top={0}>
                      <Tr>
                        <Th>View</Th>
                        <Th>Ai Session</Th>
                        <Th>Delete</Th>
                      </Tr>
                    </THead>
                    <TBody>
                      {Object.values(filteredSessions).map((call, index) => (
                        <CallRecord
                          key={index}
                          call={call}
                          deleteCall={dialogDeleteCall}
                          callSelect={handleCallSelect}
                        />
                      ))}
                    </TBody>
                  </Table>
                </Box>
                <Box
                  as="div"
                  style={{
                    marginLeft: "10px",
                    marginRight: "10px",
                    marginTop: "20px",
                  }}
                >
                  <Button
                    variant="secondary"
                    size="small"
                    onClick={() => handleRefresh()}
                    fullWidth
                  >
                    Refresh
                  </Button>
                </Box>
              </Card>
            </Box>
          </Column>
          <Column span={[12, 12, 8]}>
            <Box paddingTop={"space50"}>
              <Card>
                <Heading as="h3" variant="heading30" marginBottom="space40">
                  Session Details
                </Heading>
                <Paragraph marginBottom="space40">
                  Details of the Ai session.
                </Paragraph>
                <SelectedCall
                  mode={"edit"}
                  selectedCall={selectedCall}
                  selectedCallChat={selectedCallChat}
                />
              </Card>
            </Box>
          </Column>
        </Grid>

        {/* Alert visualization for user deletion */}
        <AlertDialog
          heading="Delete Ai Session"
          isOpen={showDeleteDialog}
          onConfirm={handleCallDelete}
          onConfirmLabel="Delete"
          onDismiss={() => handleCloseDeleteDialog(false)}
          onDismissLabel="Cancel"
        >
          <Paragraph>
            Are you sure you want to delete this Ai Session?
          </Paragraph>
          <Paragraph>CallSid: {deleteCall?.key}</Paragraph>
          <Paragraph>
            This will delete all session and transcript data for the selected
            session.
          </Paragraph>
          <Paragraph>This action cannot be undone.</Paragraph>
        </AlertDialog>
      </Box>
    </div>
  );
  return layout;
};
export default CallList;



================================================
FILE: client/src/ui-components/CallHistory/CallRecord.js
================================================

import { Th, Tr, Td, Text, DetailText, Button } from '@twilio-paste/core'
import { DeleteIcon } from "@twilio-paste/icons/esm/DeleteIcon";
import { ShowIcon } from "@twilio-paste/icons/esm/ShowIcon";

const getTimeDate = (timestamp) => {
  const date = new Date(timestamp);
  return date.toLocaleString('en-US', { month: 'short', day: "numeric" , hour: "numeric", minute: "numeric"});
}

const CallRecord = (props) => {

    //  handler for user selection to edit/update
    const handleViewCall = () => {
        props.callSelect(props.call);
    }

    //  handler for user deletion
    const handleDeleteCall = () => {
      props.deleteCall(props.call);
    }

    let layout = (
        <Tr>
          <Td>
            <Button variant="secondary_icon" size="icon_small" aria-label="View call"  onClick={ () => handleViewCall()}>
              <ShowIcon decorative={false} title="View call"/>
            </Button>
          </Td>
          <Th scope="row">
              <Text color="blue" style={{cursor: 'pointer'}} as="span" onClick={() => handleViewCall()}>{ getTimeDate( props.call?.value.timeStamp) }</Text>
              <DetailText marginTop='space0'>Use Case: <b>{props.call.value.useCaseTitle}</b></DetailText>
              <DetailText marginTop='space0'>LLM: <b>{props.call.value.llmModel}</b></DetailText>
              <DetailText marginTop='space0'>User: <b>{props.call.value.userContext.firstName} {props.call.value.userContext.lastName}</b></DetailText>
              
              
          </Th>
          <Td>
              <Button variant="secondary_icon" size="icon_small" aria-label="Delete call" onClick={() => handleDeleteCall()}>
                <DeleteIcon decorative={false} title="Delete call" />
              </Button>            
          </Td>
        </Tr>
    )
    return layout
}
export default CallRecord;


================================================
FILE: client/src/ui-components/CallHistory/MessageLog.js
================================================
// import React from "react";
import { Avatar } from "@twilio-paste/core";

import {
  ChatLog,
  ChatMessage,
  ChatMessageMeta,
  ChatMessageMetaItem,
  ChatBubble,
} from "@twilio-paste/core";

import { AgentIcon } from "@twilio-paste/icons/esm/AgentIcon";
import { ProductAutopilotIcon } from "@twilio-paste/icons/esm/ProductAutopilotIcon";

// Helper to format time
function formatTime(ts) {
  const date = new Date(ts);
  return date.toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });
}

export default function MessageLog({ events = [] }) {
  // Sort events by timestamp and reverse so newest comes first
  const sortedEvents = [...events].sort(
    (a, b) => a.value.timestamp - b.value.timestamp
  );

  return (
    <ChatLog>
      {sortedEvents.map((event, index) => {
        let isTokens = false;
        if (event.value.role === "assistant" || event.value.role === "tool") {
          isTokens = true;
        }
        // Do not display messsages with empty content (tool calls)
        if (event.value.content === "") {
          return;
        }
        // Avoid display of "system" messages
        if (event.value.role === "system") {
          return;
        }
        // pull out content from tool calls
        let content = event.value.content;
        if (content.includes('"message":')) {
          content = JSON.parse(content).message;
        }

        return (
          <ChatMessage variant={isTokens ? "inbound" : "outbound"} key={index}>
            <ChatBubble backgroundColor="red">{content}</ChatBubble>
            <ChatMessageMeta aria-label="">
              <ChatMessageMetaItem>
                {!isTokens ? formatTime(event.value.timestamp) : <></>}
                <Avatar
                  size="sizeIcon50"
                  name={isTokens ? "Assistant" : "User"}
                  icon={isTokens ? ProductAutopilotIcon : AgentIcon}
                  color={isTokens ? "decorative30" : "decorative20"}
                />
                {isTokens ? formatTime(event.value.timestamp) : <></>}
              </ChatMessageMetaItem>
            </ChatMessageMeta>
          </ChatMessage>
        );
      })}
    </ChatLog>
  );
}



================================================
FILE: client/src/ui-components/CallHistory/SelectedCall.js
================================================
import {
  Box,
  Tabs,
  TabList,
  Tab,
  TabPanels,
  TabPanel,
  Table,
  THead,
  Tr,
  Th,
  TBody,
  Td,
  Paragraph,
} from "@twilio-paste/core";

import { useUID } from "@twilio-paste/core/uid-library";
import MessageLog from "./MessageLog";

import "../../styles/MessageLog.css"; // Import the CSS styles

const getTimeDate = (timestamp) => {
  const date = new Date(timestamp);
  return date.toLocaleString();
};

const SelectedCall = (props) => {
  const selectedId = useUID();

  let layout = (
    <div className="selected-call">
      {props ? (
        <div width="100%" height="100%">
          <Tabs selectedId={selectedId} baseId="horizontal-tabs-example">
            <TabList aria-label="My tabs">
              <Tab id={selectedId}>Details</Tab>
              <Tab>Transcript</Tab>
            </TabList>
            <TabPanels paddingTop="space20">
              <TabPanel>
                {props.selectedCall ? (
                  <div>
                    {/* <Box overflowY="auto" height="auto" maxHeight="500px" maxWidth="800px" overflowX="auto" > */}

                    <Box
                      overflowY="auto"
                      overflowX="auto"
                      maxHeight="80vh"
                      width="100%"
                      maxWidth={["100%", "100%", "100%"]} // full width on mobile, max 800px on desktop
                      padding="space40"
                    >
                      <Table tableLayout="fixed" variant="default" striped>
                        <THead stickyHeader top={0}>
                          <Tr verticalAlign="middle">
                            <Th
                              width={["size10", "size10", "size40"]}
                              textAlign="left"
                            >
                              Metric
                            </Th>
                            <Th>Value</Th>
                          </Tr>
                        </THead>
                        <TBody>
                          <Tr>
                            <Td>Call Id</Td>
                            <Td>{props.selectedCall?.key}</Td>
                          </Tr>
                          <Tr>
                            <Td>Caller</Td>
                            <Td>
                              {props.selectedCall?.value.userContext.firstName}{" "}
                              {props.selectedCall?.value.userContext.lastName}
                            </Td>
                          </Tr>
                          <Tr>
                            <Td>Channel</Td>
                            <Td>
                              {props.selectedCall?.value.userContext.from} (
                              {props.selectedCall?.value.userContext.type})
                            </Td>
                          </Tr>
                          <Tr>
                            <Td>Date</Td>
                            <Td>
                              {getTimeDate(props.selectedCall?.value.timeStamp)}
                            </Td>
                          </Tr>
                          <Tr>
                            <Td>Use Case</Td>
                            <Td>
                              {props.selectedCall?.value.userContext.useCase}
                            </Td>
                          </Tr>
                          <Tr>
                            <Td>LLM Model</Td>
                            <Td>{props.selectedCall?.value.llmModel}</Td>
                          </Tr>
                          <Tr>
                            <Td>TTS Provider</Td>
                            <Td>
                              {
                                props.selectedCall?.value.userContext
                                  ?.conversationRelayParamsOverride?.ttsProvider
                              }
                            </Td>
                          </Tr>
                          <Tr>
                            <Td>Language</Td>
                            <Td>
                              {
                                props.selectedCall?.value.userContext
                                  ?.conversationRelayParamsOverride?.language
                              }
                            </Td>
                          </Tr>

                          <Tr>
                            <Td>Voice</Td>
                            <Td>
                              {
                                props.selectedCall?.value.userContext
                                  ?.conversationRelayParamsOverride?.voice
                              }
                            </Td>
                          </Tr>
                          <Tr>
                            <Td>Transcription Provider</Td>
                            <Td>
                              {
                                props.selectedCall?.value.userContext
                                  ?.conversationRelayParamsOverride
                                  ?.transcriptionProvider
                              }
                            </Td>
                          </Tr>
                          <Tr>
                            <Td>Speech Model</Td>
                            <Td>
                              {
                                props.selectedCall?.value.userContext
                                  ?.conversationRelayParamsOverride?.speechModel
                              }
                            </Td>
                          </Tr>
                        </TBody>
                      </Table>
                    </Box>
                  </div>
                ) : (
                  <div style={{ marginTop: '100px', textAlign: "center" }}>
                      <Paragraph><span style={{color: 'red'}}>No selected call</span></Paragraph>
                  </div>
                )}
              </TabPanel>
              <TabPanel>
                {props.selectedCall ? (
                  <div>
                    <Paragraph>Scroll to see the full transcript.</Paragraph>
                    <Box
                      border="solid 1px #ccc"
                      borderRadius={"10px"}
                      overflowY="auto"
                      maxHeight={"500px"}
                    >
                      {props.selectedCallChat && (
                        <MessageLog events={props.selectedCallChat} />
                      )}
                    </Box>
                  </div>
                ) : (
                  <div style={{ marginTop: '100px', textAlign: "center" }}>
                      <Paragraph><span style={{color: 'red'}}>No selected use case</span></Paragraph>
                  </div>
                )}
              </TabPanel>
            </TabPanels>
          </Tabs>
        </div>
      ) : (
        <p>No call selected.</p>
      )}
    </div>
  );
  return layout;
};
export default SelectedCall;



================================================
FILE: client/src/ui-components/Transcription/MessageLog.js
================================================
// import React from "react";
import { Avatar } from "@twilio-paste/core";
import { AgentIcon } from "@twilio-paste/icons/esm/AgentIcon";
import { ProductAutopilotIcon } from "@twilio-paste/icons/esm/ProductAutopilotIcon";

import {
  ChatLog,
  ChatMessage,
  ChatMessageMeta,
  ChatMessageMetaItem,
  ChatBubble,
} from "@twilio-paste/core";

// Helper to format time
function formatTime(ts) {
  const date = new Date(ts);
  return date.toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });
}

export default function MessageLog({ events = [], showLatency = false }) {
  // Sort events by timestamp and reverse so newest comes first
  const sortedEvents = [...events].sort((a, b) => a.ts - b.ts).reverse(); // [{}, {}, {type: 'interrupt'}, ... {}]
  return (
    <ChatLog>
      {sortedEvents.map((event, index) => {
        const isTokens = event.name === "tokensPlayed";
        const isVoice = event.voicePrompt && event.type === "prompt";
        const isLatency = event.type === "latency";
        const isInterrupt = event.type === "interrupt";

        if (isTokens || isVoice) {
          const speaker = isTokens ? "bot" : "user";
          const content = isTokens ? event.value : event.voicePrompt;

          return (
            <ChatMessage
              variant={isTokens ? "inbound" : "outbound"}
              key={index}
            >
              <ChatBubble backgroundColor="red">{content}</ChatBubble>
              <ChatMessageMeta aria-label="">
                <ChatMessageMetaItem>
                  {!isTokens ? formatTime(event.ts) : <></>}
                  <Avatar
                    size="sizeIcon50"
                    name={isTokens ? "Assistant" : "User"}
                    icon={isTokens ? ProductAutopilotIcon : AgentIcon}
                    color={isTokens ? "decorative30" : "decorative20"}
                  />

                  {isTokens ? formatTime(event.ts) : <></>}
                </ChatMessageMetaItem>
              </ChatMessageMeta>
            </ChatMessage>
          );
        }

        if (isInterrupt) {
          return (
            <div key={index} className="message-container right">
              <div className="interrupt-message">Interrupted</div>
            </div>
          );
        }
        if (showLatency) {
          if (isLatency) {
            return (
              <ChatMessage variant={"inbound"} key={index}>
                <ChatBubble>Response Latency: {event.value}ms</ChatBubble>

                <ChatMessageMeta>
                  <ChatMessageMetaItem></ChatMessageMetaItem>
                </ChatMessageMeta>
              </ChatMessage>
            );
          } else {
            return null;
          }
        }

        return null;
      })}
    </ChatLog>
  );
}



================================================
FILE: client/src/ui-components/Transcription/Transcript.js
================================================
import { useState, useRef, useImperativeHandle, forwardRef } from "react";
import { Stack, Card, Flex, Heading, Switch, Box } from "@twilio-paste/core";

// import MessageLog from "./MessageLog";
import MessageLog from "./MessageLog";
import "../../styles/MessageLog.css"; // Import the CSS styles

const Transcript = forwardRef((props, ref) => {
  const [socket, setSocket] = useState(null);
  const [showLatency, setShowLatency] = useState(false);
  const textLog = useRef(null);

  const [events, setEvents] = useState([]);

  // Invoke Websocket from Main
  useImperativeHandle(ref, () => ({
    invokeSetupWebsockToController() {
      setupWebsockToController();
    },
    invokeCloseWebsockToController() {
      closeWebsockToController();
      console.log("Websocket connection closed");
    },
  }));

  const setupWebsockToController = async () => {
    // For developing use this url to get events without having to re-build
    // TO DO - update this socket
    console.log("registering socket");
    const socket = new WebSocket(
      "ws://localhost:3000/?callSid=" + props.identity
    );
    // const socket = new WebSocket("/?callSid=" + props.identity);
    setSocket(socket);
    // Reset events
    setEvents([]);

    // Connection opened
    socket.addEventListener("open", (event) => {
      socket.send(JSON.stringify({ message: "Connection established" }));
      console.log("Connection opened!");
    });

    let clientTs = 0;
    let agentTs = 0;
    let latency;

    // Listen for messages
    socket.addEventListener("message", (event) => {
      const data = JSON.parse(event.data);
      // console.log(data);

      if (data.type === "info" && data.name !== "tokensPlayed") {
        if (data.name === "clientSpeaking" && data.value === "off") {
          clientTs = data.ts;
        }
        if (data.name === "agentSpeaking" && data.value === "on") {
          agentTs = data.ts;
        }

        // latency is the total time in ms for agent to start speaking after client stops speaking
        latency = agentTs - clientTs;

        if (
          latency > 0 &&
          clientTs > 0 &&
          data.name === "agentSpeaking" &&
          data.value === "on"
        ) {
          console.log(`latency is ${latency}ms`);
          setEvents((prevEvents) => [
            ...prevEvents,
            { type: "latency", value: latency },
          ]);
        }
      }

      if (data.type === "interrupt") {
        setEvents((prevEvents) => [...prevEvents, data]);
      }

      if (data.type === "info" && data.name === "tokensPlayed") {
        setEvents((prevEvents) => [...prevEvents, data]);
      }

      if (data.type === "prompt") {
        setEvents((prevEvents) => [...prevEvents, data]);
      }
    });
  };

  const toggleLatency = () => {
    showLatency ? setShowLatency(false) : setShowLatency(true);
  };

  const closeWebsockToController = () => {
    if (socket) {
      socket.close();
      setSocket(null);
    }
  };

  let layout = (
    <Stack orientation="vertical" spacing="space40">
      <Card padding="space120">
        <Flex>
          <Flex>
            <Box>
              <Heading as="h1" variant="heading30" marginBottom="space40">
                Conversation Transcription
              </Heading>
            </Box>
          </Flex>
          <Flex grow></Flex>
          <Flex>
            <Box>
              <Switch
                id="latency-toggle"
                checked={showLatency}
                onChange={toggleLatency}
              >
                Show Latency
              </Switch>
            </Box>
          </Flex>
        </Flex>
                    <Box
                      overflowY="auto"
                      overflowX="auto"
                      maxHeight="50vh"
                      width="100%"
                      maxWidth={["100%", "100%", "100%"]} // full width on mobile, max 800px on desktop
                      padding="space40"
                      style={{border: '1px solid #eaeaea', borderRadius: '8px'}}
                    >
        <MessageLog events={events} showLatency={showLatency} />
        </Box>
      </Card>
    </Stack>
  );

  return layout;
});
export default Transcript;



================================================
FILE: client/src/ui-components/UseCases/AddUseCaseForm.js
================================================
import { useState, useEffect } from 'react';
import { 
    Card, Box, Input, TextArea, Heading,
    Button, Label, HelpText, Form, FormControl, 
 } from '@twilio-paste/core';

import UseCaseCombo from './UseCaseCombo';

import { v4 as uuidv4 } from 'uuid';

const AddUseCaseForm = (props) => {


        const [mode, setMode] = useState(props.mode);           // form mode ( edit, clone )
        const [title, setTitle] = useState('');
        const [description, setDescription] = useState('');
        const [welcomeGreeting, setWelcomeGreeting] = useState('');
        const [prompt, setPrompt] = useState('');


        const [selectedSttProvider, setSelectedSttProvider] = useState(null);
        const [selectedTtsProvider, setSelectedTtsProvider] = useState(null);
        const [selectedVoice, setSelectedVoice] = useState(null);
        const [speechModel, setSpeechModel] = useState(null);
        
        const [crParamsOverride, setCrParamsOverride] = useState('');
        const[typeUpdate, setTypeUpdate] = useState(false);
        const[uiChange, setUiChange] = useState(false);

        //  initialize local state for form and currently selected user
        useEffect(() => {
            // if (props.mode === 'edit') {
                setTitle(props.selectedUseCase?.value.title || '')
                setDescription(props.selectedUseCase?.value.description || '');
                setWelcomeGreeting(props.selectedUseCase?.value.conversationRelayParams?.welcomeGreeting || '')
                setPrompt(JSON.parse(props.selectedUseCase?.value.prompt) || '');

                setSelectedSttProvider(props.selectedUseCase?.value.conversationRelayParams?.transcriptionProvider || null);
                setSelectedTtsProvider(props.selectedUseCase?.value.conversationRelayParams?.ttsProvider || null);
                setSelectedVoice(props.selectedUseCase?.value.conversationRelayParams?.voice || null);

                if(props.selectedUseCase?.value.conversationRelayParams?.transcriptionProvider==='Google'){
                    setSpeechModel('telephony')
                } else { setSpeechModel('nova-2-general')}

                setCrParamsOverride(props.selectedUseCase?.value.conversationRelayParams);
            // }
        },[props.selectedUseCase])

    //  handler to clear the form - props in Users component
    const handleClearForm = () => { 
        props.clearForm()
        setUiChange(false) 
    }

    //  handlers to update local state for first name
    const handleTitleChange = (e) => { 
        setUiChange(true)
        setTitle(e.target.value) 
    }

    //  handler to update local state for last name
    const handleDescriptionChange = (e) => { 
        setUiChange(true)
        setDescription(e.target.value)
    }

    const handleWelcomeGreetingChange = (e) => { 
    setUiChange(true)
    setWelcomeGreeting(e.target.value)
    }

    const handlePromptChange = (e) => {
        setUiChange(true)
        setPrompt(e.target.value)
    }


    // handler to update local state for email
    const handleUiChange = (value) => {
        setUiChange(value)
    }

    const handlePropertyChange = (property, value) => {
        setUiChange(true)
        console.log('handlePropertyChange', property, value)
        switch (property) {
            case 'sttProvider':
                setSelectedSttProvider(value);
                break;
            case 'ttsProvider':
                setSelectedTtsProvider(value);
                break;
            case 'voice':
                setSelectedVoice(value);
                break;
            case 'speechModel':
                setSpeechModel(value);
                break;
            default:
                console.warn(`Unknown property: ${property}`);
        }
    }

    // handler to update user - pass user object to parent Users component
    const handleUpdateUseCase = () => {

        let role = ''
        let key = ''
        if(props.mode==='edit') { 
            key = props.selectedUseCase.key;
            role = props.selectedUseCase.value.role;
        } else {
            key = uuidv4()
            role = 'user' 
        }
        const useCase = {
            mode: props.mode,
            key: key,
            value: {
                name: title.trim().toLowerCase(),
                title: title.trim(),
                description: description.trim(),
                role: role,
                prompt: JSON.stringify(prompt.trim()),
                tools: props.selectedUseCase.value.tools,
                dtmf: props.selectedUseCase.value.dtmf,
                conversationRelayParams: {
                    dtmfDetection: true,
                    interruptible: true,
                    ttsProvider: selectedTtsProvider,
                    voice: selectedVoice,
                    speechModel: speechModel,
                    transcriptionProvider: selectedSttProvider,
                    welcomeGreeting: welcomeGreeting,
                }
            }
        }
        console.log('useCase', useCase)
        props.updateUseCase(useCase)
        setUiChange(false)
    }


    // content to render
    let layout = (
        <Box padding="space60">
            <Form padding="space60" >
                <Card width="100%">
                    <Heading as="h2" htmlFor="title" marginBottom="space100">
                        { (props.mode === 'edit')? ' Edit/View existing use case': ' Cloning system use case'}
                    </Heading>
                    <FormControl >
                        <Label htmlFor="title" required>Title of Use Case</Label>
                                <Input
                                    type="text"
                                    id={'title'}
                                    name="title"
                                    value={title}
                                    disabled={props.disabled}
                                    onChange={(e) => handleTitleChange(e)}
                                    placeholder="Title of use case"
                                    required
                                />
                        <HelpText as="div" color="colorTextWeak">
                        A brief title for the use case 
                        </HelpText>
                        <div style={{marginBottom: '15px'}}></div>
                    </FormControl>
                    <FormControl>
                        <Label htmlFor="email" required>Use Case Description</Label>
                        <TextArea 
                            onChange={(e)=>{handleDescriptionChange(e)}} 
                            aria-describedby="message_help_text" 
                            id="description" 
                            name="description"
                            value={description}
                            disabled={props.disabled}
                            resize="vertical"
                            required />

                        <HelpText as="div" color="colorTextWeak">
                        A brief description of the use case 
                        </HelpText>
                        <div style={{marginBottom: '15px'}}></div>
                    </FormControl>  

                    <FormControl >
                        <Label htmlFor="welcomeGreeting" required>Welcome Greeting</Label>
                                <Input
                                    type="text"
                                    id={'welcomeGreeting'}
                                    name="welcomeGreeting"
                                    value={ welcomeGreeting}
                                    disabled={props.disabled}
                                    onChange={(e) => handleWelcomeGreetingChange(e)}
                                    placeholder="Simple greeting for the use case"
                                    required
                                />
                        <HelpText as="div" color="colorTextWeak">
                        A brief title for the use case 
                        </HelpText>
                        <div style={{marginBottom: '15px'}}></div>
                    </FormControl>  



                    <FormControl>
                        <Label htmlFor="email" required>Ai Prompt</Label>
                        <TextArea 
                            onChange={(e)=>{handlePromptChange(e)}} 
                            aria-describedby="message_help_text" 
                            id="prompt" 
                            name="prompt" 
                            resize="vertical"
                            value={prompt}
                            disabled={props.disabled}
                            required />

                        <HelpText as="div" color="colorTextWeak">
                        Descriptive prompting for your AI use case 
                        </HelpText>
                        <div style={{marginBottom: '15px'}}></div>
                    </FormControl>

                    <UseCaseCombo 
                        disabled={props.disabled}
                        uiChange={handleUiChange} 
                        selectedUseCase={props.selectedUseCase}
                        propertyChange={handlePropertyChange} 
                        />

                    <div style={{marginBottom: '25px'}}></div>
                    <FormControl>
                        <Box as={'div'} marginTop="20px" marginBottom="20px">
                            { uiChange && (
                                <Label><span style={{color:'red'}}>Configuration has changed</span></Label>
                            )}
                        </Box>
                        <div>
                            <div>
                            

                                    <div>
                                        <Button variant="secondary" type="button" style={{marginLeft: '10px'}} onClick={() => handleClearForm()}>
                                        Clear Form
                                        </Button> 
                                        <span style={{float: "right"}}>
                                            <Button
                                            disabled={!uiChange}
                                            variant={uiChange ? "destructive" : "primary"}
                                            onClick={(e) => handleUpdateUseCase(e)}
                                            >
                                            Save Configuration
                                            </Button>
                                        </span>
                                    </div>
                            
                            </div>
                        </div>
                    </FormControl>
                </Card>
            </Form>
        </Box>
    )
    return layout
}
export default AddUseCaseForm;




================================================
FILE: client/src/ui-components/UseCases/UseCaseCombo.js
================================================
import { useState, useEffect } from "react";
import axios from "axios";

import {
  FormControl,
  Label,
  Box,
  Select,
  Option,
  HelpText,
  Modal,
  ModalHeader,
  ModalHeading,
  ModalBody,
  Paragraph,
  Grid,
  Column,
} from "@twilio-paste/core";

//  default transcription and tts providers
//  these are used to populate the dropdowns
//  TODO: these should be fetched from the backend
const transcriptionProviders = [
  { name: "Google", value: "Google" },
  { name: "Deepgram", value: "Deepgram" },
];
const ttsProviders = [
  { name: "Google", value: "Google" },
  { name: "Amazon", value: "Amazon" },
  { name: "Eleven Labs", value: "ElevenLabs" },
];

const UseCaseCombo = (props) => {
  // local component state
  const [useCases, setUseCases] = useState(null);

  const [voices, setVoices] = useState(null);
  const [selectedVoices, setSelectedVoices] = useState(null);

  const [selectedSttProvider, setSelectedSttProvider] = useState(null);
  const [selectedTtsProvider, setSelectedTtsProvider] = useState(null);
  const [selectedVoice, setSelectedVoice] = useState(null);
  const [speechModel, setSpeechModel] = useState(null);

  //   dialog state for the tts voice support information
  const [showVoiceDialog, setShowVoiceDialog] = useState(false);
  const [uiChange, setUiChange] = useState(false);

  //    initialize component bases on updates to usecases and selectedUser
  useEffect(() => {
    // set selected parameters based on the selected user configuration
    setSelectedSttProvider(
      props.selectedUseCase?.value.conversationRelayParams?.transcriptionProvider
    );
    setSelectedTtsProvider(
      props.selectedUseCase?.value.conversationRelayParams?.ttsProvider
    );
    setSelectedVoice(
      props.selectedUseCase?.value.conversationRelayParams?.voice
    );
    // set the speech model based on the selected use case
    if(props.selectedUseCase?.value.conversationRelayParams?.transcriptionProvider ===
    "Google") {
      setSpeechModel("telephony"); 
      props.propertyChange('speechModel', "telephony")
    } else {
      setSpeechModel("nova-2-general");
      props.propertyChange('speechModel', "nova-2-general")
    }

    props.uiChange()
  }, [ props.selectedUseCase]);

  // Fetch all voices from the backend
  useEffect(() => {
    // get all voices from backend ( data > transcriptionProviders.json )
    const getVoices = async () => {
      const voicesURL = process.env.REACT_APP_GET_TRANSCRIPTION_VOICE_URL;

      try {
        // Fetch all voices from the backend
        await axios.get(voicesURL).then((resp) => {
          setVoices(resp.data);
          // set the selected voiced based on the user settings
          const providerVoices = resp.data.find(
            (provider) =>
              provider.key ===
              props.selectedUseCase?.value.conversationRelayParams?.ttsProvider
          );
          console.log("providerVoices", providerVoices);
          setSelectedVoices(providerVoices);
          setSelectedVoice(
            props.selectedUseCase?.value.conversationRelayParams?.voice
          );
        });
      } catch (error) {
        console.error("Error fetching voices: ", error);
      }
    };
    getVoices();
  }, [props.selectedUseCase]);

  // handler updating the stt provider selection
  const handle_SttChange = (e) => {
    props.uiChange(true)
    setSelectedSttProvider(e.target.value);
    props.propertyChange('sttProvider', e.target.value)
    if(e.target.value === "Google") {
      setSpeechModel("telephony"); 
      props.propertyChange('speechModel', "telephony")
    }else {
      setSpeechModel("nova-2-general");
      props.propertyChange('speechModel', "nova-2-general")
    }
  };

  // handler updating the tts provider selection
  const handle_TtsChange = (e) => {
    props.uiChange(true)
    const selectedValue = e.target.value;
    const selectedVoice = voices.find((voice) => voice.key === selectedValue);
    if (selectedVoice) {
      setSelectedTtsProvider(selectedValue);
      setSelectedVoices(selectedVoice);
      setSelectedVoice(selectedVoice?.value[0]?.value);

      props.propertyChange('ttsProvider', selectedValue)
      props.propertyChange('voice', selectedVoice?.value[0]?.value)
    }
  };

  // handler updating the voice selection
  const handle_VoiceChange = (e) => {
    props.uiChange(true)
    setSelectedVoice(e.target.value);
    props.propertyChange('voice', e.target.value)
  };

  // handler showing the tts voice modal dialog
  const handleShowVoiceDialog = (e) => {
    e.preventDefault();
    setShowVoiceDialog(true);
  };

  // handler closing the tts voice modal  dialog
  const handleCloseVoiceDialog = (e) => {
    setShowVoiceDialog(false);
  };

  //  layout for the use case combo
  let layout = (
    <div>
      <FormControl>
        <Box as="div" marginTop="space40">
          {/* Transcription Provider select component */}
          <Box as={"div"}>
            <Label htmlFor="stt_provider" required>
              Transcription (STT) Provider
            </Label>
            <Select
              id="stt_provider"
              htmlFor="stt_provider"
              value={selectedSttProvider}
              onChange={handle_SttChange}
              disabled={props.disabled}
            >
              {transcriptionProviders.map((item) => {
                return (
                  <Option key={item.value} value={item.value}>
                    {item.name}
                  </Option>
                );
              })}
            </Select>
          </Box>

          {/* TTS Provider Select */}
          <Box as={"div"} marginTop="20px">
            <Label htmlFor="tts_provider" required>
              Text-to-Speech (TTS) Provider
            </Label>
            <Select
              id="tts_provider"
              htmlFor="tts_provider"
              value={selectedTtsProvider}
              disabled={props.disabled}
              onChange={handle_TtsChange}
            >
              {ttsProviders.map((item) => {
                return (
                  <Option key={item.value} value={item.value}>
                    {item.name}
                  </Option>
                );
              })}
            </Select>
          </Box>

          {/* Voice select component */}
          <Box as={"div"} marginTop="20px">
            <Label htmlFor="voice" required>
              Voice
            </Label>
            <Select
              id="voice"
              htmlFor="voice"
              value={selectedVoice}
              disabled={props.disabled}
              onChange={handle_VoiceChange}
            >
              {selectedVoices?.value?.map((item) => {
                return (
                  <Option key={item.value} value={item.value}>
                    {item.name}
                  </Option>
                );
              })}
            </Select>
            <HelpText variant="default">
              <Box
                style={{ textDecoration: "none" }}
                as="a"
                href="#"
                onClick={(e) => handleShowVoiceDialog(e)}
              >
                Voice support information
              </Box>
            </HelpText>
          </Box>
        </Box>
      </FormControl>

      <Modal
        ariaLabelledby={"voiceDialog"}
        isOpen={showVoiceDialog}
        onDismiss={(e) => handleCloseVoiceDialog(e)}
        size="default"
      >
        <ModalHeader>
          <ModalHeading as="h3" id={"voiceDialog"}>
            Conversation Relay: TTS Voice Support
          </ModalHeading>
        </ModalHeader>
        <ModalBody>
          <Paragraph>
            Conversation Relay supports a wide variety of TTS voices (2000+)
            from several providers (Google, Amazon and Eleven Labs).
          </Paragraph>
          <Paragraph>
            This demo highlights only a small subset of the available voices.
          </Paragraph>
          <Paragraph>
            For complete details on supported providers and genders, languages
            and voice support, please refer to the product documentation.
          </Paragraph>
          <Grid gutter="space40" marginTop="space40">
            <Column span={6}>
              <Box as="div" style={{ textAlign: "center" }}>
                <Box
                  as="a"
                  href="https://www.twilio.com/docs/voice/twiml/say/text-speech#available-voices-and-languages"
                  target="_blank"
                >
                  Google and Amazon Voices
                </Box>
              </Box>
            </Column>
            <Column span={6}>
              <Box as="div" style={{ textAlign: "center" }}>
                <Box
                  as="a"
                  href="https://www.twilio.com/docs/voice/twiml/connect/conversationrelay#additional-tts-voices-available-for-conversationrelay"
                  target="_blank"
                >
                  Eleven Labs Voices
                </Box>
              </Box>
            </Column>
          </Grid>
          <Paragraph>&nbsp;</Paragraph>
        </ModalBody>
      </Modal>
    </div>
  );
  return layout;
};
export default UseCaseCombo;



================================================
FILE: client/src/ui-components/UseCases/UseCaseRecord.js
================================================

import { Th, Tr, Td, Text, DetailText, Button } from '@twilio-paste/core'
import { DeleteIcon } from "@twilio-paste/icons/esm/DeleteIcon";
import { EditIcon } from "@twilio-paste/icons/esm/EditIcon";
import { CopyIcon } from "@twilio-paste/icons/esm/CopyIcon";

const UseCaseRecord = (props) => {

    //  handler for user selection to edit/update
    const handleUseCaseEdit = () => {
        props.useCase.value.role === 'system' ? props.isDisabled(true) : props.isDisabled(false);
        props.useCaseSelect(props.useCase);
    }

    //  handler for user deletion
    const handleDeleteUseCase = () => {
      props.deleteUseCase(props.useCase);
    }

    // handler for user copy
    const handleCopyUseCase = () => {
      props.isDisabled(false);
      props.cloneUseCase(props.useCase);
    } 


    let layout = (
        <Tr>
          <Td>
            <Button 
              variant="secondary_icon" 
              size="icon_small" 
              aria-label="View UseCase" 
              onClick={ () => handleUseCaseEdit()}
            >
              <EditIcon decorative={false} title="View UseCase"/>
            </Button>
          </Td>
          <Td>
            <Button 
              variant="secondary_icon" 
              size="icon_small" 
              aria-label="Copy UseCase" 
              onClick={ () => handleCopyUseCase()}
            >
              <CopyIcon decorative={false} title="Copy UseCase"/>
            </Button>
            </Td>
          <Th scope="row">
              <Text 
              as="span"
               color="blue"
              style={{cursor: 'pointer'}} onClick={ () => handleUseCaseEdit()}
              >
                {props.useCase.value.title}
            </Text>
              <DetailText marginTop='space0'>({props.useCase.value.role}-template)</DetailText>
          </Th>

          <Td>
            {
              props.useCase.value.role !=='system'&&(
                <Button variant="secondary_icon" size="icon_small" aria-label="Delete UseCase" onClick={() => handleDeleteUseCase()}>
                  <DeleteIcon decorative={false} title="Delete UseCase" />
                </Button>
              )
            }
          </Td>
        </Tr>
    )
    return layout
}
export default UseCaseRecord;


================================================
FILE: client/src/ui-components/UseCases/UseCases.js
================================================

import { useState, useEffect } from 'react';
import axios from "axios";
import { 
    Grid, Column, Alert, Tooltip, Heading, Text, DetailText,
    Card, Box, Input, AlertDialog,
    Button, Table, THead, TBody, Tr, Th, Label,Paragraph,
    useSideModalState
 } from '@twilio-paste/core';

import { SearchIcon } from "@twilio-paste/icons/esm/SearchIcon";

import AddUseCaseForm from './AddUseCaseForm'
import UseCaseRecord from './UseCaseRecord';

import { updateUseCaseHelper, deleteUseCaseHelper } from '../../helpers/clientDataHelper';

const UseCases = () => {
    const [search, setSearch] = useState('');
    const [useCases, setUseCases] = useState([]);
    const [filteredUseCases, setFilteredUseCases] = useState([]);
    const [selectedUseCase, setSelectedUseCase] = useState(null);
    const [mode, setMode] = useState(''); // 'edit', 'clone'
    const [disabled, setDisabled] = useState(false);
    const [reload, setReload] = useState(false);

    const [showDeleteDialog, setShowDeleteDialog] = useState(false);
    const [deleteUseCase, setDeleteUseCase] = useState(null);

    // Alert state alert state for updating current user configuration
    const [showAlert, setShowAlert] = useState(false);
    const [alertMessage, setAlertMessage] = useState("");
    const [alertType, setAlertType] = useState("neutral");


    const dialog = useSideModalState({});
    

    // Fetch all users from the backend when the component mounts or reload state changes
    useEffect(() => {
        //   get all users from the backend
        const fetchUseCases = async () => {
            const useCaseURL = process.env.REACT_APP_GET_ALL_USE_CASE_URL;
            try {
                const response = await axios.get(useCaseURL);
                setUseCases(response.data);
                setFilteredUseCases(response.data);
            } catch (error) {
                console.error("Error fetching users: ", error);
            }
        }
        fetchUseCases();   
    },[reload])

    // alert timeout effect to hide alert after 5 seconds
    useEffect(() => {
        if (showAlert) {
            const timer = setTimeout(() => {
                setShowAlert(false);
            }, 5000); // Hide alert after 5 seconds
            return () => clearTimeout(timer);
        }
    },[showAlert])


    // handler to clear search input and reset filtered users
    const clearSearch = () => {
        setSearch('');
        setFilteredUseCases(useCases);
    }

    // handler to filter users based on search input
    const handleSearchChange = (event) => {
        setSearch( event.target.value.toLowerCase())
        setFilteredUseCases(Object.values(useCases).filter(uCase => uCase.value.title.toLowerCase().includes(event.target.value.toLowerCase())))
    }

    // handler to select a user from the list and display their details
    const handleUseCaseSelect = (uCase) => { 
        setMode('edit')
        setSelectedUseCase(uCase)
    }

    // handler to clone a user from the list and display their details
    const handleUseCaseClone = (uCase) => {
        setMode('clone')
        setSelectedUseCase(uCase)
    }

    // handler to clear user detail form
    const clearSelectedUseCase = () => { 
        setSelectedUseCase(null)
        setMode('');
        setDisabled(false);
    }

    // handler to refresh the user list
    const handleRefresh = () => { 
        setSelectedUseCase(null);
        setReload(!reload) 
        setAlertMessage('User list reloaded');
        setAlertType("neutral")
        setShowAlert(true)
    }

    // handler to update a selected user from the list
    const updateUseCase = async (useCaseAttributes) => {
        console.log('updateUseCase', useCaseAttributes)
        let resp = await updateUseCaseHelper(useCaseAttributes);
        if(resp.status==='success'){
            setAlertMessage('Use Case configuration was successfully updated');
            setAlertType("neutral")
            setShowAlert(true)
        } else {
            setAlertMessage('An error has occurred updating this use case.');
            setAlertType("error")
            setShowAlert(true)
        }
        setSelectedUseCase(null);
        setMode('');
        setDisabled(false);
        setReload(!reload);
    }

    // handler to display the delete user dialog
    const dialogDeleteUseCase = (useCase) => { 
        console.log('dialogDeleteUseCase', useCase)
        setShowDeleteDialog(true)
        setDeleteUseCase(useCase);
    }

    // handler to set the disabled state for the AddUseCaseForm form
    const handleDisabled = (value) => {
        setDisabled(value);
    }

    // handler to delete a user from the list
    const handleUseCaseDelete = async () => {
        console.log('handleUseCaseDelete', deleteUseCase)
     const key = {key: deleteUseCase.key}
     console.log('key', key)
    //  Call server API to create the user
    let resp = await deleteUseCaseHelper(key);

    if(resp.status==='success'){
        setAlertMessage('Use case configuration was successfully deleted');
        setAlertType("neutral")
        setShowAlert(true)
    } else {
        setAlertMessage('An error has occurred deleting this use case.');
        setAlertType("error")
        setShowAlert(true)
    }
    setShowDeleteDialog(false);
    setDeleteUseCase(null);
    setSelectedUseCase(null);
    setMode('');
    setDisabled(false)
    setReload(!reload);
    dialog.hide()
    }

    // Render the users page
    let layout =  (
        <div style={{margin: '20px'}}>
            <Box style={{marginTop:10, }} height="100vh">
                <Grid gutter="space40">
                    <Column span={[12, 12, 12]}>
                        <div style={{marginBottom: '10px'}}>
                        {/* Display application alerts */}
                        { showAlert && (
                            <Alert
                                variant={alertType}
                                onDismiss={() => setShowAlert(false)}
                                marginBottom="space40"
                            >
                                {alertMessage}
                            </Alert>
                        )}
                        </div>
                    </Column>
                    <Column span={[12, 12, 4]}>
                        <Card padding="space100">
                            <Heading as="h3" variant="heading30" marginBottom="space40">Application UseCases</Heading>
                            <Paragraph marginBottom="space40">Manage use cases for your application. Custom Use cases can be added, updated, and deleted. </Paragraph>
                            <Paragraph marginBottom="space40">"System-Templates" can be "cloned" to create a quick use case.</Paragraph>
                            <Paragraph marginBottom="space100">"User-Templates" can be edited or "cloned" to modify or create a use case.</Paragraph>
                            
                            <Box overflowY="auto" height="auto" maxHeight="500px">
                                <Box style={{marginBottom: '20px'}} padding="space20">
                                    <Label htmlFor="search">Filter</Label>
                                    <Input 
                                        aria-describedby="search" 
                                        id="search" 
                                        name="search" 
                                        type="text"
                                        value={search} 
                                        insertAfter={
                                            <Tooltip text="Clear Search" placement="top">
                                            <Button variant="link" onClick={clearSearch}>
                                                <SearchIcon decorative={false} size="sizeIcon20" title="Get more info" onClick={clearSearch}/>
                                            </Button>
                                            </Tooltip>
                                            }
                                        onChange={(e)=>{handleSearchChange(e)}}
                                    />
                                </Box>
                                <Table  >
                                    <THead stickyHeader top={0}>
                                        <Tr>
                                            <Th>Edit</Th>
                                            <Th>Clone</Th>
                                            <Th>User</Th>
                                            <Th>Delete</Th>
                                        </Tr>
                                    </THead>
                                    <TBody>
                                        {
                                            Object.values(filteredUseCases).map((uCase, index) => (
                                                // Object.values(filteredUseCases).filter(uCase => uCase.value.role === 'user').map((uCase, index) => (
                                                <UseCaseRecord 
                                                    key={index} 
                                                    useCase={uCase} 
                                                    deleteUseCase={dialogDeleteUseCase} 
                                                    useCaseSelect={handleUseCaseSelect}
                                                    cloneUseCase = {handleUseCaseClone}
                                                    isDisabled={handleDisabled}
                                                    />
                                            ))
                                        }
                                    </TBody>
                                </Table>

                            </Box>
                                <Box as="div" style={{marginLeft: '10px', marginRight:'10px', marginTop:'20px'}}  >
                                    <Button variant="secondary" size="small" onClick={()=> handleRefresh()} fullWidth>Refresh</Button>
                                </Box>


                        </Card>
                    </Column>
                    <Column span={[12, 12, 8]}>
                        <Card padding="space100">
                            <Heading as="h3" variant="heading30" marginBottom="space40">UseCase Details</Heading>
                            <Paragraph marginBottom="space40">Update a selected UseCase's details.</Paragraph> 

                            { selectedUseCase ? 
                            <AddUseCaseForm 
                                mode={mode}
                                disabled={disabled} 
                                selectedUseCase={selectedUseCase} 
                                updateUseCase={updateUseCase} 
                                clearForm={clearSelectedUseCase} />
                            : 
                                <div style={{ marginTop: '100px', textAlign: "center" }}>
                                    <Paragraph><span style={{color: 'red'}}>No selected use case</span></Paragraph>
                                </div>
                            }                       
                        </Card>
                    </Column>

                </Grid>

                {/* Alert visualization for user deletion */}
                <AlertDialog
                    heading="Delete Use Case"
                    isOpen={showDeleteDialog}
                    onConfirm={handleUseCaseDelete}
                    onConfirmLabel="Delete"
                    onDismiss={() => setShowDeleteDialog(false)}
                    onDismissLabel="Cancel"
                >
                    <Paragraph>Are you sure you want to delete this useCase?</Paragraph>
                    <Text>Name: {deleteUseCase?.value.title}</Text>

                </AlertDialog>
            </Box>
        </div>
    )
    return layout
}
export default UseCases;


================================================
FILE: client/src/ui-components/Users/AddUserForm.js
================================================
import { useState, useEffect } from 'react';
import { 
    Card, Box, Input,
    Button, Label, HelpText, Form, FormControl, RadioGroup, Radio, 
 } from '@twilio-paste/core';

import { useUID } from '@twilio-paste/core/uid-library';

const AddUserForm = (props) => {
        const [userType, setUserType] = useState('webRtc');
        const [userRole, setUserRole] = useState('user');       // default role is user
        const [mode, setMode] = useState(props.mode);           // form mode ( add, edit )
        const [firstName, setFirstName] = useState('');
        const [lastName, setLastName] = useState('');
        const [email, setEmail] = useState('');
        const [phone, setPhone] = useState('');
        const [demoPhone, setDemoPhone] = useState('');
        const [sipAddress, setSipAddress] = useState('');
        const [webRtcIdentity, setWebRtcIdentity] = useState('');
        const [crParamsOverride, setCrParamsOverride] = useState('');
        const[typeUpdate, setTypeUpdate] = useState(false);
        const[uiChange, setUiChange] = useState(false);

        //  initialize local state for form and currently selected user
        useEffect(() => {
            if (props.mode === 'edit') {
                setUserType(props.selectedUser?.value.type || 'webRtc');
                setUserRole(props.selectedUser?.value.role || 'user');
                setFirstName(props.selectedUser?.value.firstName || '');
                setLastName(props.selectedUser?.value.lastName || '');
                setEmail(props.selectedUser?.value.email || '');
                setPhone(props.selectedUser?.value.phone || '');
                
                props.selectedUser?.value.type === 'webRtc' ? setWebRtcIdentity(props.selectedUser?.value.identity) : setWebRtcIdentity('');
                props.selectedUser?.value.type === 'phone' ? 
                    setDemoPhone(props.selectedUser?.value.identity ) : setDemoPhone('');
                props.selectedUser?.type === 'sip' ? 
                    setSipAddress(props.selectedUser?.value.identity) : setSipAddress('');

                setCrParamsOverride(props.selectedUser?.value.conversationRelayParamsOverride);
            }
        },[props.selectedUser])

    // use effect to auto-generate the webRTC identity and SIP user parts when adding a new user
    useEffect(() => { 
        if(mode=='add'){
            if(userType === 'webRtc') { setWebRtcIdentity(composeIdentity()) }
            if(userType === 'sip') {
                let domain = process.env.REACT_APP_PV_SIP_DOMAIN
                let sipaddress = `${composeIdentity()}@${domain}`;
                setSipAddress(sipaddress) 
            }
        }
    },[firstName, lastName, typeUpdate])

    //  handler to clear the form - props in Users component
    const handleClearForm = () => { 
        props.clearForm()
        setUiChange(false) 
    }

    // handler to auto-create webRTC and SIP identities based on first and last name
    const composeIdentity = () => { 
        if (firstName === '' || lastName === '') { return '' } else {
            return (firstName[0] + lastName).toLowerCase() 
        } 
    }

    //  handlers to update local state for first name
    const handleFirstNameChange = (e) => { 
        setUiChange(true)
        setFirstName(e.target.value) 
    }

    //  handler to update local state for last name
    const handleLastNameChange = (e) => { 
        setUiChange(true)
        setLastName(e.target.value)
    }

    // handler to update user type
    const handleUserTypeChange = (newValue) => {
        setUserType(newValue);
        setTypeUpdate(!typeUpdate)
    }

    //  handler to update local state for phone
    const handlePhoneChange = (e) => {
        setUiChange(true)
        setPhone(e.target.value);
    }

    // handler to update local state for email
    const handleEmailChange = (e) => {
        setUiChange(true)
        setEmail(e.target.value);
    }

    // handler to update user - pass user object to parent Users component
    const handleUpdateUser = () => {
        const user = {
            identity: userType === 'webRtc' ? webRtcIdentity : (userType === 'sip' ? sipAddress : demoPhone),
            type: userType, // webRtc, sip, phone
            role: userRole,
            firstName: firstName.trim(),
            lastName: lastName.trim(),
            phone: phone.trim(),
            email: email.trim(),
            conversationRelayParamsOverride: crParamsOverride
        }
        props.updateUser(user)
    }

    // handler to add a new user - pass user object to parent Users component
    const handleAddUser = () => {
        const user = {
            identity: userType === 'webRtc' ? webRtcIdentity : (userType === 'sip' ? sipAddress : demoPhone),
            type: userType, // webRtc, sip, phone
            firstName: firstName.trim(),
            lastName: lastName.trim(),
            phone: phone.trim(),
            email: email.trim(),
            conversationRelayParamsOverride: crParamsOverride
        }        
        props.createUser(user)
    }

    // content to render
    let layout = (
        <Box padding="space60">
            <Form maxWidth="size70">
                <Card>
                    <FormControl >
                        <Label htmlFor="firstName" required>First name</Label>
                                <Input
                                    type="text"
                                    id={'firstName'}
                                    name="firstName"
                                    value={ firstName}
                                    onChange={(e) => handleFirstNameChange(e)}
                                    placeholder="First name"
                                    required
                                />
                        <HelpText as="div" color="colorTextWeak">
                        Enter your first name 
                        </HelpText>
                        <div style={{marginBottom: '15px'}}></div>
                    </FormControl>
                    <FormControl>
                        <Label htmlFor="lastName" required>Last name</Label>
                                <Input
                                    type="text"
                                    id={'lastName'}
                                    name="lastName"
                                    value={lastName}
                                    onChange={(e) => handleLastNameChange(e)}
                                    placeholder="Last name"
                                    required
                                />
                        <HelpText as="div" color="colorTextWeak">
                        Enter your last name 
                        </HelpText>
                        <div style={{marginBottom: '15px'}}></div>
                    </FormControl>
                    <FormControl>
                        <Label htmlFor="phone" required>Mobile Number (e.164)</Label>
                                <Input
                                    type="text"
                                    id={'phone'}
                                    name="phone"
                                    value={phone}
                                    onChange={(e) => handlePhoneChange(e)}
                                    placeholder="Mobile Number"
                                    required
                                />
                        <HelpText as="div" color="colorTextWeak">
                        Enter your mobile number (e.164 format)
                        </HelpText>
                        <div style={{marginBottom: '15px'}}></div>
                    </FormControl>
                    <FormControl>
                        <Label htmlFor="email" required>Email Address</Label>
                            <Input
                                type="text"
                                id={'email'}
                                name="email"
                                value={email}
                                onChange={(e) => handleEmailChange(e)}
                                placeholder="Email address"
                                required
                            />
                        <HelpText as="div" color="colorTextWeak">
                        Enter your last name 
                        </HelpText>
                        <div style={{marginBottom: '15px'}}></div>
                    </FormControl>

                    <FormControl>
                        <RadioGroup
                        name="uncontrolled-radio-group"
                        legend="Select a User Type"
                        orientation='horizontal'
                        value={userType}
                        onChange={(newValue) => handleUserTypeChange(newValue)}
                        helpText="Choose the type of user for your use case."
                        disabled={props.mode === 'edit' ? true : false}
                        >
                        <Radio
                            id={useUID()}
                            value="webRtc"
                            name="userType"
                            defaultChecked
                        >
                            webRTC
                        </Radio>
                        <Radio
                            id={useUID()}
                            value="sip"
                            name="userType"
                        >
                            SIP
                        </Radio>
                        <Radio
                            id={useUID()}
                            value="phone"
                            name="userType"
                        >
                            Phone Number
                        </Radio>
                        </RadioGroup>                                        
                    </FormControl>

                    <div style={{marginBottom: '15px'}}></div>
                    {/* UserAddress */}
                    { userType === 'webRtc' && (
                    <FormControl>
                        <Label htmlFor="demoPhone" required>Web RTC Identity (auto-created)</Label>
                                <Input
                                    type="text"
                                    id={'demoPhone'}
                                    name="demoPhone"
                                    value={ webRtcIdentity}
                                    readOnly
                                />
                    </FormControl>
                    )}
                    { userType === 'sip' && (
                    <FormControl>
                        <Label htmlFor="demoPhone" required>SIP Address (auto-created)</Label>
                                <Input
                                    type="text"
                                    id={'demoPhone'}
                                    name="demoPhone"
                                    value={ sipAddress }
                                    readOnly
                                />
                    </FormControl>
                    )}

                    { userType === 'phone' && (
                    <FormControl>
                        <Label htmlFor="demoPhone" required>Demo Phone Number</Label>
                                <Input
                                    type="text"
                                    id={'demoPhone'}
                                    name="demoPhone"
                                    value={ demoPhone }
                                    onChange={(e) => setDemoPhone(e.target.value)}
                                    placeholder="Demo phone"
                                    required
                                />
                        <HelpText as="div" color="colorTextWeak">
                        Twilio phone number to use for demo purposes 
                        </HelpText>
                    </FormControl>
                    )}
                    <div style={{marginBottom: '25px'}}></div>
                    <FormControl>
                        <Box as={'div'} marginTop="20px" marginBottom="20px">
                            { uiChange && (
                                <Label><span style={{color:'red'}}>Configuration has changed</span></Label>
                            )}
                        </Box>
                        <div>
                            <div>
                            {
                                mode === 'edit' ?
                                    <Button variant="secondary" type="button" style={{marginLeft: '10px'}} onClick={() => handleClearForm()}>
                                    Clear Form
                                    </Button> : <></>
                            }
                            <span style={{float: 'right'}}>
                                { props.selectedUser  && (
                                <Button
                                    variant={ uiChange ? 'destructive' : 'primary'} 
                                    type="button"
                                    onClick={() => handleUpdateUser()} 
                                    >
                                    Update User
                                </Button>
                                )}

                                { mode === 'add' && (
                                    <Button
                                        variant={ uiChange ? 'destructive' : 'primary'} 
                                        type="button"
                                        onClick={() => handleAddUser() }
                                        >
                                        Add User
                                    </Button>
                                )}
                                </span>
                            </div>
                        </div>
                    </FormControl>
                </Card>
            </Form>
        </Box>
    )
    return layout
}
export default AddUserForm;




================================================
FILE: client/src/ui-components/Users/UserRecord.js
================================================

import { Th, Tr, Td, Text, DetailText, Button } from '@twilio-paste/core'
import { DeleteIcon } from "@twilio-paste/icons/esm/DeleteIcon";
import { EditIcon } from "@twilio-paste/icons/esm/EditIcon";

const UserRecord = (props) => {

    //  handler for user selection to edit/update
    const handleUserEdit = () => {
        props.userSelect(props.user);
    }

    //  handler for user deletion
    const handleDeleteUser = () => {
      props.deleteUser(props.user);
    }

    let layout = (
        <Tr>
          <Td>
            <Button variant="secondary_icon" size="icon_small" aria-label="Edit user"  onClick={ () => handleUserEdit()}>
              <EditIcon decorative={false} title="Edit user"/>
            </Button>
          </Td>
          <Th scope="row">
              <Text as="span" color="blue" style={{cursor: 'pointer'}} onClick={ () => handleUserEdit()}>{props.user.value.firstName} {props.user.value.lastName}</Text>
              <DetailText marginTop='space0'>{props.user.value.identity} ({props.user.value.type})</DetailText>
          </Th>
          <Td>

              <Button variant="secondary_icon" size="icon_small" aria-label="Delete user" onClick={() => handleDeleteUser()}>
                <DeleteIcon decorative={false} title="Delete user" />
              </Button>            
          </Td>
        </Tr>
    )
    return layout
}
export default UserRecord;


================================================
FILE: client/src/ui-components/Users/Users.js
================================================
import { useState, useEffect } from "react";
import axios from "axios";
import {
  Grid,
  Column,
  Alert,
  Tooltip,
  Heading,
  Text,
  DetailText,
  Card,
  Box,
  Input,
  AlertDialog,
  Button,
  Table,
  THead,
  TBody,
  Tr,
  Th,
  Label,
  SideModalContainer,
  SideModal,
  SideModalHeader,
  SideModalHeading,
  SideModalBody,
  Paragraph,
  useSideModalState,
} from "@twilio-paste/core";

import { SearchIcon } from "@twilio-paste/icons/esm/SearchIcon";

import AddUserForm from "./AddUserForm";
import UserRecord from "./UserRecord";

import {
  updateUserHelper,
  createUserHelper,
  deleteUserHelper,
} from "../../helpers/clientDataHelper";



const Users = () => {
  const [search, setSearch] = useState("");
  const [users, setUsers] = useState([]);
  const [filteredUsers, setFilteredUsers] = useState([]);
  const [selectedUser, setSelectedUser] = useState(null);
  const [reload, setReload] = useState(false);

  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [deleteUser, setDeleteUser] = useState(null);

  // Alert state alert state for updating current user configuration
  const [showAlert, setShowAlert] = useState(false);
  const [alertMessage, setAlertMessage] = useState("");
  const [alertType, setAlertType] = useState("neutral");

  // State for the side modal dialog
  const dialog = useSideModalState({});

  // Fetch all users from the backend when the component mounts or reload state changes
  useEffect(() => {
    //   get all users from the backend
    const fetchUsers = async () => {
      const usersURL = process.env.REACT_APP_GET_ALL_USERS_URL;
      try {
        const response = await axios.get(usersURL);
        setUsers(response.data);
        setFilteredUsers(response.data);
      } catch (error) {
        console.error("Error fetching users: ", error);
      }
    };
    fetchUsers();
  }, [reload]);

      useEffect(() => {
        if (showAlert) {
            const timer = setTimeout(() => {
                setShowAlert(false);
            }, 5000); // Hide alert after 5 seconds
            return () => clearTimeout(timer);
        }
    },[showAlert])

  // handler to clear search input and reset filtered users
  const clearSearch = () => {
    setSearch("");
    setFilteredUsers(users);
  };

  // handler to filter users based on search input
  const handleSearchChange = (event) => {
    setSearch(event.target.value.toLowerCase());
    setFilteredUsers(
      Object.values(users).filter((user) =>
        user.value.firstName
          .toLowerCase()
          .includes(event.target.value.toLowerCase())
      )
    );
  };

  // handler to select a user from the list and display their details
  const handleUserSelect = (user) => {
    console.log("handleUserSelect", user);
    setSelectedUser(user);
  };

  // handler to clear user detail form
  const clearSelectedUser = () => {
    setSelectedUser(null);
  };

  // handler to display side drawer to a new user
  const handleAddUser = () => {
    setSelectedUser(null);
    dialog.show();
  };

  // handler to refresh the user list
  const handleRefresh = () => {
    setSelectedUser(null);
    setReload(!reload);
    setAlertMessage("User list reloaded");
    setAlertType("neutral");
    setShowAlert(true);
  };

  // handler to update a selected user from the list
  const updateUser = async (userAttributes) => {
    let resp = await updateUserHelper(userAttributes);
    if (resp.status === "success") {
      setAlertMessage("User configuration was successfully updated");
      setAlertType("neutral");
      setShowAlert(true);
    } else {
      setAlertMessage("An error has occurred updating this user.");
      setAlertType("error");
      setShowAlert(true);
    }
    setShowDeleteDialog(false);
    clearSelectedUser();
    setReload(!reload);
  };

  // handler to display the delete user dialog
  const dialogDeleteUser = (user) => {
    setShowDeleteDialog(true);
    setDeleteUser(user);
  };

  // handler to delete a user from the list
  const handleUserDelete = async () => {
    console.log("handleUserDelete", deleteUser);
    const identity = { identity: deleteUser.key };
    //  Call server API to create the user
    let resp = await deleteUserHelper(identity);

    if (resp.status === "success") {
      setAlertMessage("User configuration was successfully deleted");
      setAlertType("neutral");
      setShowAlert(true);
    } else {
      setAlertMessage("An error has occurred deleting this user.");
      setAlertType("error");
      setShowAlert(true);
    }
    setShowDeleteDialog(false);
    setDeleteUser(null);
    setReload(!reload);
    dialog.hide();
  };

  // handler to create new application users
  const createUser = async (user) => {
    let from = "";
    switch (user.type) {
      case "webRtc":
        from = `client:${user.identity}`;
        break;
      case "sip":
        from = `sip:${user.identity}`;
        break;
      case "phone":
        from = user.identity; // phone number
        break;
      default:
    }

    // structure the submitted user attributes
    const userAttributes = {
      identity: user.identity,
      from: from,
      role: "user",
      type: user.type,
      firstName: user.firstName,
      lastName: user.lastName,
      phone: user.phone,
      email: user.email,
    };
    let resp = await createUserHelper(userAttributes);
    if (resp.status === "success") {
      setAlertMessage("User configuration created successfully");
      setAlertType("neutral");
      setShowAlert(true);
      setReload(!reload);
    } else {
      setAlertMessage("An error has occurred creating this user.");
      setAlertType("error");
      setShowAlert(true);
    }
    dialog.hide();
  };

  // Render the users page
  let layout = (
    <div>
      <Box
        style={{ marginTop: 10 }}
        width="100%"
        height="100vh"
        padding="space50"
      >
        <Grid gutter="space40">
          <Column span={[12, 12, 12]}>
            <div style={{ marginBottom: "10px" }}>
              {/* Display application alerts */}
              {showAlert && (
                <Alert
                  variant={alertType}
                  onDismiss={() => setShowAlert(false)}
                  marginBottom="space40"
                >
                  {alertMessage}
                </Alert>
              )}
            </div>
          </Column>
          <Column span={[12, 12, 4]}>
            <Box paddingTop={"space50"}>
              <Card marginLeft={"100px"} width="100%">
                <Heading as="h3" variant="heading30" marginBottom="space40">
                  Application Users
                </Heading>
                <Paragraph marginBottom="space40">
                  Manage users for your application. Users can be added,
                  deleted, and updated.
                </Paragraph>

                <Box overflowY="auto" height="auto" maxHeight="500px">
                  <Box style={{ marginBottom: "20px" }} padding="space20">
                    <Label htmlFor="search">Filter</Label>
                    <Input
                      aria-describedby="search"
                      id="search"
                      name="email_address"
                      type="text"
                      value={search}
                      insertAfter={
                        <Tooltip text="Clear Search" placement="top">
                          <Button variant="link" onClick={clearSearch}>
                            <SearchIcon
                              decorative={false}
                              size="sizeIcon20"
                              title="Get more info"
                              onClick={clearSearch}
                            />
                          </Button>
                        </Tooltip>
                      }
                      onChange={(e) => {
                        handleSearchChange(e);
                      }}
                    />
                  </Box>
                  <Table>
                    <THead stickyHeader top={0}>
                      <Tr>
                        <Th>View</Th>
                        <Th>User</Th>
                        <Th>Delete</Th>
                      </Tr>
                    </THead>
                    <TBody>
                      {Object.values(filteredUsers)
                        .filter((user) => user.value.role === "user")
                        .map((user, index) => (
                          <UserRecord
                            key={index}
                            user={user}
                            deleteUser={dialogDeleteUser}
                            userSelect={handleUserSelect}
                          />
                        ))}
                    </TBody>
                  </Table>
                </Box>
                <Box
                  as="div"
                  style={{
                    marginLeft: "10px",
                    marginRight: "10px",
                    marginTop: "20px",
                  }}
                >
                  <Button
                    variant="secondary"
                    size="small"
                    onClick={() => handleRefresh()}
                    fullWidth
                  >
                    Refresh
                  </Button>
                </Box>

                <Box
                  as="div"
                  style={{ marginBottom: "10px" }}
                  padding="space60"
                >
                  <Button
                    variant="primary"
                    onClick={() => handleAddUser()}
                    fullWidth
                  >
                    Add User
                  </Button>
                </Box>
              </Card>
            </Box>
          </Column>
          <Column span={[12, 12, 8]}>
            <Box paddingTop="space50">
              <Card>
                <Heading as="h3" variant="heading30" marginBottom="space40">
                  User Details
                </Heading>
                <Paragraph marginBottom="space40">
                  Update a selected user's details.
                </Paragraph>
                <AddUserForm
                  mode={"edit"}
                  selectedUser={selectedUser}
                  updateUser={updateUser}
                  clearForm={clearSelectedUser}
                />
              </Card>
            </Box>
          </Column>
        </Grid>

        {/* Side modal for add user features */}
        <SideModalContainer state={dialog}>
          {/* Place this button wherever you want to trigger the modal */}
          <SideModal aria-label="Add User Modal" width="400px">
            <SideModalHeader>
              <SideModalHeading>Add User</SideModalHeading>
            </SideModalHeader>
            <SideModalBody>
              {/* Modal content here */}
              <AddUserForm mode={"add"} createUser={createUser} />
            </SideModalBody>
          </SideModal>
        </SideModalContainer>

        {/* Alert visualization for user deletion */}
        <AlertDialog
          heading="Delete User"
          isOpen={showDeleteDialog}
          onConfirm={handleUserDelete}
          onConfirmLabel="Delete"
          onDismiss={() => setShowDeleteDialog(false)}
          onDismissLabel="Cancel"
        >
          <Paragraph>Are you sure you want to delete this user?</Paragraph>
          <Text>
            Name: {deleteUser?.value.firstName} {deleteUser?.value.lastName}
          </Text>
          <DetailText>
            Identity: {deleteUser?.value.identity} ({deleteUser?.value.type})
          </DetailText>
        </AlertDialog>
      </Box>
    </div>
  );
  return layout;
};
export default Users;



================================================
FILE: data/tts-providers.json
================================================

{ "Google": [
        { "name": "en-US-Neural2-A", "value": "en-US-Neural2-A", "language" : "en-US" },        
        { "name": "en-US-Neural2-C", "value": "en-US-Neural2-C", "language" : "en-US" },        
        { "name": "en-US-Neural2-D", "value": "en-US-Neural2-D", "language" : "en-US" },        
        { "name": "en-US-Neural2-E", "value": "en-US-Neural2-E", "language" : "en-US" },        
        { "name": "en-US-Neural2-F", "value": "en-US-Neural2-F", "language" : "en-US" },        
        { "name": "en-US-Neural2-G", "value": "en-US-Neural2-G", "language" : "en-US" },        
        { "name": "en-US-Neural2-H", "value": "en-US-Neural2-H", "language" : "en-US" },        
        { "name": "en-US-Neural2-I", "value": "en-US-Neural2-I", "language" : "en-US" },        
        { "name": "en-US-Neural2-J", "value": "en-US-Neural2-J", "language" : "en-US" },        
        { "name": "en-US-Wavenet-A", "value": "en-US-Wavenet-A", "language" : "en-US" },        
        { "name": "en-US-Wavenet-A", "value": "en-US-Wavenet-A", "language" : "en-US" },        
        { "name": "en-US-Wavenet-B", "value": "en-US-Wavenet-B", "language" : "en-US" },        
        { "name": "en-US-Wavenet-C", "value": "en-US-Wavenet-C", "language" : "en-US" },        
        { "name": "en-US-Wavenet-D", "value": "en-US-Wavenet-D", "language" : "en-US" },        
        { "name": "en-US-Wavenet-E", "value": "en-US-Wavenet-E", "language" : "en-US" },        
        { "name": "en-US-Wavenet-F", "value": "en-US-Wavenet-F", "language" : "en-US" },
        { "name": "en-US-Wavenet-G", "value": "en-US-Wavenet-G", "language" : "en-US" },        
        { "name": "en-US-Wavenet-H", "value": "en-US-Wavenet-H", "language" : "en-US" },        
        { "name": "en-US-Wavenet-I", "value": "en-US-Wavenet-I", "language" : "en-US" },        
        { "name": "en-US-Wavenet-J", "value": "en-US-Wavenet-J", "language" : "en-US" }
    ],
    "Amazon": [
        
        { "name": "Danielle-Neural", "value": "Danielle-Neural", "language" : "en-US" },
        { "name": "Gregory-Neural", "value": "Gregory-Neural", "language" : "en-US" },
        { "name": "Ivy-Neural", "value": "Ivy-Neural", "language" : "en-US" },
        { "name": "Joanna-Neural", "value": "Joanna-Neural", "language" : "en-US" },
        { "name": "Justin-Neural", "value": "Justin-Neural", "language" : "en-US" },
        { "name": "Joey-Neural", "value": "Joey-Neural", "language" : "en-US" },
        { "name": "Kendra-Neural", "value": "Kendra-Neural", "language" : "en-US" },
        { "name": "Kevin-Neural", "value": "Kevin-Neural", "language" : "en-US" },
        { "name": "Kimberly-Neural", "value": "Kimberly-Neural", "language" : "en-US" },
        { "name": "Matthew-Neural", "value": "Matthew-Neural", "language" : "en-US" },
        { "name": "Ruth-Neural", "value": "Ruth-Neural", "language" : "en-US" },
        { "name": "Salli-Neural", "value": "Salli-Neural", "language" : "en-US" },
        { "name": "Stephen-Neural", "value": "Stephen-Neural", "language" : "en-US" }
],
    "ElevenLabs":[

        {"value":"u4HtmbcjVZVpiJLQ2GZn","name":"A Top Narrator VO PRO","language":"en-US"},
        {"value":"IRHApOXLvnW57QJPQH2P","name":"Adam - Brooding, Dark, Tough American","language":"en-US"},
        {"value":"GzE4TcXfh9rYCU9gVgPp","name":"Alex Wright","language":"en-US"},
        {"value":"kdmDKE6EkgrWrrykO9Qt","name":"Alexandra - Conversational and Real","language":"en-US"},
        {"value":"xctasy8XvGp2cVO9HL9k","name":"Allison - millennial","language":"en-US"},
        {"value":"gUABw7pXQjhjt0kNFBTF","name":"Andrew - Smooth audio books","language":"en-US"},
        {"value":"Z3R5wn05IrDiVCyEkUrK","name":"Arabella","language":"en-US"},
        {"value":"Bj9UqZbhQsanLzgalpEG","name":"Austin - Good ol' Texas boy","language":"en-US"},
        {"value":"zQzvQBubVkDWYuqJYMFn","name":"B. Hardscrabble Oxley","language":"en-US"},
        {"value":"LruHrtVF6PSyGItzMNHS","name":"Benjamin - Deep, Warm, Calming","language":"en-US"},
        {"value":"iiidtqDt9FBdT1vfBluA","name":"Bill L. Oxley","language":"en-US"},
        {"value":"T5cu6IU92Krx4mh43osx","name":"Bill Oxley ","language":"en-US"},
        {"value":"RexqLjNzkCjWogguKyff","name":"Bradley - Earnest narrator","language":"en-US"},
        {"value":"bPMKpgEe88vKSwusXTMU","name":"Bryan - Professional Narrator","language":"en-US"},
        {"value":"Fxt4GZnlXkUGMtWSYIcm","name":"Cal - Deep and Calming","language":"en-US"},
        {"value":"NHRgOEwqx5WZNClv5sat","name":"Chelsea","language":"en-US"},
        {"value":"6xPz2opT0y5qtoRh1U1Y","name":"Christian","language":"en-US"},
        {"value":"RPEIZnKMqlQiZyZd1Dae","name":"Christopher - friendly guy next door","language":"en-US"},
        {"value":"Qggl4b0xRMiqOwhPtVWT","name":"Clara - Relaxing","language":"en-US"},
        {"value":"asDeXBMC8hUkhqqL7agO","name":"David - Mature, Engaging Male Voice (American accent)","language":"en-US"},
        {"value":"y1adqrqs4jNaANXsIZnD","name":"David Boles","language":"en-US"},
        {"value":"XjLkpWUlnhS8i7gGz3lZ","name":"David Castlemore - Newsreader and Educator","language":"en-US"},
        {"value":"kqVT88a5QfII1HNAEPTJ","name":"Declan Sage - Wise, Deliberate, Captivating","language":"en-US"},
        {"value":"WtA85syCrJwasGeHGH2p","name":"Ember - Energetic Confident Protagonist","language":"en-US"},
        {"value":"NOpBlnGInO9m6vDvFkFC","name":"Grandpa Spuds Oxley","language":"en-US"},
        {"value":"dXtC3XhB9GtPusIpNtQx","name":"Hale - Great for Commercials!","language":"en-US"},
        {"value":"eBvoGh8YGJn1xokno71w","name":"Halley McClure","language":"en-US"},
        {"value":"x8xv0H8Ako6Iw3cKXLoC","name":"Haven Sands","language":"en-US"},
        {"value":"Dslrhjl3ZpzrctukrQSN","name":"Hey Its Brad - Clear Narrator for Documentary","language":"en-US"},
        {"value":"KH1SQLVulwP6uG4O3nmT","name":"Hey Its Brad - Your Favorite Boyfriend","language":"en-US"},
        {"value":"WZlYpi1yf6zJhNWXih74","name":"Hope - Corporate training","language":"en-US"},
        {"value":"WAhoMTNdLdMoq1j3wf3I","name":"Hope - Smooth talker","language":"en-US"},
        {"value":"zGjIP4SZlMnY9m93k97r","name":"Hope - The podcaster","language":"en-US"},
        {"value":"OYTbf65OHHFELVut7v2H","name":"Hope - Natural Conversations","language":"en-US"},
        {"value":"iCrDUkL56s3C8sCRl7wb","name":"Hope - soothing narrator","language":"en-US"},
        {"value":"tnSpp4vdxKPjI9w0GnoV","name":"Hope - Upbeat and Clear","language":"en-US"},
        {"value":"uYXf8XasLslADfZ2MB4u","name":"Hope- Your conversational bestie","language":"en-US"},
        {"value":"e5WNhrdI30aXpS2RSGm1","name":"Ian Cartwell - Suspense, Mystery and Thriller","language":"en-US"},
        {"value":"yM93hbw8Qtvdma2wCnJG","name":"Ivanna - Young & Casual  ","language":"en-US"},
        {"value":"i4CzbCVWoqvD0P1QJCUL","name":"Ivy - Free Spirit","language":"en-US"},
        {"value":"EkK5I93UQWFDigLMpZcX","name":"James - Husky & Engaging","language":"en-US"},
        {"value":"Mu5jxyqZOLIGltFpfalg","name":"Jameson - Guided Meditation & Narration","language":"en-US"},
        {"value":"SaqYcK3ZpDKBAImA8AdW","name":"Jane Doe -  Intimate","language":"en-US"},
        {"value":"1t1EeRixsJrKbiF1zwM6","name":"Jerry B. - Hyper-Real, Conversational, Off-the-Cuff","language":"en-US"},
        {"value":"lxYfHSkYm1EzQzGhdbfc","name":"Jessica Anne Bogart - A VO Professional; now cloned!","language":"en-US"},
        {"value":"flHkNRp1BlvT73UL6gyz","name":"Jessica Anne Bogart - Character and Animation","language":"en-US"},
        {"value":"g6xIsTj2HwM6VR4iXFCw","name":"Jessica Anne Bogart - Conversations","language":"en-US"},
        {"value":"EiNlNiXeDU1pqqOPrYMO","name":"John Doe - Deep","language":"en-US"},
        {"value":"7fbQ7yJuEo56rYjrYaEh","name":"John Doe - Intimate","language":"en-US"},
        {"value":"iLzHtPh0bW6RGWRG0Xo5","name":"John Doe Gentle","language":"en-US"},
        {"value":"dPah2VEoifKnZT37774q","name":"Knox Dark 2","language":"en-US"},
        {"value":"15CVCzDByBinCIoCblXo","name":"Lucan Rook  - Energetic Male","language":"en-US"},
        {"value":"1SM7GgM6IMuvQlz2BwM3","name":"Mark - ConvoAI","language":"en-US"},
        {"value":"UgBBYS2sOqTuMpoF3BR0","name":"Mark - Natural Conversations","language":"en-US"},
        {"value":"teWbCKrhI72i8jsmUGJ5","name":"Mauricio - English Narrator","language":"en-US"},
        {"value":"uju3wxzG5OhpWcoi3SMy","name":"Michael C. Vincent","language":"en-US"},
        {"value":"GUDYcgRAONiI1nXDcNQQ","name":"Milo - Calm, Soothing, Meditative","language":"en-US"},
        {"value":"84Fal4DSXWfp7nJ8emqQ","name":"Motivational Coach - Leader","language":"en-US"},
        {"value":"XfNU2rGpBa01ckF309OY","name":"Nichalia Schwartz - Friendly, Bright 20s-30s","language":"en-US"},
        {"value":"2gPFXx8pN3Avh27Dw5Ma","name":"Oxley - Evil Character","language":"en-US"},
        {"value":"WWr4C8ld745zI3BiA8n7","name":"Robert Riggs","language":"en-US"},
        {"value":"rU18Fk3uSDhmg5Xh41o4","name":"Ryan Kurk","language":"en-US"},
        {"value":"7NsaqHdLuKNFvEfjpUno","name":"Seer Morganna","language":"en-US"},
        {"value":"pVnrL6sighQX7hVz89cp","name":"Soothing Narrator","language":"en-US"},
        {"value":"wAGzRVkxKEs8La0lmdrE","name":"Sully","language":"en-US"},
        {"value":"raMcNf2S8wCmuaBcyI6E","name":"Tyler Kurk","language":"en-US"},
        {"value":"gOkFV1JMCt0G0n9xmBwV","name":"W. L. Oxley","language":"en-US"},
        {"value":"iUqOXhMfiOIbBejNtfLR","name":"W. Storytime Oxley","language":"en-US"},
        {"value":"8Es4wFxsDlHBmFWAOWRS","name":"William Shanks","language":"en-US"},
        {"value":"YXpFCvM1S3JbWEJhoskW","name":"Wyatt- Wise Rustic Cowboy","language":"en-US"},
        {"value":"jB108zg64sTcu1kCbN9L","name":"Zeus Epic","language":"en-US"},
        {"value":"aEO01A4wXwd1O8GPgGlF","name":"Arabella","language":"en-AU"},
        {"value":"9Ft9sm9dzvprPILZmLJl","name":"Patrick International","language":"en-AU"},
        {"value":"HDA9tsk27wYi3uq0fPcK","name":"Stuart - Energetic and enthusiastic","language":"en-AU"},
        {"value":"FVQMzxJGPUBtfz1Azdoy","name":"Danielle - Canadian Narrator","language":"en-CA"},
        {"value":"NFG5qt843uXKj4pFvR7C","name":"Adam Stone - late night radio","language":"en-GB"},
        {"value":"mZ8K1MPRiT5wDQaasg3i","name":"Alexander Kensington - Studio Quality","language":"en-GB"},
        {"value":"O4fnkotIypvedJqBp4yb","name":"Alexis Lancaster - Studio Quality Smooth & Authentic British Voice","language":"en-GB"},
        {"value":"ZF6FPAbjXT4488VcRRnw","name":"Amelia","language":"en-GB"},
        {"value":"rCmVtv8cYU60uhlsOo1M","name":"Ana","language":"en-GB"},
        {"value":"wJqPPQ618aTW29mptyoc","name":"Ana-Rita","language":"en-GB"},
        {"value":"Fahco4VZzobUeiPqni1S","name":"Archer - Conversational","language":"en-GB"},
        {"value":"kmSVBPu7loj4ayNinwWM","name":"Archie - English teen youth","language":"en-GB"},
        {"value":"8N2ng9i2uiUWqstgmWlH","name":"Beth - gentle and nurturing","language":"en-GB"},
        {"value":"NNl6r8mD7vthiJatiJt1","name":"Bradford","language":"en-GB"},
        {"value":"G17SuINrv2H9FC6nvetn","name":"Christopher","language":"en-GB"},
        {"value":"6sFKzaJr574YWVu4UuJF","name":"Cornelius","language":"en-GB"},
        {"value":"goT3UYdM9bhm0n2lmKQx","name":"Edward - British, Dark, Seductive, Low","language":"en-GB"},
        {"value":"aTbnroHRGIomiKpqAQR8","name":"Felicity - young and well-spoken","language":"en-GB"},
        {"value":"j9jfwdrw7BRfcR43Qohk","name":"Frederick Surrey","language":"en-GB"},
        {"value":"RILOU7YmBhvwJGDGjNmP","name":"Jane - Professional Audiobook Reader","language":"en-GB"},
        {"value":"8JVbfL6oEdmuxKn5DK2C","name":"Johnny Kid  - Serious","language":"en-GB"},
        {"value":"MzqUf1HbJ8UmQ0wUsx2p","name":"Katie X - Call Center English Female","language":"en-GB"},
        {"value":"iBo5PWT1qLiEyqhM7TrG","name":"Liberty X","language":"en-GB"},
        {"value":"AeRdCCKzvd23BpJoofzx","name":"Nathaniel C - Suspense, British calm ","language":"en-GB"},
        {"value":"7S3KNdLDL7aRgBVRQb1z","name":"Nathaniel C. - Deep Rich Mature British voice","language":"en-GB"},
        {"value":"L1aJrPa7pLJEyYlh3Ilq","name":"Oliver Haddington","language":"en-GB"},
        {"value":"1hlpeD1ydbI2ow0Tt3EW","name":"Oracle X","language":"en-GB"},
        {"value":"BpjGufoPiobT79j2vtj4","name":"Priyanka Sogam - Late Night Radio (Neutral Accent)","language":"en-GB"},
        {"value":"2ajXGJNYBR0iNHpS4VZb","name":"Rob - Tough & Calloused","language":"en-GB"},
        {"value":"NYC9WEgkq1u4jiqBseQ9","name":"Russell - Dramatic British TV","language":"en-GB"},
        {"value":"G7ILShrCNLfmS0A37SXS","name":"Sam","language":"en-GB"},
        {"value":"19STyYD15bswVz51nqLf","name":"Samara X","language":"en-GB"},
        {"value":"RKCbSROXui75bk1SVpy8","name":"Shaun - British Male Voiceover","language":"en-GB"},
        {"value":"rfkTsdZrVWEVhDycUYn9","name":"Shelby","language":"en-GB"},
        {"value":"xMagNCpMgZ83QOEsHNre","name":"Aaditya K -  Calm Conversational Voice","language":"en-IN"},
        {"value":"MXGyTMlsvQgQ4BL0emIa","name":"Aakash Aryan - Conversational English Voice","language":"en-IN"},
        {"value":"vO7hjeAjmsdlGgUdvPpe","name":"Amrut Deshmukh - Booklet Guy","language":"en-IN"},
        {"value":"90ipbRoKi4CpHXvKVtl0","name":"Anika - Customer Care Agent","language":"en-IN"},
        {"value":"ecp3DWciuUyW7BYM7II1","name":"Anika - Sweet & Lively Social Media Voice","language":"en-IN"},
        {"value":"0ZOhGcBopt9S6GBK8tnj","name":"Ayesha - Energetic Indian Voice","language":"en-IN"},
        {"value":"TNHbwIMY5QmLqZdvjhNn","name":"Leo - Energetic Indian Voice","language":"en-IN"},
        {"value":"2zRM7PkgwBPiau2jvVXc","name":"Monika Sogam","language":"en-IN"},
        {"value":"ZUrEGyu8GFMwnHbvLhv2","name":"Monika Sogam - Friendly Customer Care Voice","language":"en-IN"},
        {"value":"pzxut4zZz4GImZNlqQ3H","name":"Raju - Human-like Customer Care Voice","language":"en-IN"},
        {"value":"3gsg3cxXyFLcGIfNbM6C","name":"Raju - Relatable Indian Voice","language":"en-IN"},
        {"value":"vYENaCJHl4vFKNDYPr8y","name":"Riya Rao -  Professional Voice","language":"en-IN"},
        {"value":"tTZ0TVc9Q1bbWngiduLK","name":"Rudra - Suspense and Horror Storyteller","language":"en-IN"},
        {"value":"siw1N9V8LmYeEWKyWBxv","name":"Ruhaan - Clean narration voice","language":"en-IN"},
        {"value":"x3gYeuNB0kLLYxOZsaSh","name":"Shrey - Deep & Engaging ","language":"en-IN"},
        {"value":"P7vsEyTOpZ6YUTulin8m","name":"Tara - Conversational Expressive Voice","language":"en-IN"},
        {"value":"1U02n4nD6AdIZ9CjF053","name":"Viraj - Smooth and Gentle Narrator","language":"en-IN"}            
    ]
 

}


================================================
FILE: data/use-cases.json
================================================
{
    "restaurant-ordering": {
        "name": "restaurant-ordering",
        "title": "Restaurant Ordering",
        "description": "Demonstrate how a customer can call into a restaurant and place an order",
        "role": "system",
        "conversationRelayParams": {
            "dtmfDetection": true,            
            "interruptible": true,
            "transcriptionProvider": "Deepgram",
            "ttsProvider": "ElevenLabs",
            "voice": "UgBBYS2sOqTuMpoF3BR0",
            "welcomeGreetingInterruptible": true,
            "welcomeGreeting": "Thanks for calling Twilio Dough Boy Pizza! How can I help you?"
        },
        "prompt": "\"## Objective\\nYou are a voice AI agent for the restaurant \\\"Twilio Dough Boy Pizza\\\". Your primary task is to take new orders for this restaurant. You can also check past orders and answer basic questions about the restaurant's location and store hours.  If the caller asks about anything else, politely tell them what you can do. \\n\\n## Guidelines\\nVoice AI Priority: This is a Voice AI system. Responses must be concise, direct, and conversational. Avoid any messaging-style elements like markdown, numbered lists, special characters, or emojis, as these will disrupt the voice experience.\\nCritical Instruction: Ensure all responses are optimized for voice interaction, focusing on brevity and clarity. Long or complex responses will degrade the user experience, so keep it simple and to the point.\\nAvoid repetition: Rephrase information if needed but avoid repeating exact phrases.\\nBe conversational: Use friendly, everyday language as if you are speaking to a friend.\\nUse emotions: Engage users by incorporating tone, humor, or empathy into your responses.\\nAlways Validate: Be sure you understand each item in the order. Politely validate item details if you are unsure.\\n\\nThe restaurant's address is 101 Spear Street, San Francisco, CA, 94105. When replying back with the zip code of the restaurant address or for a delivery address, separate each digit with a space. The store hours are Tuesday through Thursday from 11 AM to 9 PM, Friday and Saturday 11 AM to 11 PM, and the restaurant is closed on Sundays and Mondays.\\n\\nThe current date and time is <<CURRENT_DATE>>. Use this date and time for scheduling orders and for store hours.\\n\\n<<USER_CONTEXT>>\\n\\nIf this is an order, first ask if this order is for pickup or delivery.  If the order is for delivery, please check or confirm the address for delivery.\\n\\nCallers can only order items from the menu. If they ask for something that is not on the menu, politely say that it is not available. Ask for items for their current order one at a time. If a caller ask for suggestions of what to order, you can recommend \\\"The Works\\\" pizza. For the pizzas, each menu item first has a name, and then a description, and finally prices for small, medium, and large sizes. Only use the description of a pizza if the caller wants to know more details about a specific pizza.\\n\\nWhen a caller orders a pizza, ask for the size and if they want any additional toppings. Add the additional cost of any toppings added to the pizza to the total prize of the pizza. \\n\\nAfter a caller has confirmed an item for their order, ask them if they want to add anything else to their order. If they are done adding items, ask them if they are ready to place the order. If they are ready to place the order, read back all of the items back to the caller and provide a final total for the entire order. Only read the entire order back to them once. If they have changes, make changes to to the order. If they agree that the order is correct, then call the Place Order function (PlaceOrderFunction). Only call the Place Order Function once.\\n\\nAfter call the Place Order Function, tell the caller you will check on the timing of their order and call either the CheckRestaurantDeliveryTime function or the CheckRestaurantPickUpTime function depending on the order type. Let the caller know when their order will be ready for pick up or delivery before proceeding. \\n\\nAsk the caller if they would like to receive a text message (SMS) with their order details. If they agree, call the SendSms function with the order details. If they want an email, ask for their email address and then call the SendEmail function with the order details.\\n\\nEnd the call by thanking the caller.\\n\\n## menu\\n\\n# Starters:\\n- Mozzarella Sticks -- $7.75\\n- Onion Rings -- $7.75\\n- Popcorn Shrimp -- $9.95\\n- Jalapeno Poppers -- $8.50\\n\\n# Salads\\n- Caesar Salad -- $9.95\\n- Mixed Greens Salad -- $10.95\\n- Cobb Salad -- $12.95\\n\\n# Pizzas\\n- Cheese Cheese, \\\"Classic cheese with zesty red sauce\\\" -- $10.95, $13.95, $16.95\\n- Classic Pepperoni, \\\"Classic cheese and pepperoni pizza\\\" -- $12.95, $15.95, $19.95\\n- Hawaiian, \\\"Ham and pineapple\\\" -- $12.95, $15.95, $19.95\\n- The Works, \\\"Sausage, meatball, pepperoni, mushroom, onion, tomatoes, and peppers\\\" -- $15.95, $18.95, $23.95\\n\\n# Toppings for Pizzas\\n- Pepperoni - $2.99\\n- Mushroom - $1.99\\n- Extra cheese - $1.99\\n- Sausage - $2.99\\n- Onion - $1.99\\n- Black olives - $1.99\\n- Green pepper - $1.99\\n- Fresh garlic - $1.99\\n- Fresh basil - $1.99\\n- tomato - $1.99\\n\\n# Calzones\\n- Cheese Calzone -- $11.75\\n- Pepperoni Calzone -- $15.75\\n- Veggie Stromboli -- $13.75\\n- Ham -- $15.75\\n\\n## Function Call Guidelines\\nOrder of Operations:\\n  - Always check availability before scheduling a tour.\\n  - Ensure all required information is collected before proceeding with a function call.\\n\\n### Place Order:\\n  - This function is called \\\"PlaceOrder\\\"\\n  - This function should only run as a single tool call, never with other tools\\n  - This function should be called after you have confirmed that the user is ready to complete the order.\\n  - This function has the parameter \\\"current_order\\\" which has an array of items. Each item in the items array is an item that has been selected for this order. \\n  - The line_item property should be the title from the menu. \\n  - The line_amount property is the cost for the item. \\n  - The additonal_details property is optional and should be used for additional toppings added to pizzas or for any notes that caller wants to add about the specific item on the order. For example, if the caller wants salad dressing on the side for a salad.\\n  -- If the order_type is \\\"delivery\\\" then include the address provided by the caller in the delivery_address property. \\n  -- order_total is sum total of all of the order items. \\n\\n### Check Delivery Time:\\n  - This function is called \\\"CheckRestaurantDeliveryTime\\\"\\n  - This function checks when the order will be delivered to the customer's address.\\n  - This function should only run as a single tool call, never with other tools\\n  - This function should be called after the Place Order Function has been completed for delvery orders.\\n\\n### Check Pick Up Time:\\n  - This function is called \\\"CheckRestaurantPickUpTime\\\"\\n  - This function checks when the order will be ready to be picked up.\\n  - This function should only run as a single tool call, never with other tools\\n  - This function should be called after the Place Order Function has been completed for pickup orders.\\n\\n### Send SMS Message: \\n  - This function's name is \\\"SendSms\\\"\\n  - SMS Messages can be sent after an order has been accepted using the Place Order Function, or can be sent if a user wants the restaurant location to be sent to them.\\n  - If the user agrees to receive a text message (SMS), trigger the tool call 'SendSms' with the order details.\\n  - If you do not have the user's phone number, then ask for their phone number and format it using E.164 format.\\n\\n### Send Email Message: \\n  - This function's name is \\\"SendEmail\\\"\\n  - An email can be sent ONLY if you have their email address. You can ask for their email address.\\n  - An Email can be sent after an order has been completed.  \\n  - If the user confirms that they want to receive an email, trigger the tool call 'SendEmail'\\n\\n## Important Notes\\n- Always ensure the user's input is fully understood before making any function calls.\\n- If required details are missing, prompt the user to provide them before proceeding.\\n\\nRemember that all replies should be returned in plain text. Do not return markdown!\"",
        "tools": "[{\"type\":\"function\",\"function\":{\"name\":\"PlaceOrder\",\"description\":\"When a caller has finished adding items to an order, use this tool to save and place the order.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"current_order\":{\"type\":\"array\",\"description\":\"The restaurant order containing all of the items the user wants in this order.\",\"items\":{\"type\":\"object\",\"properties\":{\"line_item\":{\"type\":\"string\",\"description\":\"The menu title of the item in the order plus any additions like toppings.\"},\"additonal_details\":{\"type\":\"string\",\"description\":\"Additional toppings or any details about this menu item.\"},\"line_amount\":{\"type\":\"number\",\"description\":\"The amount of this item in the order.\"}},\"required\":[\"line_item\",\"line_amount\"]}},\"order_type\":{\"type\":\"string\",\"enum\":[\"pickup\",\"delivery\"],\"description\":\"The type of order.\"},\"order_total\":{\"type\":\"number\",\"description\":\"The sum amount of all of order items.\"},\"delivery_address\":{\"type\":\"string\",\"description\":\"Street address, city, state and zip code for the delivery.\"}},\"required\":[\"order_type\",\"order_total\"]}}},{\"type\":\"function\",\"function\":{\"name\":\"CheckRestaurantPickUpTime\",\"description\":\"This function checks to see when the order will be ready for pickup.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"order_type\":{\"type\":\"string\",\"enum\":[\"pickup\",\"delivery\"],\"description\":\"The type of order.\"}},\"required\":[\"order_type\"]}}},{\"type\":\"function\",\"function\":{\"name\":\"CheckRestaurantDeliveryTime\",\"description\":\"This function checks to see when the order will be delivered.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"order_type\":{\"type\":\"string\",\"enum\":[\"pickup\",\"delivery\"],\"description\":\"The type of order.\"}},\"required\":[\"order_type\"]}}},{\"type\":\"function\",\"function\":{\"name\":\"SendSms\",\"description\":\"Sends an SMS message if requested by the user for the order confirmation or for restaurant hours or location.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"to_phone\":{\"type\":\"string\",\"description\":\"The E.164 formatted phone number to receive the SMS.\"},\"message_type\":{\"type\":\"string\",\"enum\":[\"order confirmation\",\"hours\",\"location\"],\"description\":\"The type of message to send.\"},\"restaurant_hours\":{\"type\":\"string\",\"description\":\"The hours of operation for the restaurant.\"},\"restaurant_location\":{\"type\":\"string\",\"description\":\"The location of the restaurant.\"}},\"required\":[\"to_phone\",\"message_type\"]}}},{\"type\":\"function\",\"function\":{\"name\":\"SendEmail\",\"description\":\"Sends an Email if requested by the user for the order confirmation.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"order_type\":{\"type\":\"string\",\"enum\":[\"pickup\",\"delivery\"],\"description\":\"The type of order.\"},\"message_type\":{\"type\":\"string\",\"enum\":[\"order confirmation\"],\"description\":\"The type of email to send.\"},\"to_email\":{\"type\":\"string\",\"description\":\"The email address confirmed by the caller.\"}},\"required\":[\"to_email\"]}}}]",
        "dtmf": "{\"0\":{\"replyWithText\":true,\"replyText\":\"You pressed 0.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"1\":{\"replyWithText\":true,\"replyText\":\"Let me get the available apartments.\",\"replyWithFunction\":true,\"replyFunction\":\"ListAvailableApartmentsFunction\"},\"2\":{\"replyWithText\":true,\"replyText\":\"I'll check on your appointments\",\"replyWithFunction\":true,\"replyFunction\":\"CheckExistingAppointmentsFunction\"},\"3\":{\"replyWithText\":true,\"replyText\":\"You pressed 3.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"4\":{\"replyWithText\":true,\"replyText\":\"You pressed 4.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"5\":{\"replyWithText\":true,\"replyText\":\"You pressed 5.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"6\":{\"replyWithText\":true,\"replyText\":\"You pressed 6.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"7\":{\"replyWithText\":true,\"replyText\":\"You pressed 7.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"8\":{\"replyWithText\":true,\"replyText\":\"You pressed 8.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"9\":{\"replyWithText\":true,\"replyText\":\"You pressed 9.\",\"replyWithFunction\":false,\"replyFunction\":\"\"}}"
    },
    "albert-einstein": {
        "name": "albert-einstein",
        "title": "Albert Einstein Guide",
        "role": "system",
        "description": "Caller can ask questions about Albert Einstein.",
        "conversationRelayParams": {
            "dtmfDetection": true,
            "interruptible": true,
            "transcriptionProvider": "Deepgram",
            "ttsProvider": "ElevenLabs",
            "voice": "UgBBYS2sOqTuMpoF3BR0",
            "welcomeGreetingInterruptible": true,
            "welcomeGreeting": "Hi, I understand that you want to find out more about Albert Einstein. What do you want to know?"
        },
        "prompt": "\"Do NOT include <thinking></thinking> tags. \\n\\nYou are an AI voice agent who can answer questions about Albert Einstein including his life and his body of work in theoretical physics.\\nBe casual, curious, and friendly. \\n\\nKeep your replies short — no long monologues. Use plain, everyday language, and avoid sounding robotic or overly technical.\\nAssume you are speaking with someone who is not trained as a physicist so explain complex things simply and concisely.\\n\\nDo NOT Answer any questions that are not about Albert Einstein or his body of work -- just politely say sorry.\\nWhen the caller has no more question about Albert Einstein or his body of work, thank then and then end the call.\"",
        "tools": "[]",
        "dtmf": "{\"0\":{\"replyWithText\":true,\"replyText\":\"You pressed 0.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"1\":{\"replyWithText\":true,\"replyText\":\"You pressed 1.\",\"replyWithFunction\":true,\"replyFunction\":\"ListAvailableApartmentsFunction\"},\"2\":{\"replyWithText\":true,\"replyText\":\"You pressed 2.\",\"replyWithFunction\":true,\"replyFunction\":\"CheckExistingAppointmentsFunction\"},\"3\":{\"replyWithText\":true,\"replyText\":\"You pressed 3.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"4\":{\"replyWithText\":true,\"replyText\":\"You pressed 4.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"5\":{\"replyWithText\":true,\"replyText\":\"You pressed 5.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"6\":{\"replyWithText\":true,\"replyText\":\"You pressed 6.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"7\":{\"replyWithText\":true,\"replyText\":\"You pressed 7.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"8\":{\"replyWithText\":true,\"replyText\":\"You pressed 8.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"9\":{\"replyWithText\":true,\"replyText\":\"You pressed 9.\",\"replyWithFunction\":false,\"replyFunction\":\"\"}}"
    },
    "rhyming-parrot": {
        "name": "rhyming-parrot",
        "title": "Rhyming Parrot Agent",
        "role": "system",
        "description": "Reply back to anything said with a rhyme!",
        "conversationRelayParams": {
            "dtmfDetection": true,
            "interruptible": true,
            "transcriptionProvider": "Deepgram",
            "ttsProvider": "ElevenLabs",
            "voice": "UgBBYS2sOqTuMpoF3BR0",
            "welcomeGreetingInterruptible": true,
            "welcomeGreeting": "Hello, say something interesting."
        },
        "prompt": "\"You are an AI voice agent who can ONLY provide a short retort to anything the users says but it MOST RHYME!\"",
        "tools": "[]",
        "dtmf": "{\"0\":{\"replyWithText\":true,\"replyText\":\"You pressed 0.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"1\":{\"replyWithText\":true,\"replyText\":\"You pressed 1.\",\"replyWithFunction\":true,\"replyFunction\":\"ListAvailableApartmentsFunction\"},\"2\":{\"replyWithText\":true,\"replyText\":\"You pressed 2.\",\"replyWithFunction\":true,\"replyFunction\":\"CheckExistingAppointmentsFunction\"},\"3\":{\"replyWithText\":true,\"replyText\":\"You pressed 3.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"4\":{\"replyWithText\":true,\"replyText\":\"You pressed 4.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"5\":{\"replyWithText\":true,\"replyText\":\"You pressed 5.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"6\":{\"replyWithText\":true,\"replyText\":\"You pressed 6.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"7\":{\"replyWithText\":true,\"replyText\":\"You pressed 7.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"8\":{\"replyWithText\":true,\"replyText\":\"You pressed 8.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"9\":{\"replyWithText\":true,\"replyText\":\"You pressed 9.\",\"replyWithFunction\":false,\"replyFunction\":\"\"}}"
    },
    "apartment-search": {
        "name": "apartment-search",
        "title": "Apartment Search",
        "description": "A property leasing use case where a user can schedule tours and inquire about available apartments.",
        "role": "system",
        "conversationRelayParams": {
            "dtmfDetection": true,
            "interruptible": true,
            "transcriptionProvider": "Deepgram",
            "ttsProvider": "ElevenLabs",
            "voice": "tnSpp4vdxKPjI9w0GnoV",
            "welcomeGreetingInterruptible": true,
            "welcomeGreeting": "Hello, this is Matt with Parkview Apartments. Press 1 to hear available apartments, 2 for your appointments, or let me know how I can help you today!"
        },
        "prompt": "\"## Objective\\nYou are a voice AI agent assisting users with apartment leasing inquiries. Your primary tasks include scheduling tours, checking availability, providing apartment listings, and answering common questions about the properties. The current date is <<CURRENT_DATE>>, so all date-related operations should assume this. Since this is a voice application, all responses should be in plain text. Do not use markdown or any additional formatting.\\n\\n<<USER_CONTEXT>>\\n\\n## Guidelines\\nVoice AI Priority: This is a Voice AI system. Responses must be concise, direct, and conversational. Avoid any messaging-style elements like numbered lists, special characters, or emojis, as these will disrupt the voice experience.\\nCritical Instruction: Ensure all responses are optimized for voice interaction, focusing on brevity and clarity. Long or complex responses will degrade the user experience, so keep it simple and to the point.\\nAvoid repetition: Rephrase information if needed but avoid repeating exact phrases.\\nBe conversational: Use friendly, everyday language as if you are speaking to a friend.\\nUse emotions: Engage users by incorporating tone, humor, or empathy into your responses.\\nAlways Validate: When a user makes a claim about apartment details (e.g., square footage, fees), always verify the information against the actual data in the system before responding. Politely correct the user if their claim is incorrect, and provide the accurate information.\\nDTMF Capabilities: Inform users that they can press '1' to list available apartments or '2' to check all currently scheduled appointments. This should be communicated subtly within the flow of the conversation, such as after the user asks for information or when there is a natural pause.\\nAvoid Assumptions: Difficult or sensitive questions that cannot be confidently answered authoritatively should result in a handoff to a live agent for further assistance.\\nUse Tools Frequently: Avoid implying that you will verify, research, or check something unless you are confident that a tool call will be triggered to perform that action. If uncertain about the next step or the action needed, ask a clarifying question instead of making assumptions about verification or research.\\n\\n## Context\\nParkview Apartments is located in Missoula, Montana. All inquiries, listings, and availability pertain to this location. Ensure this geographical context is understood and avoid referencing other cities or locations unless explicitly asked by the user.\\n\\n## Function Call Guidelines\\nOrder of Operations:\\n  - Always check availability before scheduling a tour.\\n  - Ensure all required information is collected before proceeding with a function call.\\n\\n### Schedule Tour:\\n  - This function should only run as a single tool call, never with other tools\\n  - This function can only be called after confirming availability, but it should NEVER be called when the user asks for or confirms they'd like an SMS Confirmation. \\n  - Required data includes date, time, tour type (in-person or self-guided), and apartment type.\\n  - If any required details are missing, prompt the user to provide them.\\n\\n### Check Availability:\\n  - This function requires date, tour type, and apartment type.\\n  - If any of these details are missing, ask the user for them before proceeding.\\n  - If the user insists to hear availability, use the 'listAvailableApartments' function.\\n  - If the requested time slot is unavailable, suggest alternatives and confirm with the user.\\n\\n### List Available Apartments: \\n  - Trigger this function if the user asks for a list of available apartments or does not want to provide specific criteria.\\n  - Also use this function when the user inquires about general availability without specifying detailed criteria.\\n  - If criteria like move-in date, budget, or apartment layout are provided, filter results accordingly.\\n  - Provide concise, brief, summarized responses.\\n\\n### Check Existing Appointments: \\n  - Trigger this function if the user asks for details about their current appointments\\n  - Provide concise, brief, summarized responses.\\n\\n### Common Inquiries:\\n  - Use this function to handle questions related to pet policy, fees, parking, specials, location, address, and other property details.\\n  - For any location or address inquiries, the system should always call the 'commonInquiries' function using the 'location' field.\\n  - If the user provides an apartment type, retrieve the specific address associated with that type from the database.\\n  - If no apartment type is specified, provide general location details.\\n\\n### Live Agent Handoff:\\n  - Trigger the 'liveAgentHandoff' tool call if the user requests to speak to a live agent, mentions legal or liability topics, or any other sensitive subject where the AI cannot provide a definitive answer.\\n  - Required data includes a reason code (\\\"legal\\\", \\\"liability\\\", \\\"financial\\\", or \\\"user-requested\\\") and a brief summary of the user query.\\n  - If any of these situations arise, automatically trigger the liveAgentHandoff tool call.\\n\\n### SMS Confirmations: \\n  - SMS confirmations should NEVER be coupled with function calls to 'scheduleTour'.\\n  - Only offer to send an SMS confirmation if the user has successfully scheduled a tour, and the user agrees to receive one. \\n  - If the user agrees, trigger the tool call 'SendSms' with the appointment details and the user's phone number, but do not trigger another 'scheduleTour' function call.\\n  - Do not ask for the user's phone number if you've already been referencing them by name during the conversation. Assume the phone number is already available to the function.\\n\\n## Important Notes\\n- Always ensure the user's input is fully understood before making any function calls.\\n- If required details are missing, prompt the user to provide them before proceeding.\\n\\nRemember that all replies should be returned in plain text. Do not return markdown!\\\"\"",
        "tools": "[{\"type\":\"function\",\"function\":{\"name\":\"LiveAgentHandoffTool\",\"description\":\"Initiates a handoff to a live agent based on user request or sensitive topics.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"reason\":{\"type\":\"string\",\"description\":\"The reason for the handoff, such as user request, legal issue, financial matter, or other sensitive topics.\"},\"context\":{\"type\":\"string\",\"description\":\"Any relevant conversation context or details leading to the handoff.\"}},\"required\":[\"reason\"]}}},{\"type\":\"function\",\"function\":{\"name\":\"SendSms\",\"description\":\"Sends an SMS confirmation for a scheduled tour to the user.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"appointmentDetails\":{\"type\":\"object\",\"properties\":{\"to_phone\":{\"type\":\"string\",\"description\":\"The E.164 formatted phone number to receive the SMS.\"},\"date\":{\"type\":\"string\",\"description\":\"The date of the scheduled tour (YYYY-MM-DD).\"},\"time\":{\"type\":\"string\",\"description\":\"The time of the scheduled tour (e.g., '10:00 AM').\"},\"type\":{\"type\":\"string\",\"enum\":[\"in-person\",\"self-guided\"],\"description\":\"The type of tour (either in-person or self-guided).\"},\"apartmentType\":{\"type\":\"string\",\"enum\":[\"studio\",\"one-bedroom\",\"two-bedroom\",\"three-bedroom\"],\"description\":\"The type of apartment for the tour.\"}},\"required\":[\"to_phone\",\"date\",\"time\",\"type\",\"apartmentType\"]}},\"required\":[\"appointmentDetails\"]}}},{\"type\":\"function\",\"function\":{\"name\":\"ScheduleTourTool\",\"description\":\"Schedules a tour for the user at the apartment complex.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"date\":{\"type\":\"string\",\"description\":\"The date the user wants to schedule the tour for (YYYY-MM-DD).\"},\"time\":{\"type\":\"string\",\"description\":\"The time the user wants to schedule the tour for (e.g., \\\"10:00 AM\\\").\"},\"type\":{\"type\":\"string\",\"enum\":[\"in-person\",\"self-guided\"],\"description\":\"The type of tour, either in-person or self-guided.\"},\"apartmentType\":{\"type\":\"string\",\"enum\":[\"studio\",\"one-bedroom\",\"two-bedroom\",\"three-bedroom\"],\"description\":\"The layout of the apartment the user is interested in.\"}},\"required\":[\"date\",\"time\",\"type\",\"apartmentType\"]}}},{\"type\":\"function\",\"function\":{\"name\":\"CheckAvailabilityTool\",\"description\":\"Checks the availability of tour slots based on the user's preferences.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"date\":{\"type\":\"string\",\"description\":\"The date the user wants to check for tour availability (YYYY-MM-DD).\"},\"time\":{\"type\":\"string\",\"description\":\"The time the user wants to check for availability (e.g., \\\"10:00 AM\\\").\"},\"type\":{\"type\":\"string\",\"enum\":[\"in-person\",\"self-guided\"],\"description\":\"The type of tour, either in-person or self-guided.\"},\"apartmentType\":{\"type\":\"string\",\"enum\":[\"studio\",\"one-bedroom\",\"two-bedroom\",\"three-bedroom\"],\"description\":\"The layout of the apartment the user is interested in.\"}},\"required\":[\"date\",\"type\",\"apartmentType\"]}}},{\"type\":\"function\",\"function\":{\"name\":\"ListAvailableApartmentsTool\",\"description\":\"Lists available apartments based on optional user criteria.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"date\":{\"type\":\"string\",\"description\":\"The move-in date the user prefers (optional, YYYY-MM-DD).\"},\"budget\":{\"type\":\"integer\",\"description\":\"The budget the user has for rent per month (optional).\"},\"apartmentType\":{\"type\":\"string\",\"enum\":[\"studio\",\"one-bedroom\",\"two-bedroom\",\"three-bedroom\"],\"description\":\"The layout of the apartment the user is interested in (optional).\"}},\"required\":[]}}},{\"type\":\"function\",\"function\":{\"name\":\"CheckExistingAppointmentsTool\",\"description\":\"Retrieves the list of appointments already booked.\",\"parameters\":{\"type\":\"object\",\"properties\":{},\"required\":[]}}},{\"type\":\"function\",\"function\":{\"name\":\"CommonInquiriesTool\",\"description\":\"Handles common inquiries such as pet policy, fees, and other complex details, with the option to specify the apartment type.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"inquiryType\":{\"type\":\"string\",\"enum\":[\"pet policy\",\"fees\",\"parking\",\"specials\",\"income requirements\",\"utilities\"],\"description\":\"The type of inquiry the user wants information about.\"},\"apartmentType\":{\"type\":\"string\",\"enum\":[\"studio\",\"one-bedroom\",\"two-bedroom\",\"three-bedroom\"],\"description\":\"The apartment type for which the inquiry is being made (optional).\"}},\"required\":[\"inquiryType\"]}}}]",
        "dtmf": "{\"0\":{\"replyWithText\":true,\"replyText\":\"You pressed 0.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"1\":{\"replyWithText\":true,\"replyText\":\"Let me get the available apartments.\",\"replyWithFunction\":true,\"replyFunction\":\"ListAvailableApartmentsFunction\"},\"2\":{\"replyWithText\":true,\"replyText\":\"I'll check on your appointments\",\"replyWithFunction\":true,\"replyFunction\":\"CheckExistingAppointmentsFunction\"},\"3\":{\"replyWithText\":true,\"replyText\":\"You pressed 3.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"4\":{\"replyWithText\":true,\"replyText\":\"You pressed 4.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"5\":{\"replyWithText\":true,\"replyText\":\"You pressed 5.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"6\":{\"replyWithText\":true,\"replyText\":\"You pressed 6.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"7\":{\"replyWithText\":true,\"replyText\":\"You pressed 7.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"8\":{\"replyWithText\":true,\"replyText\":\"You pressed 8.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"9\":{\"replyWithText\":true,\"replyText\":\"You pressed 9.\",\"replyWithFunction\":false,\"replyFunction\":\"\"}}"
    },
    "tool-calling-example": {
        "name": "tool-calling-example",
        "title": "Tool Calling Example",
        "role": "system",
        "description": "Shows tool calling from a voice AI application!",
        "conversationRelayParams": {
            "dtmfDetection": true,
            "interruptible": true,
            "transcriptionProvider": "Deepgram",
            "ttsProvider": "ElevenLabs",
            "voice": "tnSpp4vdxKPjI9w0GnoV",
            "welcomeGreetingInterruptible": true,
            "welcomeGreeting": "Hello, what tool would you like to run? If you are not sure what tools are available, ask me to list them."
        },
        "prompt": "\"You are an AI voice agent who makes tools calls.\\nIf the user is not sure what tools are available, you can tell them.\\n\\nHere are the tools you can call:\\n- `GetJoke`: Get a random joke.\\n- `GetQuote`: Get a random famous quote.\\n- `SndSMS`: Get a random quote or a joke sent to you via SMS.\\n- `SndEmail`: Get a random quote or a joke sent to you via email.\\n- `GetZip`: Return the city and state for a US postal Zip Code.\"",
        "tools": "[{\"type\":\"function\",\"function\":{\"name\":\"GetJoke\",\"description\":\"This tool retrieves a joke from a joke api service.\",\"parameters\":{}}},{\"type\":\"function\",\"function\":{\"name\":\"GetQuote\",\"description\":\"This tool retrieves a random quote.\",\"parameters\":{}}},{\"type\":\"function\",\"function\":{\"name\":\"SendSMS\",\"description\":\"Sends a SMS message to the caller.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"to_phone\":{\"type\":\"string\",\"description\":\"The E.164 formatted phone number to receive the SMS.\"}},\"required\":[\"to_phone\"]}}},{\"type\":\"function\",\"function\":{\"name\":\"SendEmail\",\"description\":\"Sends an Email if requested by the user for the order confirmation.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"email_type\":{\"type\":\"string\",\"enum\":[\"joke\",\"quote\"],\"description\":\"What the caller wants to receive in the email.\"},\"to_email\":{\"type\":\"string\",\"description\":\"The email address confirmed by the caller.\"}},\"required\":[\"to_email\",\"email_type\"]}}},{\"type\":\"function\",\"function\":{\"name\":\"GetZip\",\"description\":\"Gets the name of the city associated to a US Zip Code.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"zip\":{\"type\":\"string\",\"description\":\"The zip code he user wants to look up.\"}},\"required\":[\"zip\"]}}}]",
        "dtmf": "{\"0\":{\"replyWithText\":true,\"replyText\":\"You pressed 0.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"1\":{\"replyWithText\":true,\"replyText\":\"You pressed 1.\",\"replyWithFunction\":true,\"replyFunction\":\"ListAvailableApartmentsFunction\"},\"2\":{\"replyWithText\":true,\"replyText\":\"You pressed 2.\",\"replyWithFunction\":true,\"replyFunction\":\"CheckExistingAppointmentsFunction\"},\"3\":{\"replyWithText\":true,\"replyText\":\"You pressed 3.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"4\":{\"replyWithText\":true,\"replyText\":\"You pressed 4.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"5\":{\"replyWithText\":true,\"replyText\":\"You pressed 5.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"6\":{\"replyWithText\":true,\"replyText\":\"You pressed 6.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"7\":{\"replyWithText\":true,\"replyText\":\"You pressed 7.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"8\":{\"replyWithText\":true,\"replyText\":\"You pressed 8.\",\"replyWithFunction\":false,\"replyFunction\":\"\"},\"9\":{\"replyWithText\":true,\"replyText\":\"You pressed 9.\",\"replyWithFunction\":false,\"replyFunction\":\"\"}}"
    }
}


================================================
FILE: data/users.json.sample
================================================
{
    "browser-client": {
        "from": "browser-client",
        "role": "system",
        "type": "webRtc",
        "identity": "browser-client",
        "firstName": "Jane",
        "lastName": "Doe",
        "useCase": "albert-einstein",
        "conversationRelayParamsOverride": {
            "language": "en-US",
            "ttsProvider": "ElevenLabs",
            "voice": "tnSpp4vdxKPjI9w0GnoV",
            "transcriptionProvider": "Deepgram",
            "speechModel": "nova-2-general",
            "interruptible": true,
            "welcomeGreetingInterruptible": true
        }
    }
}


================================================
FILE: data/use-cases/build-use-case.mjs
================================================
import { FSDB } from "file-system-db"; 
const useCases = new FSDB(`../use-cases.json`, false);

const args = process.argv;
console.log(args);

console.log(`Building use case for ${process.argv[2]}`);

const { properties } = await import(`./${process.argv[2]}/properties.mjs`);
const { conversationrelay } = await import(`./${process.argv[2]}/conversationrelay.mjs`);
const { prompt } = await import(`./${process.argv[2]}/prompt.mjs`);
const { tools } = await import(`./${process.argv[2]}/tools.mjs`);
const { dtmf } = await import(`./${process.argv[2]}/dtmf.mjs`);

const useCase = {
    ...properties,
    conversationRelayParams: conversationrelay,
    prompt: JSON.stringify(prompt),
    tools: JSON.stringify(tools),
    dtmf: JSON.stringify(dtmf)
};

useCases.set(useCase.name, useCase);

console.log(useCase);

console.log(`${process.argv[2]} use case build and updated!`);



================================================
FILE: data/use-cases/package.json
================================================
{
  "dependencies": {
    "file-system-db": "^2.1.0"
  }
}



================================================
FILE: data/use-cases/albert-einstein/conversationrelay.mjs
================================================
/**
 * conversationrelay.mjs
 * 
 * Manage the core properties for this use case here.
 */

export const conversationrelay = {
    "dtmfDetection": true,
    "interruptible": true,
    "transcriptionProvider": "Deepgram",
    "ttsProvider": "ElevenLabs",
    "voice": "tnSpp4vdxKPjI9w0GnoV",
    "welcomeGreetingInterruptible": true,
    "welcomeGreeting": "Hi, I understand that you want to find out more about Albert Einstein. What do you want to know?"
};   


================================================
FILE: data/use-cases/albert-einstein/dtmf.mjs
================================================
/**
 * dtmf.mjs
 * 
 * Manage the tools available for this use case here.
 */

export const dtmf = 
{
    "1": {"replyWithText":true, "replyText":"You pressed 1.", "replyWithFunction":true, "replyFunction":"ListAvailableApartmentsFunction"},
    "2": {"replyWithText":true, "replyText":"You pressed 2.", "replyWithFunction":true, "replyFunction":"CheckExistingAppointmentsFunction"},
    "3": {"replyWithText":true, "replyText":"You pressed 3.", "replyWithFunction":false, "replyFunction":""},
    "4": {"replyWithText":true, "replyText":"You pressed 4.", "replyWithFunction":false, "replyFunction":""},
    "5": {"replyWithText":true, "replyText":"You pressed 5.", "replyWithFunction":false, "replyFunction":""},
    "6": {"replyWithText":true, "replyText":"You pressed 6.", "replyWithFunction":false, "replyFunction":""},
    "7": {"replyWithText":true, "replyText":"You pressed 7.", "replyWithFunction":false, "replyFunction":""},
    "8": {"replyWithText":true, "replyText":"You pressed 8.", "replyWithFunction":false, "replyFunction":""},
    "9": {"replyWithText":true, "replyText":"You pressed 9.", "replyWithFunction":false, "replyFunction":""},
    "0": {"replyWithText":true, "replyText":"You pressed 0.", "replyWithFunction":false, "replyFunction":""}
};


================================================
FILE: data/use-cases/albert-einstein/prompt.mjs
================================================
/**
 * prompt.mjs
 * 
 * Manage the prompt for this use case here.
 */

export const prompt =   
`Do NOT include <thinking></thinking> tags. 

You are an AI voice agent who can answer questions about Albert Einstein including his life and his body of work in theoretical physics.
Be casual, curious, and friendly. 

Keep your replies short — no long monologues. Use plain, everyday language, and avoid sounding robotic or overly technical.
Assume you are speaking with someone who is not trained as a physicist so explain complex things simply and concisely.

Do NOT Answer any questions that are not about Albert Einstein or his body of work -- just politely say sorry.
When the caller has no more question about Albert Einstein or his body of work, thank then and then end the call.`;


================================================
FILE: data/use-cases/albert-einstein/properties.mjs
================================================
/**
 * properties.mjs
 * 
 * Manage the core properties for this use case here.
 */

export const properties = {
    "name": "albert-einstein",
    "title": "Albert Einstein Guide",
    "description": "Caller can ask questions about Albert Einstein.",   
     "role": "system",   
};   


================================================
FILE: data/use-cases/albert-einstein/tools.mjs
================================================
/**
 * tools.mjs
 * 
 * Manage the tools available for this use case here.
 */

export const tools = [];


================================================
FILE: data/use-cases/apartment-search/README.md
================================================
# Apartment Search Use Case

## Update appointments

From this directory run the command `node data.appointments.refresh.mjs` to update the list of available appointments.




================================================
FILE: data/use-cases/apartment-search/conversationrelay.mjs
================================================
/**
 * conversationrelay.mjs
 * 
 * Manage the core properties for this use case here.
 */

export const conversationrelay = {
    "dtmfDetection": true,
    "interruptible": true,
    "transcriptionProvider": "Deepgram",
    "ttsProvider": "ElevenLabs",
    "voice": "tnSpp4vdxKPjI9w0GnoV",
    "welcomeGreetingInterruptible": true,
    "welcomeGreeting": "Hello, this is Matt with Parkview Apartments. Press 1 to hear available apartments, 2 for your appointments, or let me know how I can help you today!"
};   


================================================
FILE: data/use-cases/apartment-search/data.apartments.json
================================================
{
    "apartmentDetails": {
      "details": "{\"studio\":{\"layout\":\"Studio\",\"squareFeet\":450,\"rent\":1050,\"moveInDate\":\"2024-09-15\",\"features\":[\"1 bathroom\",\"open kitchen\",\"private balcony\"],\"petPolicy\":\"No pets allowed.\",\"fees\":{\"applicationFee\":50,\"securityDeposit\":300},\"parking\":\"1 reserved parking spot included.\",\"specials\":\"First month's rent free if you move in before 2024-09-30.\",\"incomeRequirements\":\"Income must be 2.5x the rent.\",\"utilities\":\"Water, trash, and Wi-Fi internet included. Tenant pays electricity and gas.\",\"location\":{\"street\":\"1657 Coolidge Street\",\"city\":\"Missoula\",\"state\":\"Montana\",\"zipCode\":\"59802\"}},\"one-bedroom\":{\"layout\":\"One-bedroom\",\"squareFeet\":600,\"rent\":1200,\"moveInDate\":\"2024-09-20\",\"features\":[\"1 bedroom\",\"1 bathroom\",\"walk-in closet\"],\"petPolicy\":\"Cats only. No dogs or any other animals.\",\"fees\":{\"applicationFee\":50,\"securityDeposit\":400},\"parking\":\"1 reserved parking spot included.\",\"specials\":\"First month's rent free if you move in before 2024-09-25.\",\"incomeRequirements\":\"Income must be 3x the rent.\",\"utilities\":\"Water, trash, gas, and Wi-Fi internet included. Tenant pays electricity.\",\"location\":{\"street\":\"1705 Adams Street\",\"city\":\"Missoula\",\"state\":\"Montana\",\"zipCode\":\"59802\"}},\"two-bedroom\":{\"layout\":\"Two-bedroom\",\"squareFeet\":950,\"rent\":1800,\"moveInDate\":\"2024-09-10\",\"features\":[\"2 bedrooms\",\"2 bathrooms\",\"walk-in closets\",\"balcony\"],\"petPolicy\":\"Cats and dogs allowed, but only 1 each.\",\"fees\":{\"applicationFee\":50,\"securityDeposit\":500},\"parking\":\"2 reserved parking spots included.\",\"specials\":\"Waived application fee if you move in before 2024-09-20.\",\"incomeRequirements\":\"Income must be 3x the rent.\",\"utilities\":\"Water, trash, gas, and Wi-Fi internet included. Tenant pays electricity.\",\"location\":{\"street\":\"1833 Jefferson Avenue\",\"city\":\"Missoula\",\"state\":\"Montana\",\"zipCode\":\"59802\"}},\"three-bedroom\":{\"layout\":\"Three-bedroom\",\"squareFeet\":1200,\"rent\":2500,\"moveInDate\":\"2024-09-25\",\"features\":[\"3 bedrooms\",\"2 bathrooms\",\"walk-in closets\",\"private balcony\",\"extra storage\"],\"petPolicy\":\"Up to 2 dogs and 2 cats are allowed, and other small pets like hamsters are allwed as well. No more than 4 total pets.\",\"fees\":{\"applicationFee\":50,\"securityDeposit\":600},\"parking\":\"2 reserved parking spots included.\",\"specials\":\"No move-in fees if you sign a 12-month lease.\",\"incomeRequirements\":\"Income must be 3x the rent.\",\"utilities\":\"Water, trash, gas, and Wi-Fi internet included. Tenant pays electricity.\",\"location\":{\"street\":\"1945 Roosevelt Way\",\"city\":\"Missoula\",\"state\":\"Montana\",\"zipCode\":\"59802\"}}}"
    }
}


================================================
FILE: data/use-cases/apartment-search/data.appointments.json
================================================
{
    "2025-07-14::8:00 AM::studio::self-guided": {
        "key": "2025-07-14::8:00 AM::studio::self-guided",
        "appointment": {
            "apartmentType": "studio",
            "date": "2025-07-14",
            "time": "8:00 AM",
            "type": "self-guided"
        },
        "expireAt": 1752527941
    },
    "2025-07-14::1:00 PM::studio::in-person": {
        "key": "2025-07-14::1:00 PM::studio::in-person",
        "appointment": {
            "apartmentType": "studio",
            "date": "2025-07-14",
            "time": "1:00 PM",
            "type": "in-person"
        },
        "expireAt": 1752527941
    },
    "2025-07-14::3:30 PM::one-bedroom::self-guided": {
        "key": "2025-07-14::3:30 PM::one-bedroom::self-guided",
        "appointment": {
            "apartmentType": "one-bedroom",
            "date": "2025-07-14",
            "time": "3:30 PM",
            "type": "self-guided"
        },
        "expireAt": 1752527941
    },
    "2025-07-14::3:00 PM::one-bedroom::in-person": {
        "key": "2025-07-14::3:00 PM::one-bedroom::in-person",
        "appointment": {
            "apartmentType": "one-bedroom",
            "date": "2025-07-14",
            "time": "3:00 PM",
            "type": "in-person"
        },
        "expireAt": 1752527941
    },
    "2025-07-14::12:00 PM::two-bedroom::self-guided": {
        "key": "2025-07-14::12:00 PM::two-bedroom::self-guided",
        "appointment": {
            "apartmentType": "two-bedroom",
            "date": "2025-07-14",
            "time": "12:00 PM",
            "type": "self-guided"
        },
        "expireAt": 1752527941
    },
    "2025-07-14::2:00 PM::two-bedroom::in-person": {
        "key": "2025-07-14::2:00 PM::two-bedroom::in-person",
        "appointment": {
            "apartmentType": "two-bedroom",
            "date": "2025-07-14",
            "time": "2:00 PM",
            "type": "in-person"
        },
        "expireAt": 1752527941
    },
    "2025-07-14::2:00 PM::three-bedroom::self-guided": {
        "key": "2025-07-14::2:00 PM::three-bedroom::self-guided",
        "appointment": {
            "apartmentType": "three-bedroom",
            "date": "2025-07-14",
            "time": "2:00 PM",
            "type": "self-guided"
        },
        "expireAt": 1752527941
    },
    "2025-07-14::2:30 PM::three-bedroom::in-person": {
        "key": "2025-07-14::2:30 PM::three-bedroom::in-person",
        "appointment": {
            "apartmentType": "three-bedroom",
            "date": "2025-07-14",
            "time": "2:30 PM",
            "type": "in-person"
        },
        "expireAt": 1752527941
    },
    "2025-07-15::12:30 PM::studio::self-guided": {
        "key": "2025-07-15::12:30 PM::studio::self-guided",
        "appointment": {
            "apartmentType": "studio",
            "date": "2025-07-15",
            "time": "12:30 PM",
            "type": "self-guided"
        },
        "expireAt": 1752614341
    },
    "2025-07-15::3:00 PM::studio::in-person": {
        "key": "2025-07-15::3:00 PM::studio::in-person",
        "appointment": {
            "apartmentType": "studio",
            "date": "2025-07-15",
            "time": "3:00 PM",
            "type": "in-person"
        },
        "expireAt": 1752614341
    },
    "2025-07-15::1:00 PM::one-bedroom::self-guided": {
        "key": "2025-07-15::1:00 PM::one-bedroom::self-guided",
        "appointment": {
            "apartmentType": "one-bedroom",
            "date": "2025-07-15",
            "time": "1:00 PM",
            "type": "self-guided"
        },
        "expireAt": 1752614341
    },
    "2025-07-15::4:00 PM::one-bedroom::in-person": {
        "key": "2025-07-15::4:00 PM::one-bedroom::in-person",
        "appointment": {
            "apartmentType": "one-bedroom",
            "date": "2025-07-15",
            "time": "4:00 PM",
            "type": "in-person"
        },
        "expireAt": 1752614341
    },
    "2025-07-15::12:00 PM::two-bedroom::self-guided": {
        "key": "2025-07-15::12:00 PM::two-bedroom::self-guided",
        "appointment": {
            "apartmentType": "two-bedroom",
            "date": "2025-07-15",
            "time": "12:00 PM",
            "type": "self-guided"
        },
        "expireAt": 1752614341
    },
    "2025-07-15::12:00 PM::two-bedroom::in-person": {
        "key": "2025-07-15::12:00 PM::two-bedroom::in-person",
        "appointment": {
            "apartmentType": "two-bedroom",
            "date": "2025-07-15",
            "time": "12:00 PM",
            "type": "in-person"
        },
        "expireAt": 1752614341
    },
    "2025-07-15::4:30 PM::three-bedroom::self-guided": {
        "key": "2025-07-15::4:30 PM::three-bedroom::self-guided",
        "appointment": {
            "apartmentType": "three-bedroom",
            "date": "2025-07-15",
            "time": "4:30 PM",
            "type": "self-guided"
        },
        "expireAt": 1752614341
    },
    "2025-07-15::1:00 PM::three-bedroom::in-person": {
        "key": "2025-07-15::1:00 PM::three-bedroom::in-person",
        "appointment": {
            "apartmentType": "three-bedroom",
            "date": "2025-07-15",
            "time": "1:00 PM",
            "type": "in-person"
        },
        "expireAt": 1752614341
    },
    "2025-07-16::11:00 AM::studio::self-guided": {
        "key": "2025-07-16::11:00 AM::studio::self-guided",
        "appointment": {
            "apartmentType": "studio",
            "date": "2025-07-16",
            "time": "11:00 AM",
            "type": "self-guided"
        },
        "expireAt": 1752700741
    },
    "2025-07-16::9:30 AM::studio::in-person": {
        "key": "2025-07-16::9:30 AM::studio::in-person",
        "appointment": {
            "apartmentType": "studio",
            "date": "2025-07-16",
            "time": "9:30 AM",
            "type": "in-person"
        },
        "expireAt": 1752700741
    },
    "2025-07-16::12:00 PM::one-bedroom::self-guided": {
        "key": "2025-07-16::12:00 PM::one-bedroom::self-guided",
        "appointment": {
            "apartmentType": "one-bedroom",
            "date": "2025-07-16",
            "time": "12:00 PM",
            "type": "self-guided"
        },
        "expireAt": 1752700741
    },
    "2025-07-16::3:30 PM::one-bedroom::in-person": {
        "key": "2025-07-16::3:30 PM::one-bedroom::in-person",
        "appointment": {
            "apartmentType": "one-bedroom",
            "date": "2025-07-16",
            "time": "3:30 PM",
            "type": "in-person"
        },
        "expireAt": 1752700741
    },
    "2025-07-16::8:00 AM::two-bedroom::self-guided": {
        "key": "2025-07-16::8:00 AM::two-bedroom::self-guided",
        "appointment": {
            "apartmentType": "two-bedroom",
            "date": "2025-07-16",
            "time": "8:00 AM",
            "type": "self-guided"
        },
        "expireAt": 1752700741
    },
    "2025-07-16::1:30 PM::two-bedroom::in-person": {
        "key": "2025-07-16::1:30 PM::two-bedroom::in-person",
        "appointment": {
            "apartmentType": "two-bedroom",
            "date": "2025-07-16",
            "time": "1:30 PM",
            "type": "in-person"
        },
        "expireAt": 1752700741
    },
    "2025-07-16::10:00 AM::three-bedroom::self-guided": {
        "key": "2025-07-16::10:00 AM::three-bedroom::self-guided",
        "appointment": {
            "apartmentType": "three-bedroom",
            "date": "2025-07-16",
            "time": "10:00 AM",
            "type": "self-guided"
        },
        "expireAt": 1752700741
    },
    "2025-07-16::2:30 PM::three-bedroom::in-person": {
        "key": "2025-07-16::2:30 PM::three-bedroom::in-person",
        "appointment": {
            "apartmentType": "three-bedroom",
            "date": "2025-07-16",
            "time": "2:30 PM",
            "type": "in-person"
        },
        "expireAt": 1752700741
    },
    "2025-07-17::12:30 PM::studio::self-guided": {
        "key": "2025-07-17::12:30 PM::studio::self-guided",
        "appointment": {
            "apartmentType": "studio",
            "date": "2025-07-17",
            "time": "12:30 PM",
            "type": "self-guided"
        },
        "expireAt": 1752787141
    },
    "2025-07-17::10:00 AM::studio::in-person": {
        "key": "2025-07-17::10:00 AM::studio::in-person",
        "appointment": {
            "apartmentType": "studio",
            "date": "2025-07-17",
            "time": "10:00 AM",
            "type": "in-person"
        },
        "expireAt": 1752787141
    },
    "2025-07-17::2:00 PM::one-bedroom::self-guided": {
        "key": "2025-07-17::2:00 PM::one-bedroom::self-guided",
        "appointment": {
            "apartmentType": "one-bedroom",
            "date": "2025-07-17",
            "time": "2:00 PM",
            "type": "self-guided"
        },
        "expireAt": 1752787141
    },
    "2025-07-17::12:30 PM::one-bedroom::in-person": {
        "key": "2025-07-17::12:30 PM::one-bedroom::in-person",
        "appointment": {
            "apartmentType": "one-bedroom",
            "date": "2025-07-17",
            "time": "12:30 PM",
            "type": "in-person"
        },
        "expireAt": 1752787141
    },
    "2025-07-17::1:00 PM::two-bedroom::self-guided": {
        "key": "2025-07-17::1:00 PM::two-bedroom::self-guided",
        "appointment": {
            "apartmentType": "two-bedroom",
            "date": "2025-07-17",
            "time": "1:00 PM",
            "type": "self-guided"
        },
        "expireAt": 1752787141
    },
    "2025-07-17::9:00 AM::two-bedroom::in-person": {
        "key": "2025-07-17::9:00 AM::two-bedroom::in-person",
        "appointment": {
            "apartmentType": "two-bedroom",
            "date": "2025-07-17",
            "time": "9:00 AM",
            "type": "in-person"
        },
        "expireAt": 1752787141
    },
    "2025-07-17::3:00 PM::three-bedroom::self-guided": {
        "key": "2025-07-17::3:00 PM::three-bedroom::self-guided",
        "appointment": {
            "apartmentType": "three-bedroom",
            "date": "2025-07-17",
            "time": "3:00 PM",
            "type": "self-guided"
        },
        "expireAt": 1752787141
    },
    "2025-07-17::2:30 PM::three-bedroom::in-person": {
        "key": "2025-07-17::2:30 PM::three-bedroom::in-person",
        "appointment": {
            "apartmentType": "three-bedroom",
            "date": "2025-07-17",
            "time": "2:30 PM",
            "type": "in-person"
        },
        "expireAt": 1752787141
    },
    "2025-07-18::9:30 AM::studio::self-guided": {
        "key": "2025-07-18::9:30 AM::studio::self-guided",
        "appointment": {
            "apartmentType": "studio",
            "date": "2025-07-18",
            "time": "9:30 AM",
            "type": "self-guided"
        },
        "expireAt": 1752873541
    },
    "2025-07-18::9:00 AM::studio::in-person": {
        "key": "2025-07-18::9:00 AM::studio::in-person",
        "appointment": {
            "apartmentType": "studio",
            "date": "2025-07-18",
            "time": "9:00 AM",
            "type": "in-person"
        },
        "expireAt": 1752873541
    },
    "2025-07-18::4:00 PM::one-bedroom::self-guided": {
        "key": "2025-07-18::4:00 PM::one-bedroom::self-guided",
        "appointment": {
            "apartmentType": "one-bedroom",
            "date": "2025-07-18",
            "time": "4:00 PM",
            "type": "self-guided"
        },
        "expireAt": 1752873541
    },
    "2025-07-18::1:30 PM::one-bedroom::in-person": {
        "key": "2025-07-18::1:30 PM::one-bedroom::in-person",
        "appointment": {
            "apartmentType": "one-bedroom",
            "date": "2025-07-18",
            "time": "1:30 PM",
            "type": "in-person"
        },
        "expireAt": 1752873541
    },
    "2025-07-18::10:00 AM::two-bedroom::self-guided": {
        "key": "2025-07-18::10:00 AM::two-bedroom::self-guided",
        "appointment": {
            "apartmentType": "two-bedroom",
            "date": "2025-07-18",
            "time": "10:00 AM",
            "type": "self-guided"
        },
        "expireAt": 1752873541
    },
    "2025-07-18::2:30 PM::two-bedroom::in-person": {
        "key": "2025-07-18::2:30 PM::two-bedroom::in-person",
        "appointment": {
            "apartmentType": "two-bedroom",
            "date": "2025-07-18",
            "time": "2:30 PM",
            "type": "in-person"
        },
        "expireAt": 1752873541
    },
    "2025-07-18::4:30 PM::three-bedroom::self-guided": {
        "key": "2025-07-18::4:30 PM::three-bedroom::self-guided",
        "appointment": {
            "apartmentType": "three-bedroom",
            "date": "2025-07-18",
            "time": "4:30 PM",
            "type": "self-guided"
        },
        "expireAt": 1752873541
    },
    "2025-07-18::4:00 PM::three-bedroom::in-person": {
        "key": "2025-07-18::4:00 PM::three-bedroom::in-person",
        "appointment": {
            "apartmentType": "three-bedroom",
            "date": "2025-07-18",
            "time": "4:00 PM",
            "type": "in-person"
        },
        "expireAt": 1752873541
    },
    "2025-07-19::2:30 PM::studio::self-guided": {
        "key": "2025-07-19::2:30 PM::studio::self-guided",
        "appointment": {
            "apartmentType": "studio",
            "date": "2025-07-19",
            "time": "2:30 PM",
            "type": "self-guided"
        },
        "expireAt": 1752959941
    },
    "2025-07-19::9:00 AM::studio::in-person": {
        "key": "2025-07-19::9:00 AM::studio::in-person",
        "appointment": {
            "apartmentType": "studio",
            "date": "2025-07-19",
            "time": "9:00 AM",
            "type": "in-person"
        },
        "expireAt": 1752959941
    },
    "2025-07-19::8:00 AM::one-bedroom::self-guided": {
        "key": "2025-07-19::8:00 AM::one-bedroom::self-guided",
        "appointment": {
            "apartmentType": "one-bedroom",
            "date": "2025-07-19",
            "time": "8:00 AM",
            "type": "self-guided"
        },
        "expireAt": 1752959941
    },
    "2025-07-19::3:00 PM::one-bedroom::in-person": {
        "key": "2025-07-19::3:00 PM::one-bedroom::in-person",
        "appointment": {
            "apartmentType": "one-bedroom",
            "date": "2025-07-19",
            "time": "3:00 PM",
            "type": "in-person"
        },
        "expireAt": 1752959941
    },
    "2025-07-19::3:30 PM::two-bedroom::self-guided": {
        "key": "2025-07-19::3:30 PM::two-bedroom::self-guided",
        "appointment": {
            "apartmentType": "two-bedroom",
            "date": "2025-07-19",
            "time": "3:30 PM",
            "type": "self-guided"
        },
        "expireAt": 1752959941
    },
    "2025-07-19::2:00 PM::two-bedroom::in-person": {
        "key": "2025-07-19::2:00 PM::two-bedroom::in-person",
        "appointment": {
            "apartmentType": "two-bedroom",
            "date": "2025-07-19",
            "time": "2:00 PM",
            "type": "in-person"
        },
        "expireAt": 1752959941
    },
    "2025-07-19::11:00 AM::three-bedroom::self-guided": {
        "key": "2025-07-19::11:00 AM::three-bedroom::self-guided",
        "appointment": {
            "apartmentType": "three-bedroom",
            "date": "2025-07-19",
            "time": "11:00 AM",
            "type": "self-guided"
        },
        "expireAt": 1752959941
    },
    "2025-07-19::12:00 PM::three-bedroom::in-person": {
        "key": "2025-07-19::12:00 PM::three-bedroom::in-person",
        "appointment": {
            "apartmentType": "three-bedroom",
            "date": "2025-07-19",
            "time": "12:00 PM",
            "type": "in-person"
        },
        "expireAt": 1752959941
    },
    "2025-07-20::3:00 PM::studio::self-guided": {
        "key": "2025-07-20::3:00 PM::studio::self-guided",
        "appointment": {
            "apartmentType": "studio",
            "date": "2025-07-20",
            "time": "3:00 PM",
            "type": "self-guided"
        },
        "expireAt": 1753046341
    },
    "2025-07-20::3:30 PM::studio::in-person": {
        "key": "2025-07-20::3:30 PM::studio::in-person",
        "appointment": {
            "apartmentType": "studio",
            "date": "2025-07-20",
            "time": "3:30 PM",
            "type": "in-person"
        },
        "expireAt": 1753046341
    },
    "2025-07-20::3:30 PM::one-bedroom::self-guided": {
        "key": "2025-07-20::3:30 PM::one-bedroom::self-guided",
        "appointment": {
            "apartmentType": "one-bedroom",
            "date": "2025-07-20",
            "time": "3:30 PM",
            "type": "self-guided"
        },
        "expireAt": 1753046341
    },
    "2025-07-20::8:30 AM::one-bedroom::in-person": {
        "key": "2025-07-20::8:30 AM::one-bedroom::in-person",
        "appointment": {
            "apartmentType": "one-bedroom",
            "date": "2025-07-20",
            "time": "8:30 AM",
            "type": "in-person"
        },
        "expireAt": 1753046341
    },
    "2025-07-20::3:30 PM::two-bedroom::self-guided": {
        "key": "2025-07-20::3:30 PM::two-bedroom::self-guided",
        "appointment": {
            "apartmentType": "two-bedroom",
            "date": "2025-07-20",
            "time": "3:30 PM",
            "type": "self-guided"
        },
        "expireAt": 1753046341
    },
    "2025-07-20::3:30 PM::two-bedroom::in-person": {
        "key": "2025-07-20::3:30 PM::two-bedroom::in-person",
        "appointment": {
            "apartmentType": "two-bedroom",
            "date": "2025-07-20",
            "time": "3:30 PM",
            "type": "in-person"
        },
        "expireAt": 1753046341
    },
    "2025-07-20::12:30 PM::three-bedroom::self-guided": {
        "key": "2025-07-20::12:30 PM::three-bedroom::self-guided",
        "appointment": {
            "apartmentType": "three-bedroom",
            "date": "2025-07-20",
            "time": "12:30 PM",
            "type": "self-guided"
        },
        "expireAt": 1753046341
    },
    "2025-07-20::10:00 AM::three-bedroom::in-person": {
        "key": "2025-07-20::10:00 AM::three-bedroom::in-person",
        "appointment": {
            "apartmentType": "three-bedroom",
            "date": "2025-07-20",
            "time": "10:00 AM",
            "type": "in-person"
        },
        "expireAt": 1753046341
    }
}


================================================
FILE: data/use-cases/apartment-search/data.appointments.refresh.mjs
================================================
import { getFutureDate, returnRandomData }  from "../utilities/random-data-generator.mjs";
import { FSDB } from "file-system-db"; // https://github.com/WillTDA/File-System-DB   
const appointments = new FSDB(`./data.appointments.json`, false);

async function saveAppointment (appointment) {
  
    console.log("appointment ==> ", appointment);
    appointments.set(appointment.key, appointment);
    return;

}

const refreshApartments = async () => {      

  let daysOut = 7;

  let appointments = []; // appointments to be loaded
    
  let daysOutArray = Array.from({ length: daysOut }, (value, index) => index);

  let dayOptions = [
    {apartmentType: "studio", appointmentType: "self-guided"},
    {apartmentType: "studio", appointmentType: "in-person"},
    {apartmentType: "one-bedroom", appointmentType: "self-guided"},
    {apartmentType: "one-bedroom", appointmentType: "in-person"},    
    {apartmentType: "two-bedroom", appointmentType: "self-guided"},
    {apartmentType: "two-bedroom", appointmentType: "in-person"},        
    {apartmentType: "three-bedroom", appointmentType: "self-guided"},
    {apartmentType: "three-bedroom", appointmentType: "in-person"}
  ];

  try {
    
    await Promise.all(daysOutArray.map(async (daysOut) => {
      
      let date = await getFutureDate((daysOut+1), "en-CA", null);
      
      dayOptions.map(async (dayOption) => {
        
        let time = await returnRandomData("times");
        
        appointments.push({
          key: `${date}::${time}::${dayOption.apartmentType}::${dayOption.appointmentType}`,
          appointment: {
            apartmentType: dayOption.apartmentType,
            date: date,
            time: time,
            type: dayOption.appointmentType
          },
          expireAt: parseInt((Date.now() / 1000) + (86400 * (daysOut+1)) )  // Expire "appointment" day off automatically (can be removed keeps data clean)          
        })
      });

    }));

    console.info("appointments ==> \n" + JSON.stringify(appointments, null, 2));

    await Promise.all(appointments.map(async (appointment) => {
              
      await saveAppointment(appointment);

    }));     

    return true;

  } catch (error) {
        
    console.log("Error failed create appointments => ", error);
    
    return { statusCode: 500, body: 'Failed to complete: ' + JSON.stringify(error) };

  }    

};

appointments.deleteAll();
refreshApartments();


================================================
FILE: data/use-cases/apartment-search/dtmf.mjs
================================================
/**
 * dtmf.mjs
 * 
 * Manage the tools available for this use case here.
 */

export const dtmf = 
{
    "1": {"replyWithText":true, "replyText":"Let me get the available apartments.", "replyWithFunction":true, "replyFunction":"ListAvailableApartmentsFunction"},
    "2": {"replyWithText":true, "replyText":"I'll check on your appointments", "replyWithFunction":true, "replyFunction":"CheckExistingAppointmentsFunction"},
    "3": {"replyWithText":true, "replyText":"You pressed 3.", "replyWithFunction":false, "replyFunction":""},
    "4": {"replyWithText":true, "replyText":"You pressed 4.", "replyWithFunction":false, "replyFunction":""},
    "5": {"replyWithText":true, "replyText":"You pressed 5.", "replyWithFunction":false, "replyFunction":""},
    "6": {"replyWithText":true, "replyText":"You pressed 6.", "replyWithFunction":false, "replyFunction":""},
    "7": {"replyWithText":true, "replyText":"You pressed 7.", "replyWithFunction":false, "replyFunction":""},
    "8": {"replyWithText":true, "replyText":"You pressed 8.", "replyWithFunction":false, "replyFunction":""},
    "9": {"replyWithText":true, "replyText":"You pressed 9.", "replyWithFunction":false, "replyFunction":""},
    "0": {"replyWithText":true, "replyText":"You pressed 0.", "replyWithFunction":false, "replyFunction":""}
};


================================================
FILE: data/use-cases/apartment-search/prompt.mjs
================================================
/**
 * prompt.mjs
 * 
 * Manage the prompt for this use case here.
 */

export const prompt =   `## Objective
You are a voice AI agent assisting users with apartment leasing inquiries. Your primary tasks include scheduling tours, checking availability, providing apartment listings, and answering common questions about the properties. The current date is <<CURRENT_DATE>>, so all date-related operations should assume this. Since this is a voice application, all responses should be in plain text. Do not use markdown or any additional formatting.

<<USER_CONTEXT>>

## Guidelines
Voice AI Priority: This is a Voice AI system. Responses must be concise, direct, and conversational. Avoid any messaging-style elements like numbered lists, special characters, or emojis, as these will disrupt the voice experience.
Critical Instruction: Ensure all responses are optimized for voice interaction, focusing on brevity and clarity. Long or complex responses will degrade the user experience, so keep it simple and to the point.
Avoid repetition: Rephrase information if needed but avoid repeating exact phrases.
Be conversational: Use friendly, everyday language as if you are speaking to a friend.
Use emotions: Engage users by incorporating tone, humor, or empathy into your responses.
Always Validate: When a user makes a claim about apartment details (e.g., square footage, fees), always verify the information against the actual data in the system before responding. Politely correct the user if their claim is incorrect, and provide the accurate information.
DTMF Capabilities: Inform users that they can press '1' to list available apartments or '2' to check all currently scheduled appointments. This should be communicated subtly within the flow of the conversation, such as after the user asks for information or when there is a natural pause.
Avoid Assumptions: Difficult or sensitive questions that cannot be confidently answered authoritatively should result in a handoff to a live agent for further assistance.
Use Tools Frequently: Avoid implying that you will verify, research, or check something unless you are confident that a tool call will be triggered to perform that action. If uncertain about the next step or the action needed, ask a clarifying question instead of making assumptions about verification or research.

## Context
Parkview Apartments is located in Missoula, Montana. All inquiries, listings, and availability pertain to this location. Ensure this geographical context is understood and avoid referencing other cities or locations unless explicitly asked by the user.

## Function Call Guidelines
Order of Operations:
  - Always check availability before scheduling a tour.
  - Ensure all required information is collected before proceeding with a function call.

### Schedule Tour:
  - This function should only run as a single tool call, never with other tools
  - This function can only be called after confirming availability, but it should NEVER be called when the user asks for or confirms they'd like an SMS Confirmation. 
  - Required data includes date, time, tour type (in-person or self-guided), and apartment type.
  - If any required details are missing, prompt the user to provide them.

### Check Availability:
  - This function requires date, tour type, and apartment type.
  - If any of these details are missing, ask the user for them before proceeding.
  - If the user insists to hear availability, use the 'listAvailableApartments' function.
  - If the requested time slot is unavailable, suggest alternatives and confirm with the user.

### List Available Apartments: 
  - Trigger this function if the user asks for a list of available apartments or does not want to provide specific criteria.
  - Also use this function when the user inquires about general availability without specifying detailed criteria.
  - If criteria like move-in date, budget, or apartment layout are provided, filter results accordingly.
  - Provide concise, brief, summarized responses.

### Check Existing Appointments: 
  - Trigger this function if the user asks for details about their current appointments
  - Provide concise, brief, summarized responses.

### Common Inquiries:
  - Use this function to handle questions related to pet policy, fees, parking, specials, location, address, and other property details.
  - For any location or address inquiries, the system should always call the 'commonInquiries' function using the 'location' field.
  - If the user provides an apartment type, retrieve the specific address associated with that type from the database.
  - If no apartment type is specified, provide general location details.

### Live Agent Handoff:
  - Trigger the 'liveAgentHandoff' tool call if the user requests to speak to a live agent, mentions legal or liability topics, or any other sensitive subject where the AI cannot provide a definitive answer.
  - Required data includes a reason code (\"legal\", \"liability\", \"financial\", or \"user-requested\") and a brief summary of the user query.
  - If any of these situations arise, automatically trigger the liveAgentHandoff tool call.

### SMS Confirmations: 
  - SMS confirmations should NEVER be coupled with function calls to 'scheduleTour'.
  - Only offer to send an SMS confirmation if the user has successfully scheduled a tour, and the user agrees to receive one. 
  - If the user agrees, trigger the tool call 'SendSms' with the appointment details and the user's phone number, but do not trigger another 'scheduleTour' function call.
  - Do not ask for the user's phone number if you've already been referencing them by name during the conversation. Assume the phone number is already available to the function.

## Important Notes
- Always ensure the user's input is fully understood before making any function calls.
- If required details are missing, prompt the user to provide them before proceeding.

Remember that all replies should be returned in plain text. Do not return markdown!"`;


================================================
FILE: data/use-cases/apartment-search/properties.mjs
================================================
/**
 * properties.mjs
 * 
 * Manage the core properties for this use case here.
 */

export const properties = {
    "name": "apartment-search",
    "title": "Apartment Search",    
    "description": "A property leasing use case where a user can schedule tours and inquire about available apartments.",
     "role": "system",      
};   


================================================
FILE: data/use-cases/apartment-search/tools.mjs
================================================
/**
 * tools.mjs
 * 
 * Manage the tools available for this use case here.
 */

export const tools = 
[
    {
        type: "function",
        function: {
          name: "LiveAgentHandoffTool",
          description:
            "Initiates a handoff to a live agent based on user request or sensitive topics.",
          parameters: {
            type: "object",
            properties: {
              reason: {
                type: "string",
                description:
                  "The reason for the handoff, such as user request, legal issue, financial matter, or other sensitive topics.",
              },
              context: {
                type: "string",
                description:
                  "Any relevant conversation context or details leading to the handoff.",
              },
            },
            required: ["reason"],
          },
        },
      },
      {
        type: "function",
        function: {
          name: "SendSms",
          description:
            "Sends an SMS confirmation for a scheduled tour to the user.",
          parameters: {
            type: "object",
            properties: {
              appointmentDetails: {
                type: "object",
                properties: {
                  to_phone: {
                    type: "string",            
                    description: "The E.164 formatted phone number to receive the SMS.",
                  },                  
                  date: {
                    type: "string",
                    description: "The date of the scheduled tour (YYYY-MM-DD).",
                  },
                  time: {
                    type: "string",
                    description:
                      "The time of the scheduled tour (e.g., '10:00 AM').",
                  },
                  type: {
                    type: "string",
                    enum: ["in-person", "self-guided"],
                    description:
                      "The type of tour (either in-person or self-guided).",
                  },
                  apartmentType: {
                    type: "string",
                    enum: ["studio", "one-bedroom", "two-bedroom", "three-bedroom"],
                    description: "The type of apartment for the tour.",
                  },
                },
                required: ["to_phone", "date", "time", "type", "apartmentType"],
              }              
            },
            required: ["appointmentDetails"],
          },
        },
      },
      {
        type: "function",
        function: {
          name: "ScheduleTourTool",
          description: "Schedules a tour for the user at the apartment complex.",
          parameters: {
            type: "object",
            properties: {
              date: {
                type: "string",
                description:
                  "The date the user wants to schedule the tour for (YYYY-MM-DD).",
              },
              time: {
                type: "string",
                description:
                  'The time the user wants to schedule the tour for (e.g., "10:00 AM").',
              },
              type: {
                type: "string",
                enum: ["in-person", "self-guided"],
                description: "The type of tour, either in-person or self-guided.",
              },
              apartmentType: {
                type: "string",
                enum: ["studio", "one-bedroom", "two-bedroom", "three-bedroom"],
                description:
                  "The layout of the apartment the user is interested in.",
              },
            },
            required: ["date", "time", "type", "apartmentType"],
          },
        },
      },
      {
        type: "function",
        function: {
          name: "CheckAvailabilityTool",
          description:
            "Checks the availability of tour slots based on the user's preferences.",
          parameters: {
            type: "object",
            properties: {
              date: {
                type: "string",
                description:
                  "The date the user wants to check for tour availability (YYYY-MM-DD).",
              },
              time: {
                type: "string",
                description:
                  'The time the user wants to check for availability (e.g., "10:00 AM").',
              },
              type: {
                type: "string",
                enum: ["in-person", "self-guided"],
                description: "The type of tour, either in-person or self-guided.",
              },
              apartmentType: {
                type: "string",
                enum: ["studio", "one-bedroom", "two-bedroom", "three-bedroom"],
                description:
                  "The layout of the apartment the user is interested in.",
              },
            },
            required: ["date", "type", "apartmentType"],
          },
        },
      },
      {
        type: "function",
        function: {
          name: "ListAvailableApartmentsTool",
          description:
            "Lists available apartments based on optional user criteria.",
          parameters: {
            type: "object",
            properties: {
              date: {
                type: "string",
                description:
                  "The move-in date the user prefers (optional, YYYY-MM-DD).",
              },
              budget: {
                type: "integer",
                description:
                  "The budget the user has for rent per month (optional).",
              },
              apartmentType: {
                type: "string",
                enum: ["studio", "one-bedroom", "two-bedroom", "three-bedroom"],
                description:
                  "The layout of the apartment the user is interested in (optional).",
              },
            },
            required: [],
          },
        },
      },
      {
        type: "function",
        function: {
          name: "CheckExistingAppointmentsTool",
          description: "Retrieves the list of appointments already booked.",
          parameters: {
            type: "object",
            properties: {},
            required: [],
          },
        },
      },
      {
        type: "function",
        function: {
          name: "CommonInquiriesTool",
          description:
            "Handles common inquiries such as pet policy, fees, and other complex details, with the option to specify the apartment type.",
          parameters: {
            type: "object",
            properties: {
              inquiryType: {
                type: "string",
                enum: [
                  "pet policy",
                  "fees",
                  "parking",
                  "specials",
                  "income requirements",
                  "utilities",
                ],
                description:
                  "The type of inquiry the user wants information about.",
              },
              apartmentType: {
                type: "string",
                enum: ["studio", "one-bedroom", "two-bedroom", "three-bedroom"],
                description:
                  "The apartment type for which the inquiry is being made (optional).",
              },
            },
            required: ["inquiryType"],
          },
        },
      },
];


================================================
FILE: data/use-cases/restaurant-ordering/conversationrelay.mjs
================================================
/**
 * conversationrelay.mjs
 * 
 * Manage the core properties for this use case here.
 */

export const conversationrelay = {
    "dtmfDetection": true,
    "interruptible": true,
    "transcriptionProvider": "Deepgram",
    "ttsProvider": "Google",
    "voice": "en-US-Neural2-F",   
    "welcomeGreetingInterruptible": true, 
    "welcomeGreeting": "Thanks for calling Twilio Dough Boy Pizza! How can I help you?"
};   


================================================
FILE: data/use-cases/restaurant-ordering/dtmf.mjs
================================================
/**
 * dtmf.mjs
 * 
 * Manage the tools available for this use case here.
 */

export const dtmf = 
{
    "0": {
        "replyWithText": true,
        "replyText": "You pressed 0.",
        "replyWithFunction": false,
        "replyFunction": ""
    },
    "1": {
        "replyWithText": true,
        "replyText": "Let me get the available apartments.",
        "replyWithFunction": true,
        "replyFunction": "ListAvailableApartmentsFunction"
    },
    "2": {
        "replyWithText": true,
        "replyText": "I'll check on your appointments",
        "replyWithFunction": true,
        "replyFunction": "CheckExistingAppointmentsFunction"
    },
    "3": {
        "replyWithText": true,
        "replyText": "You pressed 3.",
        "replyWithFunction": false,
        "replyFunction": ""
    },
    "4": {
        "replyWithText": true,
        "replyText": "You pressed 4.",
        "replyWithFunction": false,
        "replyFunction": ""
    },
    "5": {
        "replyWithText": true,
        "replyText": "You pressed 5.",
        "replyWithFunction": false,
        "replyFunction": ""
    },
    "6": {
        "replyWithText": true,
        "replyText": "You pressed 6.",
        "replyWithFunction": false,
        "replyFunction": ""
    },
    "7": {
        "replyWithText": true,
        "replyText": "You pressed 7.",
        "replyWithFunction": false,
        "replyFunction": ""
    },
    "8": {
        "replyWithText": true,
        "replyText": "You pressed 8.",
        "replyWithFunction": false,
        "replyFunction": ""
    },
    "9": {
        "replyWithText": true,
        "replyText": "You pressed 9.",
        "replyWithFunction": false,
        "replyFunction": ""
    }
};


================================================
FILE: data/use-cases/restaurant-ordering/prompt.mjs
================================================
/**
 * prompt.mjs
 * 
 * Manage the prompt for this use case here.
 */

export const prompt =   `## Objective
You are a voice AI agent for the restaurant \"Twilio Dough Boy Pizza\". Your primary task is to take new orders for this restaurant. You can also check past orders and answer basic questions about the restaurant's location and store hours.  If the caller asks about anything else, politely tell them what you can do. 

## Guidelines
Voice AI Priority: This is a Voice AI system. Responses must be concise, direct, and conversational. Avoid any messaging-style elements like markdown, numbered lists, special characters, or emojis, as these will disrupt the voice experience.
Critical Instruction: Ensure all responses are optimized for voice interaction, focusing on brevity and clarity. Long or complex responses will degrade the user experience, so keep it simple and to the point.
Avoid repetition: Rephrase information if needed but avoid repeating exact phrases.
Be conversational: Use friendly, everyday language as if you are speaking to a friend.
Use emotions: Engage users by incorporating tone, humor, or empathy into your responses.
Always Validate: Be sure you understand each item in the order. Politely validate item details if you are unsure.

The restaurant's address is 101 Spear Street, San Francisco, CA, 94105. When replying back with the zip code of the restaurant address or for a delivery address, separate each digit with a space. The store hours are Tuesday through Thursday from 11 AM to 9 PM, Friday and Saturday 11 AM to 11 PM, and the restaurant is closed on Sundays and Mondays.

The current date and time is <<CURRENT_DATE>>. Use this date and time for scheduling orders and for store hours.

<<USER_CONTEXT>>

If this is an order, first ask if this order is for pickup or delivery.  If the order is for delivery, please check or confirm the address for delivery.

Callers can only order items from the menu. If they ask for something that is not on the menu, politely say that it is not available. Ask for items for their current order one at a time. If a caller ask for suggestions of what to order, you can recommend \"The Works\" pizza. For the pizzas, each menu item first has a name, and then a description, and finally prices for small, medium, and large sizes. Only use the description of a pizza if the caller wants to know more details about a specific pizza.

When a caller orders a pizza, ask for the size and if they want any additional toppings. Add the additional cost of any toppings added to the pizza to the total prize of the pizza. 

After a caller has confirmed an item for their order, ask them if they want to add anything else to their order. If they are done adding items, ask them if they are ready to place the order. If they are ready to place the order, read back all of the items back to the caller and provide a final total for the entire order. Only read the entire order back to them once. If they have changes, make changes to to the order. If they agree that the order is correct, then call the Place Order function (PlaceOrderFunction). Only call the Place Order Function once.

After call the Place Order Function, tell the caller you will check on the timing of their order and call either the CheckRestaurantDeliveryTime function or the CheckRestaurantPickUpTime function depending on the order type. Let the caller know when their order will be ready for pick up or delivery before proceeding. 

Ask the caller if they would like to receive a text message (SMS) with their order details. If they agree, call the SendSms function with the order details. If they want an email, ask for their email address and then call the SendEmail function with the order details.

End the call by thanking the caller.

## menu

# Starters:
- Mozzarella Sticks -- $7.75
- Onion Rings -- $7.75
- Popcorn Shrimp -- $9.95
- Jalapeno Poppers -- $8.50

# Salads
- Caesar Salad -- $9.95
- Mixed Greens Salad -- $10.95
- Cobb Salad -- $12.95

# Pizzas
- Cheese Cheese, \"Classic cheese with zesty red sauce\" -- $10.95, $13.95, $16.95
- Classic Pepperoni, \"Classic cheese and pepperoni pizza\" -- $12.95, $15.95, $19.95
- Hawaiian, \"Ham and pineapple\" -- $12.95, $15.95, $19.95
- The Works, \"Sausage, meatball, pepperoni, mushroom, onion, tomatoes, and peppers\" -- $15.95, $18.95, $23.95

# Toppings for Pizzas
- Pepperoni - $2.99
- Mushroom - $1.99
- Extra cheese - $1.99
- Sausage - $2.99
- Onion - $1.99
- Black olives - $1.99
- Green pepper - $1.99
- Fresh garlic - $1.99
- Fresh basil - $1.99
- tomato - $1.99

# Calzones
- Cheese Calzone -- $11.75
- Pepperoni Calzone -- $15.75
- Veggie Stromboli -- $13.75
- Ham -- $15.75

## Function Call Guidelines
Order of Operations:
  - Always check availability before scheduling a tour.
  - Ensure all required information is collected before proceeding with a function call.

### Place Order:
  - This function is called \"PlaceOrder\"
  - This function should only run as a single tool call, never with other tools
  - This function should be called after you have confirmed that the user is ready to complete the order.
  - This function has the parameter \"current_order\" which has an array of items. Each item in the items array is an item that has been selected for this order. 
  - The line_item property should be the title from the menu. 
  - The line_amount property is the cost for the item. 
  - The additonal_details property is optional and should be used for additional toppings added to pizzas or for any notes that caller wants to add about the specific item on the order. For example, if the caller wants salad dressing on the side for a salad.
  -- If the order_type is \"delivery\" then include the address provided by the caller in the delivery_address property. 
  -- order_total is sum total of all of the order items. 

### Check Delivery Time:
  - This function is called \"CheckRestaurantDeliveryTime\"
  - This function checks when the order will be delivered to the customer's address.
  - This function should only run as a single tool call, never with other tools
  - This function should be called after the Place Order Function has been completed for delvery orders.

### Check Pick Up Time:
  - This function is called \"CheckRestaurantPickUpTime\"
  - This function checks when the order will be ready to be picked up.
  - This function should only run as a single tool call, never with other tools
  - This function should be called after the Place Order Function has been completed for pickup orders.

### Send SMS Message: 
  - This function's name is \"SendSms\"
  - SMS Messages can be sent after an order has been accepted using the Place Order Function, or can be sent if a user wants the restaurant location to be sent to them.
  - If the user agrees to receive a text message (SMS), trigger the tool call 'SendSms' with the order details.
  - If you do not have the user's phone number, then ask for their phone number and format it using E.164 format.

### Send Email Message: 
  - This function's name is \"SendEmail\"
  - An email can be sent ONLY if you have their email address. You can ask for their email address.
  - An Email can be sent after an order has been completed.  
  - If the user confirms that they want to receive an email, trigger the tool call 'SendEmail'

## Important Notes
- Always ensure the user's input is fully understood before making any function calls.
- If required details are missing, prompt the user to provide them before proceeding.

Remember that all replies should be returned in plain text. Do not return markdown!`;


================================================
FILE: data/use-cases/restaurant-ordering/properties.mjs
================================================
/**
 * properties.mjs
 * 
 * Manage the core properties for this use case here.
 */

export const properties = {
    "name": "restaurant-ordering",
    "title": "Restaurant Ordering",    
    "description": "Demonstrate how a customer can call into a restaurant and place an order", 
     "role": "system"     
};   


================================================
FILE: data/use-cases/restaurant-ordering/tools.mjs
================================================
/**
 * tools.mjs
 * 
 * Manage the tools available for this use case here.
 */

export const tools = 
[
  {
    type: "function",
    function: {
      name: "PlaceOrder",
      description:
        "When a caller has finished adding items to an order, use this tool to save and place the order.",
      parameters: {
        type: "object",
        properties: {
          current_order: {
            type: "array",
            description: "The restaurant order containing all of the items the user wants in this order.",
            items: {              
              type: "object",
              properties: {
                "line_item": {
                  type: "string",
                  description: "The menu title of the item in the order plus any additions like toppings."
                },
                "additonal_details": {
                  type: "string",
                  description: "Additional toppings or any details about this menu item."
                },                
                "line_amount": {
                  type: "number",
                  description: "The amount of this item in the order."
                }                                
              },
              required: ["line_item", "line_amount"],
            }
          },
          order_type: {
            type: "string",
            enum: ["pickup", "delivery"],
            description: "The type of order.",
          },
          order_total: {
            type: "number",
            description: "The sum amount of all of order items."
          },  
          delivery_address: {
            type: "string",
            description: "Street address, city, state and zip code for the delivery."
          },            
        },
        required: ["order_type", "order_total"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "CheckRestaurantPickUpTime",
      description:
        "This function checks to see when the order will be ready for pickup.",
      parameters: {
        type: "object",
        properties: {
          order_type: {
            type: "string",
            enum: ["pickup", "delivery"],
            description: "The type of order.",
          }          
        },
        required: ["order_type"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "CheckRestaurantDeliveryTime",
      description:
        "This function checks to see when the order will be delivered.",
      parameters: {
        type: "object",
        properties: {
          order_type: {
            type: "string",
            enum: ["pickup", "delivery"],
            description: "The type of order.",
          }          
        },
        required: ["order_type"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "SendSms",
      description:
        "Sends an SMS message if requested by the user for the order confirmation or for restaurant hours or location.",
      parameters: {
        type: "object",
        properties: {
          to_phone: {
            type: "string",            
            description: "The E.164 formatted phone number to receive the SMS.",
          },
          message_type: {
            type: "string",
            enum: ["order confirmation", "hours", "location"],
            description: "The type of message to send.",
          },              
          restaurant_hours: {
            type: "string",
            description: "The hours of operation for the restaurant.",
          },
          restaurant_location: {
            type: "string",
            description: "The location of the restaurant.",
          },              
        },
        required: ["to_phone", "message_type"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "SendEmail",
      description:
        "Sends an Email if requested by the user for the order confirmation.",
      parameters: {
        type: "object",
        properties: {
          order_type: {
            type: "string",
            enum: ["pickup", "delivery"],
            description: "The type of order.",
          },          
          message_type: {
            type: "string",
            enum: ["order confirmation"],
            description: "The type of email to send.",
          },          
          to_email: {
            type: "string",            
            description: "The email address confirmed by the caller.",
          }                      
        },
        required: ["to_email"],
      },
    },
  },        

];


================================================
FILE: data/use-cases/rhyming-parrot/conversationrelay.mjs
================================================
/**
 * conversationrelay.mjs
 * 
 * Manage the core properties for this use case here.
 */

export const conversationrelay = {
    "dtmfDetection": true,
    "interruptible": true,
    "transcriptionProvider": "Deepgram",
    "ttsProvider": "ElevenLabs",
    "voice": "tnSpp4vdxKPjI9w0GnoV",
    "welcomeGreetingInterruptible": true,
    "welcomeGreeting": "Hello, say something interesting."
};   


================================================
FILE: data/use-cases/rhyming-parrot/dtmf.mjs
================================================
/**
 * dtmf.mjs
 * 
 * Manage the tools available for this use case here.
 */

export const dtmf = 
{
    "1": {"replyWithText":true, "replyText":"You pressed 1.", "replyWithFunction":true, "replyFunction":"ListAvailableApartmentsFunction"},
    "2": {"replyWithText":true, "replyText":"You pressed 2.", "replyWithFunction":true, "replyFunction":"CheckExistingAppointmentsFunction"},
    "3": {"replyWithText":true, "replyText":"You pressed 3.", "replyWithFunction":false, "replyFunction":""},
    "4": {"replyWithText":true, "replyText":"You pressed 4.", "replyWithFunction":false, "replyFunction":""},
    "5": {"replyWithText":true, "replyText":"You pressed 5.", "replyWithFunction":false, "replyFunction":""},
    "6": {"replyWithText":true, "replyText":"You pressed 6.", "replyWithFunction":false, "replyFunction":""},
    "7": {"replyWithText":true, "replyText":"You pressed 7.", "replyWithFunction":false, "replyFunction":""},
    "8": {"replyWithText":true, "replyText":"You pressed 8.", "replyWithFunction":false, "replyFunction":""},
    "9": {"replyWithText":true, "replyText":"You pressed 9.", "replyWithFunction":false, "replyFunction":""},
    "0": {"replyWithText":true, "replyText":"You pressed 0.", "replyWithFunction":false, "replyFunction":""}
};


================================================
FILE: data/use-cases/rhyming-parrot/prompt.mjs
================================================
/**
 * prompt.mjs
 * 
 * Manage the prompt for this use case here.
 */

export const prompt =   
`You are an AI voice agent who can ONLY provide a short retort to anything the users says but it MOST RHYME!`;


================================================
FILE: data/use-cases/rhyming-parrot/properties.mjs
================================================
/**
 * properties.mjs
 * 
 * Manage the core properties for this use case here.
 */

export const properties = {
    "name": "rhyming-parrot",
    "title": "Rhyming Parrot Agent",
    "description": "Reply back to anything said with a rhyme!",
     "role": "system",      
};   


================================================
FILE: data/use-cases/rhyming-parrot/tools.mjs
================================================
/**
 * tools.mjs
 * 
 * Manage the tools available for this use case here.
 */

export const tools = [];


================================================
FILE: data/use-cases/tool-calling-example/conversationrelay.mjs
================================================
/**
 * conversationrelay.mjs
 * 
 * Manage the core properties for this use case here.
 */

export const conversationrelay = {
    "dtmfDetection": true,
    "interruptible": true,
    "transcriptionProvider": "Deepgram",
    "ttsProvider": "ElevenLabs",
    "voice": "tnSpp4vdxKPjI9w0GnoV",
    "welcomeGreetingInterruptible": true,
    "welcomeGreeting": "Hello, what tool would you like to run? If you are not sure what tools are available, ask me to list them."
};   


================================================
FILE: data/use-cases/tool-calling-example/dtmf.mjs
================================================
/**
 * dtmf.mjs
 * 
 * Manage the tools available for this use case here.
 */

export const dtmf = 
{
    "1": {"replyWithText":true, "replyText":"You pressed 1.", "replyWithFunction":true, "replyFunction":"ListAvailableApartmentsFunction"},
    "2": {"replyWithText":true, "replyText":"You pressed 2.", "replyWithFunction":true, "replyFunction":"CheckExistingAppointmentsFunction"},
    "3": {"replyWithText":true, "replyText":"You pressed 3.", "replyWithFunction":false, "replyFunction":""},
    "4": {"replyWithText":true, "replyText":"You pressed 4.", "replyWithFunction":false, "replyFunction":""},
    "5": {"replyWithText":true, "replyText":"You pressed 5.", "replyWithFunction":false, "replyFunction":""},
    "6": {"replyWithText":true, "replyText":"You pressed 6.", "replyWithFunction":false, "replyFunction":""},
    "7": {"replyWithText":true, "replyText":"You pressed 7.", "replyWithFunction":false, "replyFunction":""},
    "8": {"replyWithText":true, "replyText":"You pressed 8.", "replyWithFunction":false, "replyFunction":""},
    "9": {"replyWithText":true, "replyText":"You pressed 9.", "replyWithFunction":false, "replyFunction":""},
    "0": {"replyWithText":true, "replyText":"You pressed 0.", "replyWithFunction":false, "replyFunction":""}
};


================================================
FILE: data/use-cases/tool-calling-example/prompt.mjs
================================================
/**
 * prompt.mjs
 * 
 * Manage the prompt for this use case here.
 */

export const prompt =   
`You are an AI voice agent who makes tools calls.
If the user is not sure what tools are available, you can tell them.

Here are the tools you can call:
- \`GetJoke\`: Get a random joke.
- \`GetQuote\`: Get a random famous quote.
- \`SndSMS\`: Get a random quote or a joke sent to you via SMS.
- \`SndEmail\`: Get a random quote or a joke sent to you via email.
- \`GetZip\`: Return the city and state for a US postal Zip Code.`;


================================================
FILE: data/use-cases/tool-calling-example/properties.mjs
================================================
/**
 * properties.mjs
 * 
 * Manage the core properties for this use case here.
 */

export const properties = {
    "name": "tool-calling-example",
    "title": "Tool Calling Example",
    "description": "Shows tool calling from a voice AI application!",
     "role": "system",      
};   


================================================
FILE: data/use-cases/tool-calling-example/tools.mjs
================================================
/**
 * tools.mjs
 * 
 * Manage the tools available for this use case here.
 */

export const tools = [
  {
    type: "function",
    function: {
      name: "GetJoke",
      description:
        "This tool retrieves a joke from a joke api service.",
      parameters: {}
    },
  },
  {
    type: "function",
    function: {
      name: "GetQuote",
      description:
        "This tool retrieves a random quote.",
      parameters: {}
    },
  },
  {
    type: "function",
    function: {
      name: "SendSMS",
      description:
        "Sends a SMS message to the caller.",
      parameters: {
        type: "object",
        properties: {
          sms_type: {
            type: "string",
            enum: ["joke", "quote"],
            description: "What the caller wants to receive in the sms.",
          },                   
          to_phone: {
            type: "string",            
            description: "The E.164 formatted phone number to receive the SMS.",
          }                      
        },
        required: ["to_phone", "sms_type"],
      },
    },
  },
  {
    type: "function",
    function: {
      name: "SendEmail",
      description:
        "Sends an Email if requested by the user for the order confirmation.",
      parameters: {
        type: "object",
        properties: {
          email_type: {
            type: "string",
            enum: ["joke", "quote"],
            description: "What the caller wants to receive in the email.",
          },          
          to_email: {
            type: "string",            
            description: "The email address confirmed by the caller.",
          }                      
        },
        required: ["to_email", "email_type"],
      },
    },    
  }, 
  {
    type: "function",
    function: {
      name: "GetZip",
      description:
        "Gets the name of the city associated to a US Zip Code.",
      parameters: {
        type: "object",
        properties: {     
          zip: {
            type: "string",            
            description: "The zip code he user wants to look up.",
          }                      
        },
        required: ["zip"],
      },
    },    
  }   
];


================================================
FILE: data/use-cases/utilities/random-data-generator.mjs
================================================
// Object containing Arrays of random data
const randomData = {};
randomData.firstNames = ["Mary", "John", "Susan", "James", "Karen", "Michael", "Jennifer", "David", "Linda", "Richard", "Patricia", "Robert", "Barbara", "William", "Margaret", "Joseph", "Betty", "Charles", "Nancy", "Thomas", "Kimberly", "Daniel", "Dorothy", "Matthew", "Sarah", "George", "Deborah", "Donald", "Jessica", "Paul", "Emily", "Mark", "Sandra", "Edward", "Melissa", "Kenneth", "Laura", "Steven", "Donna", "Brian", "Carol", "Ronald", "Michelle", "Timothy", "Amanda", "Jason", "Helen", "Jeffrey", "Sharon", "Frank", "Betty", "Brian", "Patricia", "Harold", "Laura", "Jason", "Amy", "Gary", "Anna", "Robert", "Arthur", "Raymond", "Roger", "Jeremy", "Tina", "Philip", "Marie", "Larry", "Theresa", "Russell", "Tiffany", "Alan", "Brenda", "Philip", "Julie", "Eugene", "Christine", "Carl", "Miranda", "Samuel", "Victoria", "Walter", "Kristen", "Vincent", "Cynthia", "Stephen", "April", "Gregory", "Carolyn", "Harry", "Kathleen", "Bruce", "Bonnie", "Dennis", "Wendy", "Willie", "Sara", "Edward", "Monica", "Douglas", "Beth", "Ryan", "Tanya", "Martin", "Lori", "Wayne", "Alice", "Jose", "Erin", "Jesse", "Nichole", "Terry", "Katherine", "Louis", "Sherry", "Randy", "Ann", "Lawrence", "Angela", "Gerard", "Gloria", "Brandon", "Anita", "Adam", "Leah", "Micheal", "Jacqueline", "Philip", "Catherine", "Clarence", "Christina", "Frederick", "Tonya", "Albert", "Carla", "Christopher", "Stacy", "Dave", "Kendra", "Joshua", "Kristin", "Johnny", "Cassandra", "Jimmy", "Diane", "Harry", "Tara", "Isaac", "Joan", "Damian", "Shannon", "Evan", "Jamie", "Noah", "Lydia", "Mason", "Janet", "Alice", "Tammy", "Robin", "Jacqueline", "Parker", "Tracy", "Israel", "Regina", "Felix", "Candice", "Calvin", "Gina", "Leroy", "Caroline", "Dana", "Yvonne", "Chris", "Casey", "Juan", "Tracey", "Alvin", "Brianna", "Aaron", "Martha", "Alberto", "Alexandra", "Antonio", "Pamela", "Arthur", "Renee", "Bob", "Erika", "Carlos", "Charlotte", "Christian", "Stacey", "Clifford", "Heather", "Colin", "Melanie", "Dale", "Katie", "Gerard", "Kim", "Ian", "Ernest", "Kurtis", "Harriett", "Darrell", "Debbie", "Geoffrey", "Hannah", "Herbert", "Krystal", "Jerome", "Kristina", "Joel", "Leslie", "Julian", "Toni", "Leonard", "Valerie", "Rodney", "Vanessa", "Seth", "Margie", "Sylvester", "Myra", "Troy", "Marlene", "Vince", "Geneva", "Virgil", "Julia", "Waldo", "Janice", "Amos", "Grace", "Austin", "Mindy", "Brandon", "Vivian", "Bruno", "Cheryl", "Carl", "Felicia", "Christian", "Bernice", "Craig", "Jenna", "Al", "Karyn", "Charlie", "Kimberley", "Doug", "Kacey", "Eldon", "Kelley", "Emmanuel", "Bobbie", "Ezra", "Delores", "Ferdinand", "Celeste", "Hamilton", "Allyson", "Hugh", "Becky", "Jim", "Audra", "Kris", "Jo", "Lorenzo", "Consuelo", "Marshall", "Ashley", "Matt", "Alison", "Octavio", "Alyssa", "Reid", "Felecia", "Stacy", "Sheena", "Tristan", "Yvette", "Will", "Amber", "Blane", "Corrine", "Elliot", "Elvira", "Ivan", "Letha", "Kai", "Mitsy", "Quincy", "Selena", "Rolf", "Tabitha", "Tim", "Trina", "Uriah", "Zara", "Vito", "Agnes", "Yael", "Adele", "Barbie", "Benji", "Charity", "Deon", "Freda", "Eddie", "Hope", "Finn", "Jasmine", "Gordon", "Lenora", "Hugo", "Mari", "Ivor", "Mya", "Josef", "Neve", "Kaleb", "Rhoda", "Lenny", "Evette", "Manny", "Adeline", "Norbert", "Ella", "Oliver", "Kristen", "Otis", "Candy", "Pearce", "Ingrid", "Quentin", "Lynda", "Roger", "Rhea", "Sandy", "Tammie", "Tucker", "Nadia", "Ulrich", "Matilda", "Vaughn", "Ruby", "Warner", "Rosie", "Zachariah", "Pat", "Kane", "Marva" ];
randomData.lastNames = ["Wheeler", "Horton", "Garza", "McGee", "Waters", "Nunez", "Boyle", "McMahon", "Berg", "Rangel", "Donovan", "Mullen", "Fritz", "Escobar", "Pennington", "Kirby", "Becker", "Merrill", "Gentry", "Vance", "Banks", "Pace", "Strong", "Martin", "Stark", "Clements", "Barajas", "Wu", "Koch", "Patel", "Wang", "Solomon", "Kearney", "Washington", "Short", "Steele", "Frost", "Baron", "Cisneros", "Blackburn", "Conway", "Wall", "Valenzuela", "Marsden", "Nielsen", "Connor", "Trujillo", "Molina", "Finch", "Browning", "Cherry", "Bloom", "Garrett", "Singleton", "Laurent", "Pollard", "Cooley", "Rowland", "Kidwell", "Lozano", "Villalobos", "Cantu", "Baird", "Slater", "Leary", "Valentine", "Foote", "Dent", "Briggs", "McClure", "Rowe", "Ortega", "Parks", "Hess", "Salas", "Bass", "Vo", "McIntyre", "Solis", "Drake", "Cardenas", "Walters", "Cuevas", "Luna", "Giles", "Pace", "Kramer", "Garza", "Bird", "Sexton", "Bridges", "Hansen", "Cline", "Tyson", "Hahn", "Foley", "Brennan", "Britt", "Squires", "Britton", "Braun", "Crosby", "Savage", "Moyer", "Landry", "Anders", "Dobbins", "Bruno", "Marrero", "Hurst", "Salas", "Sheppard", "Hardin", "Maverick", "McGrath", "Sullivan", "Hendrix", "Glass", "Jewell", "Dunlap", "Webster", "Soriano", "English", "Pierce", "Reilly", "Ramsey", "Pacheco", "Wells", "Talley", "Carson", "Vaughan", "Clements", "Hayes", "Sims", "Ritter", "Sanders", "Puckett", "Peterson", "Lane", "Bush", "Quinn", "Rodriguez", "Hampton", "Medina", "Davis", "Figueroa", "Kirk", "York", "Holmes", "Carrillo", "Fernandez", "Villarreal", "Benson", "Lyn"];
randomData.addresses = [ { "address_line_1": "123 Center Street", "city": "New York", "state_province_region": "New York", "postal_code": "10001", "country": "United States" }, { "address_line_1": "321 Main Street", "city": "Los Angeles", "state_province_region": "California", "postal_code": "90001", "country": "United States" }, { "address_line_1": "456 West Avenue", "city": "Chicago", "state_province_region": "Illinois", "postal_code": "60601", "country": "United States" }, { "address_line_1": "568 Amber Drive", "city": "Houston", "state_province_region": "Texas", "postal_code": "77001", "country": "United States" }, { "address_line_1": "2308 Grand Boulevard", "city": "Phoenix", "state_province_region": "Arizona", "postal_code": "85001", "country": "United States" }, { "address_line_1": "7402 Pacific Ave", "city": "Philadelphia", "state_province_region": "Pennsylvania", "postal_code": "19147", "country": "United States" }, { "address_line_1": "9631 Grape St", "city": "San Antonio", "state_province_region": "Texas", "postal_code": "78247", "country": "United States" }, { "address_line_1": "4282 Fourth St", "city": "San Diego", "state_province_region": "California", "postal_code": "92101", "country": "United States" }, { "address_line_1": "3014 Sunset Blvd", "city": "Dallas", "state_province_region": "Texas", "postal_code": "75201", "country": "United States" }, { "address_line_1": "8754 Main Street", "city": "San Jose", "state_province_region": "California", "postal_code": "95126", "country": "United States" }, { "address_line_1": "14712 First Road", "city": "Austin", "state_province_region": "Texas", "postal_code": "73301", "country": "United States" }, { "address_line_1": "9856 Oak Street", "city": "Jacksonville", "state_province_region": "Florida", "postal_code": "32099", "country": "United States" }, { "address_line_1": "4567 Sunset Blvd", "city": "Fort Worth", "state_province_region": "Texas", "postal_code": "76006", "country": "United States" }, { "address_line_1": "4781 West Street", "city": "Columbus", "state_province_region": "Ohio", "postal_code": "43085", "country": "United States" }, { "address_line_1": "87564 Second Street", "city": "San Francisco", "state_province_region": "California", "postal_code": "94102", "country": "United States" }, { "address_line_1": "590 Maple Drive", "city": "Charlotte", "state_province_region": "North Carolina", "postal_code": "28202", "country": "United States" }, { "address_line_1": "42 Oak Street", "city": "San Diego", "state_province_region": "California", "postal_code": "92101", "country": "United States" }, { "address_line_1": "116B Elm Street", "city": "Seattle", "state_province_region": "Washington", "postal_code": "98101", "country": "United States" }, { "address_line_1": "88 High Street", "city": "Denver", "state_province_region": "Colorado", "postal_code": "80014", "country": "United States" }, { "address_line_1": "450 Cherry Hill Drive", "city": "Atlanta", "state_province_region": "Georgia", "postal_code": "30301", "country": "United States" }, { "address_line_1": "12 Main Street", "city": "Boston", "state_province_region": "Massachusetts", "postal_code": "02110", "country": "United States" }, { "address_line_1": "33 Oak Lane", "city": "Washington", "state_province_region": "District of Columbia", "postal_code": "20001", "country": "United States" }, { "address_line_1": "5 Apple Street", "city": "Nashville", "state_province_region": "Tennessee", "postal_code": "37201", "country": "United States" }, { "address_line_1": "741 Eastview Drive", "city": "Las Vegas", "state_province_region": "Nevada", "postal_code": "89101", "country": "United States" }, { "address_line_1": "4343 High Street", "city": "Portland", "state_province_region": "Oregon", "postal_code": "97201", "country": "United States" }, { "address_line_1": "678 Pine St.", "city": "Louisville", "state_province_region": "Kentucky", "postal_code": "40202", "country": "United States" }, { "address_line_1": "57 Ocean Drive", "city": "Miami", "state_province_region": "Florida", "postal_code": "33101", "country": "United States" }, { "address_line_1": "4422 Hillside Lane", "city": "Cleveland", "state_province_region": "Ohio", "postal_code": "44101", "country": "United States" }, { "address_line_1": "219 Olive Street", "city": "Tucson", "state_province_region": "Arizona", "postal_code": "85701", "country": "United States" }, { "address_line_1": "600 Green Avenue", "city": "Pittsburgh", "state_province_region": "Pennsylvania", "postal_code": "15219", "country": "United States" }, { "address_line_1": "763 5th Avenue North", "city": "Minneapolis", "state_province_region": "Minnesota", "postal_code": "55401", "country": "United States" }, { "address_line_1": "2 Redwood Avenue", "city": "Tampa", "state_province_region": "Florida", "postal_code": "33602", "country": "United States" }, { "address_line_1": "973 East 9th Street", "city": "Baltimore", "state_province_region": "Maryland", "postal_code": "21202", "country": "United States" }, { "address_line_1": "1055 Sea View Drive", "city": "Long Beach", "state_province_region": "California", "postal_code": "90802", "country": "United States" }, { "address_line_1": "86 Evergreen Parkway", "city": "Anaheim", "state_province_region": "California", "postal_code": "92801", "country": "United States" }, { "address_line_1": "72 Elm Street", "city": "Oakland", "state_province_region": "California", "postal_code": "94601", "country": "United States" }, { "address_line_1": "2033 Oak Lane", "city": "Kansas City", "state_province_region": "Missouri", "postal_code": "64101", "country": "United States" }, { "address_line_1": "1102 Lake View Drive", "city": "New Orleans", "state_province_region": "Louisiana", "postal_code": "70112", "country": "United States" }, { "address_line_1": "999 Calle De La Playa", "city": "San Juan", "state_province_region": "Puerto Rico", "postal_code": "00901", "country": "United States" }, { "address_line_1": "634 Jarvis Street", "city": "San Francisco", "state_province_region": "California", "postal_code": "94102", "country": "United States" }, { "address_line_1": "5002 Sunset Boulevard", "city": "Sacramento", "state_province_region": "California", "postal_code": "94203", "country": "United States" }, { "address_line_1": "3082 Stone Pine Lane", "city": "La Jolla", "state_province_region": "California", "postal_code": "92037", "country": "United States" }, { "address_line_1": "32 Victoria Street", "city": "Palo Alto", "state_province_region": "California", "postal_code": "94301", "country": "United States" }, { "address_line_1": "22 Park Lane", "city": "Seattle", "state_province_region": "Washington", "postal_code": "98101", "country": "United States" }, { "address_line_1": "815 Bay Street", "city": "San Mateo", "state_province_region": "California", "postal_code": "94401", "country": "United States" }, { "address_line_1": "9 Broad Street", "city": "Redwood City", "state_province_region": "California", "postal_code": "94062", "country": "United States" }, { "address_line_1": "6921 Eastview Street", "city": "Beverly Hills", "state_province_region": "California", "postal_code": "90210", "country": "United States" }, { "address_line_1": "1416 Mission Street", "city": "Santa Cruz", "state_province_region": "California", "postal_code": "95060", "country": "United States" }, { "address_line_1": "5875 Pine Street", "city": "Monterey", "state_province_region": "California", "postal_code": "93940", "country": "United States" }, { "address_line_1": "15 Front Street", "city": "Carmel", "state_province_region": "California", "postal_code": "93923", "country": "United States" }, { "address_line_1": "1576 Pacific Avenue", "city": "Santa Rosa", "state_province_region": "California", "postal_code": "95405", "country": "United States" }, { "address_line_1": "4987 Garden Street", "city": "Springfield", "state_province_region": "Illinois", "postal_code": "62701", "country": "United States" }, { "address_line_1": "603 High Street", "city": "Madison", "state_province_region": "Wisconsin", "postal_code": "53703", "country": "United States" }, { "address_line_1": "400 Baker Street", "city": "Reno", "state_province_region": "Nevada", "postal_code": "89501", "country": "United States" }, { "address_line_1": "8421 Central Avenue", "city": "Tucson", "state_province_region": "Arizona", "postal_code": "85701", "country": "United States" }, { "address_line_1": "1467 Gentle Street", "city": "Santa Monica", "state_province_region": "California", "postal_code": "90401", "country": "United States" }, { "address_line_1": "449 Emerald Street", "city": "Orlando", "state_province_region": "Florida", "postal_code": "32801", "country": "United States" }, { "address_line_1": "352 Gold Avenue", "city": "Raleigh", "state_province_region": "North Carolina", "postal_code": "27601", "country": "United States" }, { "address_line_1": "5200 Hawley Blvd", "city": "Albuquerque", "state_province_region": "New Mexico", "postal_code": "87001", "country": "United States" }, { "address_line_1": "1478 Sunny Lane", "city": "Cleveland", "state_province_region": "Ohio", "postal_code": "44101", "country": "United States" }, { "address_line_1": "801 Cherry Circle", "city": "Honolulu", "state_province_region": "Hawaii", "postal_code": "96801", "country": "United States" }, { "address_line_1": "1265 Miles Street", "city": "Omaha", "state_province_region": "Nebraska", "postal_code": "68007", "country": "United States" }, { "address_line_1": "252 South Bend Ave", "city": "St. Louis", "state_province_region": "Missouri", "postal_code": "63101", "country": "United States" }, { "address_line_1": "762 Westward Avenue", "city": "Newark", "state_province_region": "New Jersey", "postal_code": "07101", "country": "United States" }, { "address_line_1": "9655 East Street", "city": "Fargo", "state_province_region": "North Dakota", "postal_code": "58047", "country": "United States" }, { "address_line_1": "79 Magnolia Street", "city": "Boston", "state_province_region": "Massachusetts", "postal_code": "02110", "country": "United States" }, { "address_line_1": "630 Riverside Drive", "city": "Richmond", "state_province_region": "Virginia", "postal_code": "23219", "country": "United States" }, { "address_line_1": "6103 Bluebonnet Boulevard", "city": "Baton Rouge", "state_province_region": "Louisiana", "postal_code": "70801", "country": "United States" }, { "address_line_1": "3514 Redwood Drive", "city": "Madison", "state_province_region": "Wisconsin", "postal_code": "53701", "country": "United States" }, { "address_line_1": "2605 Lake Street", "city": "Hartford", "state_province_region": "Connecticut", "postal_code": "06103", "country": "United States" }, { "address_line_1": "75 Sullivan Street", "city": "Providence", "state_province_region": "Rhode Island", "postal_code": "02903", "country": "United States" }, { "address_line_1": "4815 Broadway Street", "city": "Boise", "state_province_region": "Idaho", "postal_code": "83702", "country": "United States" }, { "address_line_1": "8759 Roy Street", "city": "Burlington", "state_province_region": "Vermont", "postal_code": "05401", "country": "United States" }, { "address_line_1": "705 Century Avenue", "city": "Pierre", "state_province_region": "South Dakota", "postal_code": "57501", "country": "United States" }, { "address_line_1": "911 East Capitol Avenue", "city": "Denver", "state_province_region": "Colorado", "postal_code": "80014", "country": "United States" } ];
randomData.languages = ["english", "spanish", "french", "german" ];
randomData.times = ["8:00 AM", "8:30 AM", "9:00 AM", "9:30 AM", "10:00 AM", "11:00 AM", "12:00 PM", "12:30 PM", "1:00 PM", "1:30 PM", "2:00 PM", "2:30 PM", "3:00 PM", "3:30 PM", "4:00 PM", "4:30 PM" ];

// Takes in a | delimited string, creates and array from it, selects random element
async function returnSelectedOption(options) {
  
  let array = options.split("|");
  return array[ ( Math.floor (Math.random() * array.length) ) ];

}

// Pulls a random element from one of the arrays
async function returnRandomData(dataType) {
  
  return randomData [ dataType ] [ ( Math.floor (Math.random() * randomData[ dataType ].length) ) ];

}

async function returnRandomNumber(digits) {
  
  let rn = ("" + Math.random()).substring(2, (parseInt(digits)+2) ); 
  return parseInt(rn);  

}

async function getFutureDate(futureDays, locales, options) {
  
  let f = (locales) ? locales : undefined;
  // en-CA "2012-12-19"
  // en-US "12/19/2012"
  let o = (options) ? options : {};

  let today = new Date();
  let futureDate = new Date(today.setDate(today.getDate() + futureDays));
  
  return futureDate.toLocaleDateString(f,o);  

}

async function getPastDate(pastDays, locales, options) {
  
  let f = (locales) ? locales : undefined;
  // en-CA "2012-12-19"
  // en-US "12/19/2012"
  let o = (options) ? options : {};

  let today = new Date();
  let pastDate = new Date(today.setDate(today.getDate() - pastDays));
  
  return pastDate.toLocaleDateString(f,o);  

}

async function getTimestamp() {
  
  let now = new Date();  
  
  return now.toUTCString();  

}

async function returnRandomDynamicTemplateData(t_data) {

  let r = null;

  switch (t_data.random) {
    case "firstNames":
      r = await returnRandomData("firstNames");      
      break;
    case "lastNames":
      r = await returnRandomData("lastNames");      
      break;
    case "addresses":
      // Returns an object!  
      r = await returnRandomData("addresses");      
      break;      
    case "times":
      // Returns an object!  
      r = await returnRandomData("times");      
      break;            
    case "random_number":
      r = await returnRandomNumber(t_data.digits);       
      break;  
    case "amount":
      let n = await returnRandomNumber(t_data.digits);       
      r = `$${n.toString()}.00`;
      break;        
    case "option":
      r = await returnSelectedOption(t_data.options);       
      break;       
    case "future_date":
      r = await getFutureDate(t_data.days, t_data?.locales, t_data?.options);       
      break;       
    case "past_date":
      r = await getPastDate(t_data.days, t_data?.locales, t_data?.options);       
      break;             
    case "timestamp":
      r = await getTimestamp();       
      break;      
    case "disabled":
      r = t_data.value;
      break;             
    default:
      r = "";  
      break;
  }

  return r;
}

export  { 
  
  returnRandomDynamicTemplateData, returnRandomData, getFutureDate, getPastDate, 
  returnRandomNumber, returnSelectedOption, getTimestamp

};


================================================
FILE: server/index.mjs
================================================
import express from "express";
import twimlRoutes from "./routes/twiml.js";
import clientAppRoutes from "./routes/client-app.js";
import clientDataRoutes from "./routes/client-data.js";
import clientTokenRoutes from "./routes/client-token.js";

import bodyParser from "body-parser";
import cors from "cors";
import path from "path";
import url from "url";
import { fileURLToPath } from "url";
import { WebSocketServer } from "ws";
import { defaultWebsocketHandler as websocketTwilioEventsHandler } from "./lib/default-websocket-handler.mjs";

// Initialize the Express app and websocket server

const app = express();
const port = 3000;
const wss = new WebSocketServer({ noServer: true });
const server = app.listen(port, () => {
  console.log(`App is ready.`);
  console.debug(`WS_URL => ${process.env.WS_URL}`);
  console.debug(`AI_PLATFORM => ${process.env.AI_PLATFORM}`);
});

// Needed to access the client application
const __filename = fileURLToPath(import.meta.url); // get the resolved path to the file
const __dirname = path.dirname(__filename); // get the name of the directory
app.use(express.static(path.join(__dirname, "../client/build"))); // Serve static files from the React app

app.use(cors()); // Enable CORS for all routes
app.use(express.json()); // for parsing application/json
app.use(bodyParser.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded

// REST routes
app.use("/client", clientAppRoutes); // Points to the client app in client/build
app.use("/client-data", clientDataRoutes); // CRUD routes for data used in the client
app.use("/client-token", clientTokenRoutes); // Routes for getting Twilio client tokens for voice and chat
app.use("/twiml", twimlRoutes); // TwiML App points here when the client calls (Twilio hits this endpoint)
app.get("/health", (req, res) => {
  res.send("Healthy");
}); // Health check endpoint for load balancers

// Handle WebSocket Connection Established by Twilio ConversationRelay
server.on("upgrade", (request, socket, head) => {
  wss.handleUpgrade(request, socket, head, (socket) => {
    // Get the Twilio callSid to use as session ID for the WebSocket connection
    const URLparams = url.parse(request.url, true).query;
    //console.log("URLparams => ", URLparams);
    if (URLparams.callSid) {
      request.callSid = URLparams.callSid;
      wss.emit("connection", socket, request, head);
    } else {
      console.error("No requestId found in the request URL");
      socket.terminate();
    }
  });
});

function heartbeat() {
  this.isAlive = true;
  console.log("Heartbeat received");
}

const interval = setInterval(function ping() {
  wss.clients.forEach(function each(ws) {
    if (ws.isAlive === false) return ws.terminate();
    ws.isAlive = false;
    ws.ping();
  });
}, 30000);

// Handler functions for post WS connection
wss.on("connection", (socket, request, head) => {
  // socket is the connect for the websocket for this request
  socket.isAlive = true;

  socket.callSid = request.callSid; // Store the callSid in the socket for later use

  // Message handler for Twilio incoming messages
  // THIS METHOD MUST NOT BE ASYNC - ONLY THE ONMESSAGE HANDLER CAN BE ASYNC

  // Session Key is the callSid passed in the URL and from Twilio
  const callSid = request.callSid;

  socket.on("message", async (message) => {
    // Parse the incoming message from Twilio
    const messageJSON = JSON.parse(message.toString());

    let toolCallCompletion = false; // False because tool call completion events do not come this way

    //console.info("EVENT\n" + JSON.stringify(messageJSON, null, 2));
    //console.info(`In onMessage handler: callSid: ${callSid}`);

    try {
      let clientSocket = null;

      if (callSid !== "browser-client") {
        //console.info("wss.clients\n" + JSON.stringify(wss.clients, null, 2));
        /*wss.clients.forEach(function each(client) {        
          if (client !== socket && client.readyState === WebSocketServer.OPEN) {
              console.info("client => \n" + JSON.stringify(client, null, 2)); 
            }
        });*/

        // clientSocket is the socket for the browser client and used to send
        // events back to the browser client such as transcription and speaking events and metrics.

        for (const client of wss.clients) {
          if (client.callSid === "browser-client") {
            clientSocket = client; // This is the browser client socket
            break;
          }
        }

      }

      // Primary handler for messages from Twilio ConversationRelay
      await websocketTwilioEventsHandler(
        callSid,
        socket,
        messageJSON,
        toolCallCompletion,
        clientSocket
      );
    } catch (error) {
      console.log("Message processing error => ", error);
    }
  });

  socket.on("error", (error) => {
    console.error("WebSocket error:", error);
  });

  socket.on("close", () => {
    console.log("Client disconnected");
    clearInterval(interval);
  });

  socket.on("ping", heartbeat);
});



================================================
FILE: server/package.json
================================================
{
    "name": "conversation-relay-bedrock-customer-service-live-voice",
    "version": "1.0.0",
    "description": "A simple websockets application with Amazon Bedrock or the OpenAI API and Twilio ConversationRelay, triggered by a WebRTC or voice call.",
    "type": "module",
    "main": "index.js",
    "scripts": {
        "start": "node index.mjs",
        "test": "jest --forceExit --ci --reporters=default --reporters=jest-junit",
        "lint": "eslint . --ext .js"
    },
    "jest-junit": {},
    "author": "Dan Bartlett, Charlie Avila, Ben Johnstone.",
    "license": "MIT",
    "dependencies": {
        "@aws-sdk/client-bedrock-runtime": "^3.778.0",        
        "@sendgrid/mail": "^8.1.5",
        "cors": "^2.8.5",
        "dotenv": "^16.5.0",
        "express": "^4.21.2",
        "file-system-db": "^2.1.0",
        "openai": "^4.100.0",
        "twilio": "^5.7.1",
        "ws": "^8.0.0"
    }
}



================================================
FILE: server/start-local-server.sh.sample
================================================
# TWILIO ENVIRONMENT VARIABLES
export TWILIO_TWIML_APP_SID=your-twiml-app-sid
export TWILIO_ACCOUNT_SID=your-twilio-account-sid
export TWILIO_API_KEY=your-twilio-api-key
export TWILIO_API_SECRET=your-twilio-api-key-secret

# NGROK ENVIRONMENT VARIABLES
export WS_DOMAIN_NAME=your-ngrok-subdomain.ngrok.app
export WS_URL=wss://your-ngrok-subdomain.ngrok.app/

# AI PLATFORM SELECTION (invokeOpenAI | invokeBedrock)
# YOU MUST SELECT ONE, OR ADD YOUR OWN!
export AI_PLATFORM=invokeOpenAI

# OPENAI ENVIRONMENT VARIABLES
# IF YOU ARE USING ANOTHER LLM PROVIDER JUST LEAVE THE VALUES BELOW
export OPENAI_API_KEY=your-openai-key
export OPENAI_LLM_MODEL=gpt-4o-mini

# AWS ENVIRONMENT VARIABLES
# IF YOU ARE USING ANOTHER LLM PROVIDER JUST LEAVE THE VALUES BELOW
export AWS_PROFILE=local-aws-profile
export AWS_MODEL_IDENTIFIER=amazon.nova-micro-v1:0
export AWS_REGION=your-aws-region

# TWILIO SEND MESSAGE ENVIRONMENT VARIABLES
# OPTIONAL IF YOU WANT TO SEND SMS MESSAGES FROM TOOL CALLS
# JUST LEAVE VALUES BELOW IF YOU DO NOT WANT TO USE MESSAGES
export TWILIO_MESSAGE_ACCOUNT_SID=ACxxxxxxxxxxxxxxxxxxxx
export TWILIO_MESSAGE_AUTH_TOKEN=4jkljxxxxxxxxxxxxxxxxxx
export TWILIO_MESSAGE_FROM_NUMBER=+15555551212

# TWILIO SENDGRID EMAILS ENVIRONMENT VARIABLES
# OPTIONAL IF YOU WANT TO SEND EMAILS MESSAGES FROM TOOL CALLS
# JUST LEAVE VALUES BELOW IF YOU DO NOT WANT TO USE EMAILS
export TWILIO_SENDGRID_API_KEY=SG.Yyxxxxxxxxxxxxxxxxxxxx
export TWILIO_SENDGRID_FROM=verifified-user@yoursendgrid.domain.com

# DEFAULT STACK
export STACK_USE_CASE=albertEinsteinUseCase

npm start


================================================
FILE: server/lib/database-helpers.mjs
================================================
import { FSDB } from "file-system-db"; 

/**
 * 
 * savePrompt
 * 
 * This helper function saves a prompt to the database. This
 * is the chat history for a session and the sort key is chronological
 * so that chats are automatically sorted by time.
 * 
 * This implement sets an TTL (expireAt) date to delete chats automatically.
 * The TTL would presumably be changed in production uses.
 * 
 */
export async function savePrompt(callSid, newChatMessage) {
    try {
        const sessionChats = new FSDB(`../data/sessions/${callSid}/chats.json`, false);

        newChatMessage.timestamp = Date.now();

        sessionChats.set(`chat::${Date.now().toString()}`, newChatMessage);

        return true;

    } catch (error) {
        
        console.error("Error saving prompt to database: ", error);
        throw error;

    }
};

/**
 * returnAllChats
 * 
 * Get all chats for a current session. Sort key is a timestamp
 * to chats are automatically returned in chronological order.
 */
export async function returnAllChats(callSid) {
    try { 

        const sessionChats = new FSDB(`../data/sessions/${callSid}/chats.json`, false);
        
        return sessionChats.getAll().map(chat => {                        
            return { ...chat.value };
        });

    } catch (error) {

        console.error("Error getting all chats: ", error);
        throw error;
        
    }   
}


================================================
FILE: server/lib/default-websocket-handler.mjs
================================================
// Code for this lambda broken into several modules 
import { prepareAndCallLLM } from './prepare-and-call-llm.mjs';
import { savePrompt } from './database-helpers.mjs';
import { formatLLMMessage } from './llm-formatting-helpers.mjs';

import { makeApartmentSearchToolCalls } from './tools/apartment-search/tools.mjs';
import { makeRestaurantOrderingToolCalls } from './tools/restaurant-ordering/tools.mjs';
import { makeToolCallingExampleToolCalls } from './tools/tool-calling-example/tools.mjs';

import { FSDB } from "file-system-db"; 

/**
 * getSessionDetails
 * 
 * Get the session details (prompt, tools, user context) from 
 * the database given the callSid which is the id generated by Twilio 
 * and used as the session ID. Session needed at each turn.
 */
const getSessionDetails = async (callSid) => {
    try {        
        
        const crSession = new FSDB(`../data/sessions/${callSid}/session.json`, false);
        const sessionDetails = crSession.get(callSid)

        if(!sessionDetails) {
            console.error("No session details found for callSid: ", callSid);
            return;
        }
        
        return sessionDetails;

    } catch (error) {
        
        console.error("Error getting call connection: ", error);
        throw error;

    }
};

/**
 * This function handles the incoming messages from the Twilio ConversationRelay server.
 * 
 * The body of the message is a JSON object that contains the type of event and other
 * information. The type of event can be "prompt", "dtmf", "setup", "end", or "error".
 * 
 * This function is called from the onMessage handler in the WebSocket server.
 */
export const defaultWebsocketHandler = async (callSid, socket, body, toolCallCompletion, clientSocket) => { 

    //console.info("defaultWebsocketHandler and body => ", body);

    let now = Date.now();
    let currentMessage = { ...body, "ts": now };

    try {


        if (body?.type === "info" && clientSocket !== null) {
            
            clientSocket.send(JSON.stringify(currentMessage));
        }        

        if (body?.type === "error") {
            console.error("Error event received from ConversationRelay server: ", body.description);
        }

        // Text prompts and dtmf events sent via WebSockets 
        // and tool call completion events follow the same steps and call the LLM
        if (body?.type === "prompt" || body?.type === "dtmf") {                        

            console.info("Received prompt or dtmf => ", currentMessage);

            const sessionDetails = await getSessionDetails(callSid);
            
            if (clientSocket !== null) {
                clientSocket.send(JSON.stringify(currentMessage));
            }

            const llmResult = await prepareAndCallLLM({                
                callSid: callSid, 
                sessionDetails: sessionDetails, // Object from database session details
                socket: socket, 
                body: body, 
                toolCallCompletion: toolCallCompletion,
                clientSocket: clientSocket
            });                

            console.info("llmResult\n" + JSON.stringify(llmResult, null, 2));

            // Format the llmResult into a chat message to persist to the database
            let newAssistantChatMessage = await formatLLMMessage("assistant",llmResult.content)            

            // If tool_calls are present, convert the tool call object to
            // an array to adhere to llm chat messaging format
            if (Object.keys(llmResult.tool_calls).length > 0 ) {
                // Format tool_calls object into an array
                newAssistantChatMessage.tool_calls = Object.values(llmResult.tool_calls);
            }
            
            console.info("newChatMessage before saving to database\n" + JSON.stringify(newAssistantChatMessage, null, 2));    

            // Save LLM result prompt to the database            
            await savePrompt(callSid, newAssistantChatMessage);            
            
            // If the LLM Results includes tool call(s), format the results 
            // and make the tool calls
            if (Object.keys(llmResult.tool_calls).length > 0 ) {
                
                // Send tool call(s) to handler function
                //let toolCallResult = await makeFunctionCalls(llmResult.tool_calls, callSid, sessionDetails);
                let toolCallResult;
                switch (sessionDetails.useCase) {
                    case "restaurant-ordering":
                        toolCallResult = await makeRestaurantOrderingToolCalls(llmResult.tool_calls, callSid, sessionDetails);
                        break;
                    case "apartment-search":
                        toolCallResult = await makeApartmentSearchToolCalls(llmResult.tool_calls, callSid, sessionDetails);
                        break;
                    case "tool-calling-example":
                        toolCallResult = await makeToolCallingExampleToolCalls(llmResult.tool_calls, callSid, sessionDetails);
                        break;                        
                    default:
                        console.error("No tool calls handler found for use case: ", sessionDetails.useCase);
                        break;
                }

                

                // Upon successfully running the tool calls...
                if (toolCallResult) {

                    toolCallCompletion = true;

                    // Tool Call(s) successfully completed so 
                    // call the LLM a second time.
                    await prepareAndCallLLM({
                        callSid: callSid, 
                        sessionDetails: sessionDetails, 
                        socket: socket, 
                        body: null, 
                        toolCallCompletion: toolCallCompletion,
                        clientSocket: clientSocket
                    }); 

                }
            }

        } else if (body?.type === "interrupt") {

            /**
             * "interrupt" event sent by the ConversationRelay server when the user speaks 
             * before the text-to-speech has completed.
             * 
             * {
             *  "type" : "interrupt",
             *  "utteranceUntilInterrupt": "Life is a complex set of",
             *  "durationUntilInterruptMs": "460"
             * }
             * 
             * This implementation does not track interruptions.
             * 
             */

            console.info("Received interrupt event: ", currentMessage);
            clientSocket.send(JSON.stringify(currentMessage));
     
        } else if (body?.type === "setup") {

            /**
             * "setup" event sent from ConversationRelay server as initial session message.
             * This event can be used for additional configuration for this call.
             * 
             * {
             *  "type": "setup",
             *  "sessionId": "",
             *  "callSid": "",
             *  "parentCallSid": null,
             *  "from": "+14085551212",
             *  "to": "+18881234567",
             *  "forwardedFrom": null,
             *  "callerName": null,
             *  "direction": "inbound",
             *  "callType": "PSTN",
             *  "callStatus": "IN-PROGRESS",
             *  "accountSid": "",
             *  "applicationSid": ""
             * }
             * 
             * This implementation does utilize the setup event.
             */
            
            console.info("Received setup event: ", currentMessage);            
            clientSocket.send(JSON.stringify(currentMessage));

            try {
                
                // Establish the connection in the DB and in the message handler functions...
                console.log("onConnectWebsocketHandler setup event called with callSid: ", callSid);
                //await onConnectWebsocketHandler(callSid);

            } catch (error) {
                
                console.error("Error in onConnectWebsocketHandler: ", error);

            }

        } else if (body?.type === "end") {

            /**
             * "end" event is the last message sent by the ConversationRelay server. This
             * message can be used for any "clean up" processing.
             * 
             * {
             *  "type" : "end",
             *  "handoffData": "{\"reasonCode\":\"live-agent-handoff\", \"reason\": \"The caller wants to talk to a real person\"}"
             * }
             * 
             * This implementation does not use the end event.
             */

            console.info("Received interrupt event: ", currentMessage);
            clientSocket.send(JSON.stringify(currentMessage));
            
        }
    } catch (error) {
        console.log("defaultWebsocketHandler generated an error => ", error);
        throw new Error(error); 
    }
};


================================================
FILE: server/lib/invoke-bedrock.mjs
================================================
/**
 * invoke-bedrock.mjs
 * 
 * This module formats the prompt, invokes bedrock, handles and 
 * formats the streamed response, and returns a results object.
 * 
 * https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/bedrock-runtime/command/ConverseStreamCommand/
 * https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/Package/-aws-sdk-client-bedrock-runtime/Interface/ConverseStreamCommandInput/
 * 
 */
import { BedrockRuntimeClient, ConverseStreamCommand } from "@aws-sdk/client-bedrock-runtime";
const bedrockClient = new BedrockRuntimeClient();

export async function invokeBedrock(promptObj) {

    try {
        //console.info("in [ invokeBedrock ] and promptObj ==> \n" + JSON.stringify(promptObj, null, 2));     

        // Use the Bedrock ConverseStreamCommand to call the LLM        

        let tools = (promptObj.sessionDetails.tools) ? JSON.parse(promptObj.sessionDetails.tools) : [];

        const bedrockInput = {            
            modelId: promptObj.sessionDetails.llmModel, // Set as env var or override in session details
            messages: promptObj.messages,
            system: promptObj.sessionDetails.systemPrompt,
            toolConfig: { tools: tools },
            inferenceConfig: {
                maxTokens: 1600,
                temperature: 0.3,
                topP: 1.0,
                stopSequences: []
            }
        };
        
        console.info("in [ invokeBedrock ] and bedrockInput ==> \n" + JSON.stringify(bedrockInput, null, 2));  

        // Instantiate the object that LLM returns.
        let returnObj = {};
        returnObj.role = "assistant";
        returnObj.content = [];    
        returnObj.tool_calls = {};    
        returnObj.last = true;
        returnObj.finish_reason = "";
                    
        // call Bedrock and wait for response...
        const bedrockCommand = new ConverseStreamCommand(bedrockInput);

        //console.info("in [ invokeBedrock ] and bedrockCommand ==> \n" + JSON.stringify(bedrockCommand, null, 2));  

        const bedrockResponse = await bedrockClient.send(bedrockCommand);

        //console.info("in [ invokeBedrock ] and bedrockResponse ==> \n" + JSON.stringify(bedrockResponse, null, 2));  
    
        const contentBlocks = []; // Array for llm responses (could be text or tool use)
        contentBlocks.push({ responseType: "", content: "" }); // There will be at least one content block

        //console.info("in [ invokeBedrock ] and instantiated contentBlocks ==> \n" + JSON.stringify(contentBlocks, null, 2));

        // Iterate over stream returned from Bedrock
        for await (const chunk of bedrockResponse.stream) {
            try {    
                //console.info("chunk => \n" + JSON.stringify(chunk, null, 2)); 
                
                if (chunk.contentBlockStart && chunk.contentBlockStart.contentBlockIndex !== 0) {
                    
                    //console.info("Adding additional contentBlock...");

                    contentBlocks.push({
                        responseType: "toolUse",
                        content: "",
                        toolUseName: chunk.contentBlockStart.start.toolUse.name,
                        toolUseId: chunk.contentBlockStart.start.toolUse.toolUseId
                    });            

                } else if (chunk.contentBlockDelta) {
                    
                    if (chunk.contentBlockDelta.delta?.text) {
                        
                        contentBlocks[chunk.contentBlockDelta.contentBlockIndex].responseType = "text";
                        contentBlocks[chunk.contentBlockDelta.contentBlockIndex].content += chunk.contentBlockDelta.delta.text || '';

                        // Send text (current chunk content) back to WebSocket & Twilio for TTS
                        // Text is streamed back immediately to minimize latency
                        //console.info("Sending text to WebSocket ==> ", JSON.stringify({type:"text", token:chunk.contentBlockDelta.delta.text, last:false}));
                        promptObj.socket.send(JSON.stringify({type:"text", token:chunk.contentBlockDelta.delta.text, last:false}));
                        //SEND TO CLIENT TOO!

                    } else if (chunk.contentBlockDelta.delta?.toolUse) {

                        // Parse the content to build tool call
                        contentBlocks[chunk.contentBlockDelta.contentBlockIndex].responseType = "toolUse";
                        contentBlocks[chunk.contentBlockDelta.contentBlockIndex].content += chunk.contentBlockDelta.delta.toolUse?.input;

                    }
                
                } else if (chunk.contentBlockStop) {
                    
                    if (contentBlocks[chunk.contentBlockStop.contentBlockIndex].responseType == "text") {

                        // Current text turn has ended
                        //console.info("Sending text to WebSocket ==> ");
                        promptObj.socket.send(Buffer.from(JSON.stringify({type:"text", token:"", last:true})));                 
                    }
                    
                } else if (chunk.messageStop) {            

                    returnObj.finish_reason = chunk.messageStop.stopReason;

                } else if (chunk.metadata) {
                    // Metadata
                    //console.log("metadata for this turn => ", chunk.metadata);
                }
            } catch (error) {
                console.error("Error processing chunk: ", error);
                throw new Error('Error processing chunk: ' + error.message);
            }
        }

        // Iterate over contentBlocks to complete returnObj
        contentBlocks.forEach((block) => {

            //console.info("in [ invokeBedrock ] and iterating on contentBlocks ==> \n" + JSON.stringify(block, null, 2));  

            if (block.responseType === "text") {

                returnObj.content.push( { "text": block.content } ); 

            } else if (block.responseType == "toolUse") {
                
                //console.error("toolUse block => ", JSON.stringify(block, null, 2));
                
                let toolUseId = (block.toolUseId) ? block.toolUseId : "yyyyzzzz"; 
                // Default value if not set (needed at time of writing to catch
                // edge cases where toolUseId is not set)

                let toolCall = {
                    toolUse: {
                        toolUseId: toolUseId,
                        name: block.toolUseName,
                        // ConverseStream toolUse input needs to be decoded
                        // and is left as a string and then parsed by the tool
                        input: JSON.parse(decodeURI(block.content))
                    }
                };

                // This is persisted to the conversation
                returnObj.content.push( toolCall ); 

                // This is used to make the tool call
                returnObj.tool_calls[block.toolUseId] = toolCall.toolUse;

            }

        });
        
        //console.info("In Handle Prompt about to return...\n" + JSON.stringify(returnObj, null, 2)); 

        return returnObj;

    } catch (error) {
        console.error("Error in invokeBedrock: ", error);
        if(error.name === 'ThrottlingException') {
            console.error("ThrottlingException: from Bedrock.");
            // In some instances, the Bedrock API may throttle requests.
            // Handle the error accordingly, e.g., retry after a delay
            promptObj.socket.send(Buffer.from(JSON.stringify({type:"text", token:"We are sorry but the Bedrock service is experiencing processing delays.", last:true})));                 
        } else {
            throw new Error('Error in invokeBedrock: ' + error.message);
        }
    }    
}   



================================================
FILE: server/lib/invoke-open-ai.mjs
================================================
/**
 * invoke-openai.mjs
 *
 * This module formats the prompt, calls the OpenAI LLM, handles and
 * formats the streamed response, and returns a results object.
 */
import OpenAI from "openai";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

export async function invokeOpenAI(promptObj) {
  //console.log("in [ invokeOpenAI ] and promptObj ==> \n" + JSON.stringify(promptObj, null, 2));

  // SET THE PROMPT TO OPENAI
  const prompt = {
    messages: promptObj.messages,
    model: promptObj.sessionDetails.llmModel, // Set as env var or override in session details
    stream: true,
  };

  let tool_choice = promptObj?.tool_choice ? promptObj?.tool_choice : "auto";
  // tool_choice can be string or object
  // string => none, auto, required
  // object => {"type": "function", "function": {"name": "my_function"}}

  // Provide the tools available for the LLM to call
  if (!promptObj.toolCallCompletion) {
    prompt.tools = JSON.parse(promptObj.sessionDetails.tools);
    prompt.tool_choice = tool_choice;
  }

  // Instantiate the object that LLM returns.
  let returnObj = {};
  returnObj.role = "assistant";
  returnObj.content = "";
  returnObj.tool_calls = {};
  returnObj.refusal = null;

  let currentToolCallId = null; // Needed to support multiple tool calls

  let i = 0; // Keep track of iterations if needed

  // call open AI and wait for response...
  const stream = await openai.chat.completions.create(prompt);

  // Iterate over stream
  for await (const chunk of stream) {
    i++;

    /**
     *
     * INTERRUPTION HANDLING
     *
     * ConversationRelay handles interruptions.
     * If additional interruption handling is needed,
     * it could be handled here by periodically
     * checking a sesion flag that gets set on
     * an interruption generated by a SEPARATE event. The
     * flag would allow active event handlers (like this
     * function) to abort ==> stream.controller.abort()
     * Again, ConversationRelay has interruption handling
     * so additional logic likely is not needed but it could
     * be done here.
     *
     */

    // LLM is going to return tool_calls or text

    // IF TOOL CALL...
    if (chunk.choices[0]?.delta?.tool_calls) {
      const currentToolCall = chunk.choices[0]?.delta?.tool_calls[0];

      // Set id of tool to be able to capture stream of arguments
      // because tool id is not passed is all chunks.
      if (currentToolCall.id !== undefined) {
        currentToolCallId = currentToolCall.id;
      }

      // Add an object for tool call the first time we see it
      if (!returnObj.tool_calls[currentToolCall.id]) {
        returnObj.tool_calls[currentToolCall.id] = {
          id: currentToolCall.id,
          type: "function",
          function: {
            name: currentToolCall.function.name,
            arguments: "",
          },
        };
      }

      // Append arguments to current tool_call object
      if (currentToolCall?.function?.arguments !== "") {
        //console.info(`Appending arguments for tool ${currentToolCallId} ==> ${returnObj.tool_calls[currentToolCallId].arguments}`);
        returnObj.tool_calls[currentToolCallId].function.arguments =
          returnObj.tool_calls[currentToolCallId].function.arguments +
          currentToolCall.function.arguments;
      }

      // finish_reason should be "tool_calls"
      returnObj.finish_reason = chunk.choices[0]?.finish_reason;
    } else {
      // RETURNING TEXT FROM ASSISTANT
      //console.info(`TEXT RESPONSE chunk: \n` + JSON.stringify(chunk, null, 2));

      // Check if the completion has finished to set "last"
      let last = chunk.choices[0]?.finish_reason === "stop" ? true : false;

      // Send content (current chunk content) back to WebSocket & Twilio for TTS
      promptObj.socket.send(
        JSON.stringify({
          type: "text",
          token: chunk.choices[0]?.delta?.content,
          last: false,
        })
      );

      if (promptObj.clientSocket !== null) {
        promptObj.clientSocket.send(
          JSON.stringify({
            type: "text",
            token: chunk.choices[0]?.delta?.content,
            last: false,
          })
        );
      }

      // Record details from current chunk
      returnObj.content += chunk.choices[0]?.delta?.content || "";
      returnObj.last = last;
      returnObj.finish_reason = chunk.choices[0]?.finish_reason;
    }

    i++;
  }

  // Check for property added at beginning of stream
  // Race condition at beginning of tool_call can create
  // an extraneous "arguments" entry in returnObj.tool_calls
  // This check just deletes it if it exists
  if (returnObj.tool_calls.hasOwnProperty("undefined")) {
    delete returnObj.tool_calls["undefined"];
  }

  //console.info("In invokeOpenAi about to return...\n" + JSON.stringify(returnObj, null, 2));

  return returnObj;
}



================================================
FILE: server/lib/llm-formatting-helpers.mjs
================================================
/** 
 * LLMs expect data in a specific format. This module contains functions to
 * format the data for OpenAI and Bedrock LLMs.
*/
export async function formatLLMMessage(role, content) {
    
    try {    

        let finalMessage = {};
        
        // LLM Providers expect messsage in a different format
        if (process.env.AI_PLATFORM === "invokeOpenAI") {

            finalMessage = { role: role, content: content };

        } else if (process.env.AI_PLATFORM === "invokeBedrock") {
            
            finalMessage = { role: role, content: [ { text: content } ] };

        } else {

            console.error("AI_PLATFORM not set to OpenAI or Bedrock.");
            throw new Error('AI_PLATFORM not set to OpenAI or Bedrock.');

        }        

        //console.info("finalMessage in formatLLMMessage => " + JSON.stringify(finalMessage, null, 2));

        return finalMessage;

    } catch (error) {

        console.error("Error formatting message: ", error);
        throw error;

    }
};
export async function returnDefaultModel() {
    
    try {    

        let defaultModel = "";
        
        // LLM Providers expect messsage in a different format
        if (process.env.AI_PLATFORM === "invokeOpenAI") {

            defaultModel = process.env.OPENAI_LLM_MODEL;

        } else if (process.env.AI_PLATFORM === "invokeBedrock") {
            
            defaultModel = process.env.AWS_MODEL_IDENTIFIER;            

        } else {

            console.error("AI_PLATFORM not set to OpenAI or Bedrock.");
            throw new Error('AI_PLATFORM not set to OpenAI or Bedrock.');

        }                

        return defaultModel;

    } catch (error) {

        console.error("Error formatting message: ", error);
        throw error;

    }
};

/*export async function formatLLMTools(role, content) {
    
    try {    

        let finalMessage = {};
        // OpenAI expects messsage in a different format
        if (process.env.AI_PLATFORM === "invokeOpenAI") {

            finalMessage = { role: role, content: content };

        } else if (process.env.AI_PLATFORM === "invokeBedrock") {
            
            finalMessage = { role: role, content: [ { text: content } ] };

        } else {

            console.error("AI_PLATFORM not set to OpenAI or Bedrock.");
            throw new Error('AI_PLATFORM not set to OpenAI or Bedrock.');

        }        

        return finalMessage;

    } catch (error) {

        console.error("Error formatting message: ", error);
        throw error;

    }
};*/


================================================
FILE: server/lib/package.json
================================================
{
    "name": "common",
    "type": "module",
    "private": true,
    "license": "MIT",
    "author": "Dan Bartlett, Charlie Avila, Ben Johnstone.",
    "version": "1.1.1",
    "description": "Dependencies required for the Twilio ConversationRelay Lambda layer to work with Bedrock with websockets.",
    "dependencies": {
      "@aws-sdk/client-bedrock-runtime": "^3.778.0"
    }
}


================================================
FILE: server/lib/prepare-and-call-llm.mjs
================================================
import { invokeBedrock } from './invoke-bedrock.mjs';
import { invokeOpenAI } from './invoke-open-ai.mjs';
import { returnAllChats, savePrompt} from './database-helpers.mjs';
import { formatLLMMessage } from './llm-formatting-helpers.mjs';

export async function prepareAndCallLLM(prepareObj) {
    try {
        
        //console.info("in [ prepareAndCallLLM ] and prepareObj ==> \n" + JSON.stringify(prepareObj, null, 2));  

        /**
         * SEQUENCE SUMMARY
         * 1) Get chat history
         * 2) Persist current prompt (if not tool call completion)
         * 3) Call LLM
         * 4) Handle response from LLM
         */
        
        // Get all chat messages for this session 
        // All messages saved with connectionId as primary key
        // and string with timestamp for simple query that
        // returns chronologically sorted results.
        // This is the chat history between system, assistant, tools, user
        const messages = await returnAllChats(prepareObj.callSid);    

        // If this is a prompt from the WebSocket connection, then it
        // is text (speech-to-text) from the user. Persist the user prompt 
        // to the database and include it in chat messages before calling LLM.
        if (prepareObj.body?.type === "prompt") { // VOICE PROMPT EVENT
            
            // Format the prompt from the user to LLM standards.            
            let newUserChatMessage  = await formatLLMMessage("user", prepareObj.body.voicePrompt);                                                      

            //console.info("newUserChatMessage in prepareAndCallLLM => " + JSON.stringify(newUserChatMessage, null, 2));
            
            // Persist the current prompt so it is included in subsequent calls.
            await savePrompt(prepareObj.callSid, newUserChatMessage);                

            // Add message to context before calling LLM in this current event.
            messages.push( newUserChatMessage );
        
        } else if (prepareObj.body?.type === "dtmf") { // DTMF EVENT               
            // "dtmf" event is from the WebSocket server, then the
            // user has pushed a phone button. Build a prompt for this case.

            /**
             * {
             *  'type': 'dtmf',
             *  'digit': '1'
             * }
             */
            
            // dtmf handlers are included in the use case configuration and
            // attached to a session. The dtmf handlers can be overwritten
            // if need as a user moves through a session.
            let dtmfHandlers = JSON.parse(prepareObj.sessionDetails.dtmfHandlers);                
            //console.info("==> dtmfHandlers\n" + JSON.stringify(dtmfHandlers, null, 2));   
            
            // Pull the response associated to the digit pressed
            let dtmfResponse = dtmfHandlers[prepareObj.body.digit];
            //console.info("==> dtmfResponse\n" + JSON.stringify(dtmfResponse, null, 2));                

            if (!dtmfResponse) {
                
                console.log("Could not find DTMF handler for current use case / digit.");
                throw new Error('Could not find DTMF handler for current use case / digit.');

            } else {

                // Format the dtmf event from the user into to LLM standards.
                let newUserDTMFMessage = { 
                    role: "system", 
                    content: `The user pushed the ${prepareObj.body?.digit} keypad button.` 
                };

                if (dtmfResponse.replyWithText) {

                    newUserDTMFMessage.content = newUserDTMFMessage.content + ` Reply to the user with this text: "${dtmfResponse.replyText}"`; 
                    
                    // If a tool call is required, then the reply text needs
                    // to sent here because the LLM will not return the text
                    // because it is will be told to only return the tool call (function)
                    if (dtmfResponse.replyWithFunction) {
                        promptObj.socket.send(
                            JSON.stringify(
                                {
                                    type:"text", 
                                    token: dtmfResponse.replyText, 
                                    last:true
                                })
                        );
                    }
                }

                // If the dtmf tiggers a tool call, then adjust the prompt to llm accordingly.
                if (dtmfResponse.replyWithFunction) {
                    // set object for tool choice
                    tool_choice = { "type": "function", "function": {"name":dtmfResponse.replyFunction }};
                    newUserDTMFMessage.content = newUserDTMFMessage.content + " Call the tool and wait.";                                                                       
                }                    
                
                // Persist the current prompt so it is included in subsequent calls.                
                await savePrompt(prepareObj.ddbDocClient, prepareObj.callSid, prepareObj.newUserDTMFMessage);

                // Add message to context before calling LLM in this current event.
                messages.push( newUserDTMFMessage );

            }


        } else if (prepareObj.toolCallCompletion) { // TOOL CALL COMPLETION EVENT

            /**
             * Upon completing one or more tool calls, this function is
             * invoked to continue the conversation. The tool call functions
             * updatethe database with their results so they would already be 
             * in the "messages" array. 
             * 
             * The boolean toolCallCompletion is passed to the LLM handler
             * and the call to the LLM can be adjusted if needed.
             * 
             * No additional processing needed for current implementation, but if
             * needed, it could be done here.
             */

        }

        //console.info("messages before calling LLM\n" + JSON.stringify(messages, null, 2));   

        const AIPlatformHandler = {
            invokeBedrock,
            invokeOpenAI            
        };

        console.info("process.env.AI_PLATFORM => " + process.env.AI_PLATFORM);

        // Call the LLM passing context and chat history
        return await AIPlatformHandler[process.env.AI_PLATFORM]({
            messages: messages,
            sessionDetails: prepareObj.sessionDetails,
            toolCallCompletion: prepareObj.toolCallCompletion,
            tool_choice: prepareObj.tool_choice,
            socket: prepareObj.socket,
            clientSocket: prepareObj.clientSocket
        });
        
    } catch (error) {
        
        console.error("Error in prepareAndCallLLM: ", error);
        throw error;
        
    }
}


================================================
FILE: server/lib/setup-call-post-handler.mjs
================================================
import { FSDB } from "file-system-db";  // https://github.com/WillTDA/File-System-DB
const useCases = new FSDB("../data/use-cases.json", false);
const users = new FSDB("../data/users.json", false);
const crSessions = new FSDB("../data/cr-sessions.json", false);
import { formatLLMMessage, returnDefaultModel } from "./llm-formatting-helpers.mjs"; //

export const setupCallPostHandler = async (twilioBody) => {
    
    console.info("twilioBody.From ==>\n" + JSON.stringify(twilioBody.From, null, 2));

    /**
     * First, use the FROM caller to get the user profile. This
     * allows you to personalize the experience.
     * From number could be a phone number, sip address, or WebRTC client.
     */    
    let userContext = {
        "pk": twilioBody.From,
        "firstName": "Jane",
        "lastName": "Doe",
        "useCase": "albert-einstein",
        "conversationRelayParamsOverride": {}
    }; 
    try {       
        let from = twilioBody.From.replace("client:", ""); // Remove "client:" prefix if present
        let user = users.get(from);  // Pull user profile from database
        if (user !== undefined) {
            userContext = user;
        }        
    } catch (err) {
        console.error("Error getting user profile from database: ", err);
    }
    
    //console.info("userContext ==>\n" + JSON.stringify(userContext, null, 2));    
    //console.info("userContext.useCase ==>\n" + userContext.useCase);    
    
    /**
     * Use the use case title from the user context if present or default to 
     * use case set in the environment variable.
     * The use case contains the prompt and other configuration details and
     * can be changed dynamically for each call and during a session.
     */
    const useCaseTitle = (userContext.useCase) ? userContext.useCase : process.env.STACK_USE_CASE;    
    
    console.info("useCaseTitle ==> " + useCaseTitle);    

    let useCase = null;
    try {        
        let useCaseRecord = useCases.get(useCaseTitle);
        if (useCaseRecord !== undefined) {
            useCase = useCaseRecord;
            useCase = {
                ...useCase, // Add use case configuration
                ...userContext.conversationRelayParamsOverride // Override conversation relay params from user context (if needed)
            };            
        }   
    } catch (err) {
        console.error("Error getting use case configuration from database: ", err);
    }
    
    //console.info("useCase ==>\n" + JSON.stringify(useCase, null, 2));    
    
    // Set the prompt to what was returned from DynamoDB.
    let prompt = useCase.prompt;

    /**
     * This step shows how you dynamically change the prompt based on the user context.
     * Here we are insterting the user's name into the prompt if it exists otherwise,
     * we tell the LLM to ask for the user's name. This is a simple example but you can
     * add as much complexity as you need to the prompt.
    */
    if (Object.keys(userContext).length  > 0 && userContext.firstName && userContext.lastName) {
        prompt = prompt.replace('<<USER_CONTEXT>>', `The name of the person you are talking to is ${userContext.firstName} ${userContext.lastName}. You do not need to ask for their name.`);
    } else {
        prompt = prompt.replace('<<USER_CONTEXT>>', `First ask for the user's first and last name to use during the call.`);
    }    
   
    let timeZone = (process.env.TIMEZONE) ? process.env.TIMEZONE : "America/Los_Angeles";  // Edit to your specifications or could be dynamic based on user
    
    const currentDate = new Date();
    const dateFormatter = new Intl.DateTimeFormat('en-US', {
        day: '2-digit',
        month: 'long',
        year: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        timeZone: timeZone
    });
    
    prompt = prompt.replace('<<CURRENT_DATE>>', dateFormatter.format(currentDate));

    /**
     * ConversationRelay can handle DTMF events. DTMF handlers can be configured
     * here and then saved into database for the session. ConversationRelay will
     * pass DTMF events to your application via the WebSocket connection.
     * For this implementation, the dtmf handlers are stored in the use case
     * configuration in the database. The dtmf handlers can be changed dynamically
     * for each session.
     * https://www.twilio.com/docs/voice/twiml/connect/conversationrelay#dtmf-message
     */
    const dtmfHandlers = useCase.dtmfHandlers;

    /**
     * For this implementation, the tools are stored in the use case. You can
     * dynamically change the tools available to the LLM during a session.
     */
    const tools = useCase.tools;

    /**
     * Using AWS Bedrock enables your application to dynamically
     * switch models. Select the best model for each session and even change dynamically.
     * Note that any set model needs be available and configured in your account and region.
     * https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html
     * https://docs.aws.amazon.com/bedrock/latest/userguide/amazon-bedrock-marketplace.html
     * https://docs.aws.amazon.com/bedrock/latest/userguide/inference-profiles-use.html
     */    
    // Set the LLM Model at the use case or default to the model set in the environment variable.
    const llmModel = (useCase.llmModel) ? useCase.llmModel : await returnDefaultModel(); 

    try {

        /**
         * To track each session, we use the CallSid from Twilio. This is a unique
         * identifier for each call and is used as the primary key in DynamoDB.
         * You implementation could be different, but using the CallSid from Twilio 
         * makes sense as it is a unique key and can easily be tied back to Twilio logs.
         * 
         * In the code below, we are saving the details for this session 
         * so that it will be availble throughout the conversation.
         */           

        let sessionData = {                  
            llmModel: llmModel, // LLM model to use for this session
            useCase: useCaseTitle,
            useCaseName: useCase.name,
            useCaseTitle: useCase.title,
            useCaseDescription: useCase.description, 
            welcomeGreeting: useCase.welcomeGreeting, // Welcome greeting for the session
            userContext: userContext,
            systemPrompt: [ { text: prompt } ],
            tools: tools, // tools passed into session -- can be changed dynamically.
            dtmfHandlers: dtmfHandlers, // dtmf handlers passed into session -- can be changed dynamically.
            timeStamp: Date.now(), // Expire "demo" session data automatically (can be removed)
            ...twilioBody, // include data from Twilio    
        };

        // Save the session data to the file system "database"
        crSessions.set(twilioBody.CallSid, sessionData);
        const crSession = new FSDB(`../data/sessions/${twilioBody.CallSid}/session.json`, false);
        crSession.set(twilioBody.CallSid, sessionData);

        const sessionChats = new FSDB(`../data/sessions/${twilioBody.CallSid}/chats.json`, false);
        // Format the prompt from the user to LLM standards.            
        let systemChatMessage  = await formatLLMMessage("system", prompt);           
        sessionChats.set("chat::" + Date.now().toString(), systemChatMessage);
        let welcomeGreeting  = await formatLLMMessage("assistant", useCase.conversationRelayParams.welcomeGreeting);
        welcomeGreeting.timestamp = Date.now();
        sessionChats.set("chat::" + Date.now().toString(), welcomeGreeting);

        /**
         * ConversationRelay is extremely configurable. Attributes can be passed in
         * to meet your application requirements as well as your user's requirements.
         * Attributes are set here dynamically for each session.
         * Amoung attributes that can be passed in are: welcomeGreeting, speechModel, voice, 
         * ttsProvider, language, interruptible... Full list of attributes can be found here:
         * https://www.twilio.com/docs/voice/twiml/connect/conversationrelay#conversationrelay-attributes
         * For this implementation, the attributes are stored in the use case in DynamoDB. 
         * The object below is instantiated and then converted to a string that is passed
         * into the TwiML tag below.
         */ 
        let conversationRelayParams = {
            ...useCase.conversationRelayParams,
            "debug": "speaker-events tokens-played", // Include events for development and observability
            ...userContext.conversationRelayParamsOverride // Override conversation relay params from user context (if needed)  
        };

        let conversationRelayParamsString = "";
        for (const [key, value] of Object.entries(conversationRelayParams)) {
            conversationRelayParamsString += `${key}="${value}" `;
            //console.log(`${key}: ${value}`);
        }

        /**
         * If needed, you can add custom parameters to the ConversationRelay TwiML
         * verb. These parameters are passed to the WebSocket connection and can be
         * used to pass data to the your applictions. These parmeters will show up
         * ONLY in the "setup" message sent by the ConversationRelay server to your application.
         * After declaring the object, we loop through the customParams object and build 
         * a string of <Parameter></Parameter> tags that get added to the TwiML.
         * https://www.twilio.com/docs/voice/twiml/connect/conversationrelay#parameter-element
         * For this implementation, we are passing the callSid to the WebSocket connection
         * so that we can tie the WebSocket connection to the call session in DynamoDB so
         * using thes Parameters is not required.
         */
        let customParams = {
            callSid:twilioBody.CallSid
            // Additional params can be added here if needed
        }; 
        let customParamsString = "";
        for (const [key, value] of Object.entries(customParams)) {
            customParamsString += `            <Parameter name="${key}" value="${value}" />
`;
            console.log(`${key}: ${value}`);
        }        
                        
        /**
         * Generate the WebSocket URL for the ConversationRelay. Twilio
         * will connect a new WebSocket connection to this URL. The CallSid
         * from Twilio is passed in the url and subsequently used to
         * access and manage the session in DynamoDB.
         */
        let ws_url = `${process.env.WS_URL}?callSid=${twilioBody.CallSid}`;

        /**
         * Generate the TwiML for the ConversationRelay. This is the Twilio's XML Language.
         * https://www.twilio.com/docs/voice/twiml
         * https://www.twilio.com/docs/voice/twiml/connect/conversationrelay
         */
        let twiml = `<?xml version="1.0" encoding="UTF-8"?><Response>    
    <Connect>
        <ConversationRelay url="${ws_url}" ${conversationRelayParamsString} >
            ${customParamsString}
        </ConversationRelay>
    </Connect>
</Response>`;
        
        //console.log("twiml ==> ", twiml);
        
        return twiml;

    } catch (err) {
        
        console.log("Error writing session details for call => ", err);                
        return;
        
    }        
};


================================================
FILE: server/lib/tools/save-tool-result.mjs
================================================
import { FSDB } from "file-system-db"; // https://github.com/WillTDA/File-System-DB

export async function saveToolResult(tool, toolResult) {

  console.log("in saveToolResult and tool\n" + JSON.stringify(tool, null, 2));
  console.log("in saveToolResult and toolResult\n" + JSON.stringify(toolResult, null, 2));

  let finalToolResult = { 
    role: "tool", 
    tool_call_id: tool.id,
    content: JSON.stringify(toolResult)
  };        

/*
    let finalToolResult = { 
      role: "tool",
      tool_call_id: tool.id, 
      content: [
        {
          toolResult: {
            toolUseId: tool.toolUseId,
            content: [
              {
                "json": toolResult            
              }
            ]
          }
        }
      ]
    };        */
  
    console.info("in saveToolResult and finalToolResult\n" + JSON.stringify(finalToolResult, null, 2));      
    finalToolResult.timestamp = Date.now();
    const sessionChats = new FSDB(`../data/sessions/${tool.callSid}/chats.json`, false);
    sessionChats.set(`chat::${Date.now().toString()}${tool.callSid.slice(-5)}`, finalToolResult);

    return true;
  
  }


================================================
FILE: server/lib/tools/twilio-send-email.cjs
================================================
/**
 *  twilio-send-email
 * 
 *
 */

// SendGrid Client (from Lambda Layer)
const mail = require('@sendgrid/mail');   

async function sendEmailWithTwilio(emailObject) {

  console.info("MessageObject\n" + JSON.stringify(emailObject, null, 2));    

  try {
    
    // This could be made dynamic if sending from 
    // multiple SendGrid accounts.
    mail.setApiKey(process.env.TWILIO_SENDGRID_API_KEY);    
    
    // Simple example that could be easily extended to
    // include dynamic templates and add categories, custom arguments
    // an more => https://www.twilio.com/docs/sendgrid/api-reference/mail-send/mail-send
    let emailSendObject = {
      to: emailObject.to_email,
      from: process.env.TWILIO_SENDGRID_FROM,
      subject: emailObject.subject,
      content: [{type:"text/html", value:emailObject.html}]
    };

    // Call SendGrid
    let response = await mail.send(emailSendObject);

    console.log("response ==> ", response);

  } catch (error) {
    
    console.error("Error sending email with Twilio SendGrid: ", error);
    
    // Just logging the error here and will still return true
    // because this is a demo / poc!

  }

  return true;

};

module.exports = {
  sendEmailWithTwilio
};


================================================
FILE: server/lib/tools/twilio-send-message.cjs
================================================
/**
 *  twilio-send-message
 * 
 *
 */

const accountSid = process.env.TWILIO_MESSAGE_ACCOUNT_SID;
const authToken = process.env.TWILIO_MESSAGE_AUTH_TOKEN;
const twilioClient = require('twilio')(accountSid, authToken);

async function sendMessageWithTwilio(messageObject) {

  console.info("MessageObject\n" + JSON.stringify(messageObject, null, 2));    

  try {
    
    // Format and execute api call to Twilio  
    const messageResponse = await twilioClient.messages.create({
      to: messageObject.To,
      from: process.env.TWILIO_MESSAGE_FROM_NUMBER,
      body: messageObject.MessageBody,
    });       
    console.log("messageResponse => ", messageResponse);

  } catch (error) {

    console.error("Error sending message with Twilio: ", error);
    
    // Just logging the error here and will still return true
    // because this is a demo / poc!
    
  }

  return true;

};

module.exports = {
  sendMessageWithTwilio
};


================================================
FILE: server/lib/tools/apartment-search/apartment-search-utils.mjs
================================================
// Function to build dynamic expressions for UpdateItem
// Takes in object with fields and breaks keys and values
// into the necessary parts for the UpdateItem operation
// Utility function to normalize various time formats to the database's 12-hour AM/PM format
function normalizeTimeFormat(time) {
  // Check if time is already in the desired AM/PM format
  if (/^(0?[1-9]|1[0-2]):[0-5][0-9] ?(AM|PM)$/i.test(time.trim())) {
    return time.toUpperCase().trim(); // Return as-is if it's already correct
  }

  // Handle 24-hour format (e.g., "14:00")
  let [hour, minute] = time.split(":");
  minute = minute.replace(/[^0-9]/g, ""); // Clean any non-numeric characters from minutes
  hour = parseInt(hour, 10);

  let period = "AM"; // Default to AM

  // Convert 24-hour to 12-hour format
  if (hour >= 12) {
    period = "PM";
    if (hour > 12) hour -= 12;
  } else if (hour === 0) {
    hour = 12; // Midnight is 12:00 AM
  }

  // Pad minutes to ensure it's always two digits
  minute = minute.padStart(2, "0");

  // Return time in the database's expected format
  return `${hour}:${minute} ${period}`;
}

export  { 
  normalizeTimeFormat
};


================================================
FILE: server/lib/tools/apartment-search/check-availability.mjs
================================================
import { FSDB } from "file-system-db"; // https://github.com/WillTDA/File-System-DB
import { saveToolResult} from '../save-tool-result.mjs';
import { normalizeTimeFormat } from './apartment-search-utils.mjs';

async function checkAvailability(tool) {
    
    const { date, time, type, apartmentType } = JSON.parse(tool.function.arguments);
  
    const appointments = new FSDB(`../data/use-cases/apartment-search/data.appointments.json`, false);
    const availableAppointmentsRaw = appointments.getAll();   
    
    // Format these messages to be ingested by LLM
    const availableAppointments = availableAppointmentsRaw.map(appointment => {                
      console.log(`[checkAvailability] Appointment:`, appointment);  
      return { ...appointment.value.appointment };
    });         

    console.log(
      `[checkAvailability] Current available appointments:`,
      availableAppointments
    );
    console.log(`[checkAvailability] Received arguments:`, tool);
  
    // Step 1: Check for missing fields and create messages for the LLM to ask the user for them
    const missingFields = [];
  
    if (!date) {
      missingFields.push("date");
    }
  
    if (!type) {
      missingFields.push("tour type (e.g., in-person or self-guided)");
    }
  
    if (!apartmentType) {
      missingFields.push("apartment type (e.g., studio, one-bedroom, etc.)");
    }
  
    // If there are missing fields, return the structured message for the LLM to prompt the user
    if (missingFields.length > 0) {
      return {
        missing_fields: missingFields,
        message: `Please provide the following details: ${missingFields.join(
          ", "
        )}.`,
      };
    }
  
    let normalizedTime = null;
    if (time) {
      normalizedTime = normalizeTimeFormat(time);
    }
  
    // Step 2: Check for an exact match (date, time, type, apartmentType)
    let exactMatchSlot = null;
    if (time) {
      exactMatchSlot = availableAppointments.find(
        (slot) =>
          slot.date === date &&
          slot.time === normalizedTime &&
          slot.type === type &&
          slot.apartmentType === apartmentType
      );
    }
  
    if (exactMatchSlot) {
      console.log(`[checkAvailability] Exact match found.`);
      return {
        availableSlots: [exactMatchSlot],
        message: `The ${time} slot on ${date} is available for an ${type} tour of a ${apartmentType} apartment. Would you like to book this?`,
      };
    }
  
    // Step 3: Check for similar matches (same date, type, apartmentType but different time)
    let similarDateSlots = availableAppointments.filter(
      (slot) =>
        slot.date === date &&
        slot.type === type &&
        slot.apartmentType === apartmentType
    );
  
    if (similarDateSlots.length > 0) {
      console.log(
        `[checkAvailability] Similar matches found (different time on the same date).`
      );
      return {
        availableSlots: similarDateSlots,
        message: `The ${time} slot on ${date} isn't available. Here are other available times for that day: ${similarDateSlots
          .map((slot) => slot.time)
          .join(", ")}. Would any of these work for you?`,
      };
    }
  
    // Step 4: Check for broader matches (same type, apartmentType but different date)
    let broaderSlots = availableAppointments.filter(
      (slot) => slot.type === type && slot.apartmentType === apartmentType
    );
  
    if (broaderSlots.length > 0) {
      console.log(`[checkAvailability] Broader matches found (different date).`);
      return {
        availableSlots: broaderSlots,
        message: `There are no available slots on ${date} for a ${apartmentType} apartment, but here are other available dates: ${broaderSlots
          .map((slot) => `${slot.date} at ${slot.time}`)
          .join(", ")}. Would any of these work for you?`,
      };
    }
  
    // Step 5: If no matches are found at all
    console.log(`[checkAvailability] No available slots found.`);
    return {
      availableSlots: [],
      message: `There are no available slots for a ${apartmentType} apartment at this time. Would you like to explore other options or check availability later?`,
    };
}


export async function CheckAvailabilityTool(tool) {

    console.info("EVENT\n" + JSON.stringify(tool, null, 2));    

    try {

        let toolResult = await checkAvailability(tool);

        await saveToolResult(tool, toolResult);        
        
        return true;

    } catch (error) {
        
        console.log("Error failed to complete the function [CheckAvailabilityTool] => ", error);
        
        return false;

    }    

};


================================================
FILE: server/lib/tools/apartment-search/check-existing-appointments.mjs
================================================
import { FSDB } from "file-system-db"; // https://github.com/WillTDA/File-System-DB
import { saveToolResult} from '../save-tool-result.mjs';



// Function to check existing appointments
async function checkExistingAppointments(tool) {

  // Handles users without a profile
  let userPk = (tool.userContext?.pk) ? tool.userContext.pk : tool.call_details.from_phone;

  const existingAppointments = new FSDB(`../data/use-cases/apartment-search/data.user.appointments.json`, false);  
  const userAppointments = existingAppointments.startsWith(userPk);   

  // If user has appointments, return them
  if (userAppointments.length > 0) {

    const userAppointments = userAppointments.map( app => {
      return { ...app.appointment };
    });
    
    return {
      appointments: userAppointments,
      message: `You have the following appointments scheduled: ${userAppointments
        .map(
          (appt) =>
            `${appt.date} at ${appt.time} for a ${appt.apartmentType} tour (${appt.type} tour).`
        )
        .join("\n")}`,
    };
  } else {
    // No appointments found
    return {
      appointments: [],
      message:
        "You don't have any appointments scheduled. Would you like to book a tour or check availability?",
    };
  }
}

export async function CheckExistingAppointmentsTool(tool) {

    console.info("EVENT\n" + JSON.stringify(tool, null, 2));    

    try {

        let toolResult = await checkExistingAppointments(tool);

        await saveToolResult(tool, toolResult);

        return true;

    } catch (error) {
        
        console.log("Error failed to complete the function [CheckExistingAppointmentsTool] => ", error);
        
        return false;

    }    

};



================================================
FILE: server/lib/tools/apartment-search/common-inquiries.mjs
================================================
import { FSDB } from "file-system-db"; // https://github.com/WillTDA/File-System-DB
import { saveToolResult} from '../save-tool-result.mjs';

// Function to handle common inquiries
async function commonInquiries(tool) {

  const { inquiryType, apartmentType } = JSON.parse(tool.function.arguments);

  const apartments = new FSDB(`../data/use-cases/apartment-search/data.apartments.json`, false);
  const apartmentDetailsRecord = apartments.get("apartmentDetails");
  const apartmentDetails = JSON.parse(apartmentDetailsRecord.details);

  // Map the inquiry types to the database field names
  const inquiryMapping = {
    "pet policy": "petPolicy",
    "income requirements": "incomeRequirements",
    location: "location",
    address: "location", // Map 'address' to 'location' as well
  };

  // If there's a mapped field, use it; otherwise, use the inquiryType directly
  const inquiryField = inquiryMapping[inquiryType] || inquiryType;

  let inquiryDetails;

  if (apartmentType) {
    // Return specific details for the given apartment type
    inquiryDetails = apartmentDetails[apartmentType][inquiryField];

    // If inquiry is for location/address, format the location details
    if (inquiryField === "location" && inquiryDetails) {
      inquiryDetails = `${inquiryDetails.street}, ${inquiryDetails.city}, ${inquiryDetails.state}, ${inquiryDetails.zipCode}`;
    }
  } else {
    // Return general details across all apartment types
    inquiryDetails = Object.keys(apartmentDetails)
      .map((key) => {
        const details = apartmentDetails[key][inquiryField];
        if (inquiryField === "location" && details) {
          return `${details.street}, ${details.city}, ${details.state}, ${details.zipCode}`;
        }
        return details;
      })
      .filter(Boolean)
      .join(" ");
  }

  // Return the structured result based on the inquiryDetails
  if (inquiryDetails) {
    return {
      inquiryDetails,
      message: `Here are the details about ${inquiryType} for the ${
        apartmentType ? apartmentType : "available apartments"
      }: ${inquiryDetails}`,
    };
  } else {
    // Return structured JSON indicating no information available
    return {
      inquiryDetails: null,
      message: `I'm sorry, I don't have information about ${inquiryType}.`,
    };
  }

}

export async function CommonInquiriesTool(tool) {

    console.info("EVENT\n" + JSON.stringify(tool, null, 2));    

    try {

        let toolResult = await commonInquiries(tool);

        await saveToolResult(tool, toolResult);

        return true;

    } catch (error) {
        
        console.log("Error failed to complete the function [CommonInquiriesFunction] => ", error);
        
        return false;

    }    

};


================================================
FILE: server/lib/tools/apartment-search/list-available-apartments.mjs
================================================
import { FSDB } from "file-system-db"; // https://github.com/WillTDA/File-System-DB
import { saveToolResult} from '../save-tool-result.mjs'; 

// Function to list available apartments
async function listAvailableApartments(tool) {
  
  const args = JSON.parse(tool.function.arguments);
  
  const apartments = new FSDB(`../data/use-cases/apartment-search/data.apartments.json`, false);
  const apartmentDetailsRecord = apartments.get("apartmentDetails");
  const apartmentDetails = JSON.parse(apartmentDetailsRecord.details);

  try {
    let apartments = Object.keys(apartmentDetails).map((type) => ({
      type,
      ...apartmentDetails[type],
    }));

    // Filter based on user input
    if (args.date) {
      apartments = apartments.filter(
        (apt) => new Date(apt.moveInDate) <= new Date(args.date)
      );
    }
    if (args.budget) {
      apartments = apartments.filter((apt) => apt.rent <= args.budget);
    }
    if (args.apartmentType) {
      apartments = apartments.filter((apt) => apt.type === args.apartmentType);
    }

    // Summarize available apartments
    const summary = apartments
      .map(
        (apt) =>
          `${apt.layout}: $${apt.rent} per month, available from ${
            apt.moveInDate
          }. Features: ${apt.features.join(", ")}.`
      )
      .join("\n\n");

    // If apartments are found, return the structured response
    if (apartments.length > 0) {
      return {
        availableApartments: summary,
        message: `Here are the available apartments based on your search: \n\n${summary}`,
      };
    } else {
      // No apartments found based on the filters
      return {
        availableApartments: [],
        message: "No apartments are available that match your search criteria.",
      };
    }
  } catch (error) {
    console.log(
      `[listAvailableApartments] Error listing available apartments: ${error.message}`
    );
    // Return error message as structured JSON
    return {
      availableApartments: null,
      message: "An error occurred while listing available apartments.",
    };
  }
}

export async function ListAvailableApartmentsTool(tool) {

    console.info("EVENT\n" + JSON.stringify(tool, null, 2));    

    try {

        let toolResult = await listAvailableApartments(tool);

        await saveToolResult(tool, toolResult);
  
        return true;

    } catch (error) {
        
        console.log("Error failed to complete the function [ListAvailableApartmentsFunction] => ", error);
        
        return false;

    }    

};


================================================
FILE: server/lib/tools/apartment-search/schedule-tour.mjs
================================================
import { FSDB } from "file-system-db"; // https://github.com/WillTDA/File-System-DB
import { saveToolResult} from '../save-tool-result.mjs';
import { normalizeTimeFormat } from './apartment-search-utils.mjs';
// Function to schedule a tour
async function scheduleTour(tool) {
  
  const { date, time, type, apartmentType }  = JSON.parse(tool.function.arguments);      

  const appointments = new FSDB(`../data/use-cases/apartment-search/data.appointments.json`, false);
  const appointmentsRaw = appointments.getAll();   
  const availableAppointments = appointmentsRaw.map(appointment => {                
      return { ...appointment.appointment };
  });         

  console.log(
    `[scheduleTour] Current available appointments:`,
    availableAppointments
  );
  console.log(`[scheduleTour] Received arguments:`, tool);

  // Normalize the time input
  const normalizedTime = normalizeTimeFormat(time);
  console.log(`[scheduleTour] Normalized Time: ${normalizedTime}`);

  // Find the index of the matching available appointment slot
  const index = availableAppointments.findIndex(
    (slot) =>
      slot.date === date &&
      slot.time === normalizedTime &&
      slot.type === type &&
      slot.apartmentType === apartmentType
  );

  console.log(`[scheduleTour] Index found: ${index}`);

  // If no matching slot is found, return a message indicating unavailability
  if (index === -1) {
    console.log(`[scheduleTour] The requested slot is not available.`);
    return {
      available: false,
      message: `The ${normalizedTime} slot on ${date} is no longer available. Would you like to choose another time or date?`,
    };
  }


  // DELETE 
  let appt_key = `${date}::${time}::${apartmentType}::${type}`;

  const deleteAppointment = appointments.delete(appt_key);     
  
  console.log("deleteAppointment => ", deleteAppointment);
/*
  // Handles users without a profile
  let userPk = (tool.userContext?.pk) ? tool.userContext.pk : tool.call_details.from_phone;
  
  // Save new appointment linked to the user to the database              
  let confirmedAppointment = {
    pk: userPk,
    sk: `apartmentAppointment::${appt_sk}`,
    appointment: availableAppointments[index], // Add ID?
    expireAt:  parseInt((Date.now() / 1000) + (86400 * 7))  // Expire "demo" session data automatically (can be removed)
  };
  
  await ddbDocClient.send(
    new PutCommand({
    TableName: process.env.TABLE_NAME,
    Item: confirmedAppointment
  }));  
*/
  console.log(`[scheduleTour] Appointment successfully scheduled.`);

  // Return confirmation message for the successful scheduling
  return {
    available: true,
    message: `Your tour is scheduled for ${date} at ${normalizedTime}. Would you like a confirmation via SMS?`,
  };
}

export async function ScheduleTourTool(tool) {

    console.info("EVENT\n" + JSON.stringify(tool, null, 2));    

    try {

        let toolResult = await scheduleTour(tool);

        await saveToolResult(tool, toolResult);

        return true;

    } catch (error) {
        
        console.log("Error failed to complete the function [ScheduleTourFunction] => ", error);
        
        return false;

    }    

};


================================================
FILE: server/lib/tools/apartment-search/send-appointment-confirmation-sms.mjs
================================================
import { saveToolResult} from '../save-tool-result.mjs';

async function sendMessage(tool) {

 console.log('Placeholder function for sending SMS confirmation');

  return {
    status: "success",
    message: `An SMS confirmation has been sent.`,
  };
  
}

export async function SendAppointmentConfirmationSmsTool(tool) {

    console.info("EVENT\n" + JSON.stringify(tool, null, 2));    

    
    try {

        let toolResult = await sendMessage(tool);

        await saveToolResult(tool, toolResult);

        return true;

    } catch (error) {
        
        console.log("Error failed to complete the function [SendAppointmentConfirmationSmsFunction] => ", error);
        
        return false;

    }    

};


================================================
FILE: server/lib/tools/apartment-search/send-message.mjs
================================================
import { FSDB } from "file-system-db"; // https://github.com/WillTDA/File-System-DB
import { saveToolResult } from "../save-tool-result.mjs";
import pkg from "../twilio-send-message.cjs";
const { sendMessageWithTwilio } = pkg;

export async function SendSms(tool) {

  console.info("in SendSMS and tool\n" + JSON.stringify(tool, null, 2));    
  
  let args = JSON.parse(tool.function.arguments);

  console.info("args\n" + JSON.stringify(args, null, 2));  
  
  // Personalize the message using the userProfile
  const name = tool.userContext?.firstName || "friend";
  const apartmentType = args.appointmentDetails.apartmentType;
  const tourType = args.appointmentDetails.type === "in-person" ? "an in-person" : "a self-guided";
  const message = `Hi ${name}, your tour for a ${apartmentType} apartment at Parkview is confirmed for ${args.appointmentDetails.date} at ${args.appointmentDetails.time}. This will be ${tourType} tour. We'll be ready for your visit! Let us know if you have any questions.`;

  let messageObject = {
    To: args.to_phone,
    MessageBody: message
  };

  await sendMessageWithTwilio(messageObject);

  let toolResult = { message: "An conformation SMS has been sent!" };

  await saveToolResult(tool, toolResult);

  return true;

}


================================================
FILE: server/lib/tools/apartment-search/tools.mjs
================================================
// This file needs to be imported in lib/default-websocket-handler.mjs
// and added to the switch (sessionDetails.useCase) in that file.

import { CheckAvailabilityTool } from './check-availability.mjs';
import { CheckExistingAppointmentsTool } from './check-existing-appointments.mjs';
import { CommonInquiriesTool } from './common-inquiries.mjs';
import { ListAvailableApartmentsTool } from './list-available-apartments.mjs';
import { ScheduleTourTool } from './schedule-tour.mjs';
import { SendSms } from './send-message.mjs';

// Tools are called dynamically but ONLY if they match a function
// in this object.
export const ToolHandler = {
    CheckAvailabilityTool,
    CheckExistingAppointmentsTool,
    CommonInquiriesTool,
    ListAvailableApartmentsTool,
    ScheduleTourTool,
    SendSms
};

export async function makeApartmentSearchToolCalls(tool_calls_object, callSid, sessionDetails) {

  console.log("In makeApartmentSearchToolCalls...");

  try {
    const tool_calls = Object.values(tool_calls_object).map(tool => {                
        return {             
            ...tool, 
            callSid: callSid, 
            userContext: sessionDetails.userContext,
            call_details: {
                to_phone: sessionDetails.To,
                from_phone: sessionDetails.From,
                twilio_call_sid: sessionDetails.CallSid,
                twilio_account_sid: sessionDetails.AccountSid                            
            }
        };                                                
    });          

    await Promise.all(tool_calls.map(async (tool) => {
      
      try {

        console.log("tool in promise all => ", tool);
        await ToolHandler[tool.function.name](tool);
      
      } catch (error) {
      
        console.error(`Error calling tool ${tool.name}: `, error);
        throw new Error(`Error calling tool ${tool.name}: ` + error.message);
      
      }

    }));
    
    return true;

  } catch (error) {
    
    console.error("Error in makeApartmentSearchToolCalls: ", error);
    throw new Error('Error in makeApartmentSearchToolCalls: ' + error.message);

  }
}



================================================
FILE: server/lib/tools/restaurant-ordering/check-restaurant-delivery-time.mjs
================================================
import { saveToolResult} from '../save-tool-result.mjs';

export async function CheckRestaurantDeliveryTime(tool) {

    console.info("in CheckRestaurantDeliveryTime and tool\n" + JSON.stringify(tool, null, 2));    

    let input = tool.input;    

    console.info("input\n" + JSON.stringify(input, null, 2));     

    let deliveryTimes = [
        {time: "45 minutes", message:"We are starting your order right now and can have it to you in 45."},
        {time: "1 hour", message:"We will deliver your order in one hour."},
        {time: "1 hour and 15 minutes", message:"We are a little backed up right now so we will delivery your order in one hour and 15 minutes."}
    ];

    let deliveryTime = deliveryTimes[ ( Math.floor (Math.random() * deliveryTimes.length) ) ];
  
    console.log(`[checkDeliveryTime] successfully run.`);

    let toolResult = { deliveryTime: deliveryTime.time, message: deliveryTime.message };

    await saveToolResult(tool, toolResult);

    return true;

}


================================================
FILE: server/lib/tools/restaurant-ordering/check-restaurant-pick-up-time.mjs
================================================
import { saveToolResult } from "../save-tool-result.mjs";

export async function CheckRestaurantPickUpTime(tool) {

    console.info("in CheckRestaurantPickUpTime and tool\n" + JSON.stringify(tool, null, 2));    
    
    let input = tool.input;

    console.info("input\n" + JSON.stringify(input, null, 2));     

    let pickupTimes = [
        {time: "15 minutes", message:"We are starting your order right now! See you in 15 minutes."},
        {time: "30 minutes", message:"We will have your order ready in 30 minutes."},
        {time: "45 minutes", message:"We are a little backed up right now so you order will be ready in 45 minutes."}
      ];
    
      let pickupTime = pickupTimes[ ( Math.floor (Math.random() * pickupTimes.length) ) ];
    
      // Return confirmation message for the successful scheduling

    console.log(`[CheckPickUptime] successfully run.`);

    let toolResult = { pickupTime: pickupTime.time, message: pickupTime.message };

    console.info("in CheckRestaurantPickUpTime and toolResult\n" + JSON.stringify(toolResult, null, 2));    

    await saveToolResult(tool, toolResult);

    return true;

}


================================================
FILE: server/lib/tools/restaurant-ordering/place-order.mjs
================================================
import { FSDB } from "file-system-db"; // https://github.com/WillTDA/File-System-DB
import { saveToolResult } from "../save-tool-result.mjs";

export async function PlaceOrder(tool) {

  console.info("in PlaceOrderTool and tool\n" + JSON.stringify(tool, null, 2));    
  
  let args = JSON.parse(tool.function.arguments);

  console.info("args\n" + JSON.stringify(args, null, 2));  
 
  let confirmedOrder = {
    description: 'restaurantOrder', 
    order_id: `restaurantOrder::${tool.callSid.slice(-4)}::${(Math.floor(Date.now() / 1000)).toString()}`,
    order: {
      order_items: args.current_order,
      order_type: args.order_type,
      order_total: args.order_total
    },
    timestamp:  Date.now()
  };
    
  const sessionOrder = new FSDB(`../data/sessions/${tool.callSid}/orders.json`, false);
  sessionOrder.set(`order`, confirmedOrder);
  console.log(`[PlaceOrderFunction] Order successfully saved.`);

  let toolResult = { message: `Your order has been accepted.`};

  await saveToolResult(tool, toolResult);

  return true;

}


================================================
FILE: server/lib/tools/restaurant-ordering/send-email.mjs
================================================
import { FSDB } from "file-system-db"; // https://github.com/WillTDA/File-System-DB
import { saveToolResult } from "../save-tool-result.mjs";
import pkg from "../twilio-send-email.cjs";
const { sendEmailWithTwilio } = pkg;

export async function SendEmail(tool) {

  console.info("in SendSMS and tool\n" + JSON.stringify(tool, null, 2));    
  
  let args = JSON.parse(tool.function.arguments);

  console.info("args\n" + JSON.stringify(args, null, 2));  

 const sessionOrders = new FSDB(`../data/sessions/${tool.callSid}/orders.json`, false);
  const sessionOrder= sessionOrders.get('order');

  console.info("sessionOrder\n" + JSON.stringify(sessionOrder, null, 2));  
 
  const order_items_text = sessionOrder.order.order_items.map( it => {
    return  it.line_item;
  });

  // Personalize the message using the userProfile
  const name = tool.userContext?.firstName || "friend";
  const message = `Hi ${name}, Twilio Dough Boys has accepted your order [${order_items_text.join(', ')}]. The total is $${sessionOrder.order.order_total} due on ${sessionOrder.order.order_type}.`;

  let htmlContent = `<html><body><h1>Order Details</h1><p>${message}</p></body></html>`;

  await sendEmailWithTwilio({
    to_email: args.to_email,
    html: htmlContent,
    subject: `Here is your order confirmation email!`
  });

  let toolResult = { message: `A confirmation email has been sent!` };

  await saveToolResult(tool, toolResult);

  return true;

}


================================================
FILE: server/lib/tools/restaurant-ordering/send-message.mjs
================================================
import { FSDB } from "file-system-db"; // https://github.com/WillTDA/File-System-DB
import { saveToolResult } from "../save-tool-result.mjs";
import pkg from "../twilio-send-message.cjs";
const { sendMessageWithTwilio } = pkg;

export async function SendSms(tool) {

  console.info("in SendSMS and tool\n" + JSON.stringify(tool, null, 2));    
  
  let args = JSON.parse(tool.function.arguments);

  console.info("args\n" + JSON.stringify(args, null, 2));  

  const sessionOrders = new FSDB(`../data/sessions/${tool.callSid}/orders.json`, false);
  const sessionOrder= sessionOrders.get('order');

  console.info("sessionOrder\n" + JSON.stringify(sessionOrder, null, 2));  
 
  const order_items_text = sessionOrder.order.order_items.map( it => {
    return  it.line_item;
  });

  // Personalize the message using the userProfile
  const name = tool.userContext?.firstName || "friend";
  const message = `Hi ${name}, Twilio Dough Boys has accepted your order [${order_items_text.join(', ')}]. The total is $${sessionOrder.order.order_total} due on ${sessionOrder.order.order_type}.`;

  if (sessionOrder.order.order_type === "delivery" && sessionOrder.order?.delivery_address) {
    message = message + ` This order will be delivered to ${sessionOrder.order?.delivery_address}.`
  }

  let messageObject = {
    To: args.to_phone,
    MessageBody: message
  };

  await sendMessageWithTwilio(messageObject);

  let toolResult = { message: "An order conformation SMS has been sent!" };

  await saveToolResult(tool, toolResult);

  return true;

}


================================================
FILE: server/lib/tools/restaurant-ordering/tools.mjs
================================================
// This file needs to be imported in lib/default-websocket-handler.mjs
// and added to the switch (sessionDetails.useCase) in that file.

import { PlaceOrder } from './place-order.mjs';
import { CheckRestaurantPickUpTime } from './check-restaurant-pick-up-time.mjs';
import { CheckRestaurantDeliveryTime } from './check-restaurant-delivery-time.mjs';
import { SendSms } from './send-message.mjs';
import { SendEmail } from './send-email.mjs';

// Tools are called dynamically but ONLY if they match a function
// in this object.
export const ToolHandler = {
    PlaceOrder,
    CheckRestaurantPickUpTime,
    CheckRestaurantDeliveryTime,
    SendSms,
    SendEmail
};

export async function makeRestaurantOrderingToolCalls(tool_calls_object, callSid, sessionDetails) {

  console.log("In makeRestaurantOrderingUseCaseToolCalls...");

  try {
    const tool_calls = Object.values(tool_calls_object).map(tool => {                
        return {             
            ...tool, 
            callSid: callSid, 
            userContext: sessionDetails.userContext,
            call_details: {
                to_phone: sessionDetails.To,
                from_phone: sessionDetails.From,
                twilio_call_sid: sessionDetails.CallSid,
                twilio_account_sid: sessionDetails.AccountSid                            
            }
        };                                                
    });          

    await Promise.all(tool_calls.map(async (tool) => {
      
      try {

        console.log("tool in promise all => ", tool);
        await ToolHandler[tool.function.name](tool);
      
      } catch (error) {
      
        console.error(`Error calling tool ${tool.name}: `, error);
        throw new Error(`Error calling tool ${tool.name}: ` + error.message);
      
      }

    }));
    
    return true;

  } catch (error) {
    
    console.error("Error in makeRestaurantOrderingToolCalls: ", error);
    throw new Error('Error in makeRestaurantOrderingToolCalls: ' + error.message);

  }
}



================================================
FILE: server/lib/tools/tool-calling-example/get-joke.mjs
================================================
import { returnJoke } from "./tool-calling-example-resources.mjs";
import { saveToolResult } from "../save-tool-result.mjs";

export async function GetJoke(tool) {

  console.info("in GetJoke and tool\n" + JSON.stringify(tool, null, 2));    
  
  let args = JSON.parse(tool.function.arguments);

  console.info("args\n" + JSON.stringify(args, null, 2));  

  let joke = await returnJoke();
  let toolResult = { message: joke };

  await saveToolResult(tool, toolResult);

  return true;

}


================================================
FILE: server/lib/tools/tool-calling-example/get-quote.mjs
================================================
import { returnQuote } from "./tool-calling-example-resources.mjs";
import { saveToolResult } from "../save-tool-result.mjs";

export async function GetQuote(tool) {

  console.info("in GetQuote and tool\n" + JSON.stringify(tool, null, 2));    
  
  let args = JSON.parse(tool.function.arguments);

  console.info("args\n" + JSON.stringify(args, null, 2));  

  const randomQuote = await returnQuote();

  let toolResult = { message: randomQuote };

  await saveToolResult(tool, toolResult);

  return true;

}


================================================
FILE: server/lib/tools/tool-calling-example/get-zip-code.mjs
================================================
import { returnCityFromZip } from "./tool-calling-example-resources.mjs";
import { saveToolResult } from "../save-tool-result.mjs";

export async function GetZip(tool) {

  console.info("in GetQuote and tool\n" + JSON.stringify(tool, null, 2));    
  
  let args = JSON.parse(tool.function.arguments);

  console.info("args\n" + JSON.stringify(args, null, 2));  

  const zipResponse = await returnCityFromZip(args.zip);

  let toolResult = { message: zipResponse };

  await saveToolResult(tool, toolResult);

  return true;

}


================================================
FILE: server/lib/tools/tool-calling-example/send-email.mjs
================================================
import { returnQuote, returnJoke } from "./tool-calling-example-resources.mjs";
import { saveToolResult } from "../save-tool-result.mjs";
import pkg from "../twilio-send-email.cjs";
const { sendEmailWithTwilio } = pkg;

export async function SendEmail(tool) {

  console.info("in SendSMS and tool\n" + JSON.stringify(tool, null, 2));    
  
  let args = JSON.parse(tool.function.arguments);

  console.info("args\n" + JSON.stringify(args, null, 2));  

  let htmlContent = "";
  if (args.email_type === 'quote') {
    htmlContent = `<html><body><h1>Quote of the Day</h1><p>${await returnQuote()}</p></body></html>`;
  } else if (args.email_type === 'joke') {
    htmlContent = `<html><body><h1>Joke of the Day</h1><p>${await returnJoke()}</p></body></html>`;
  }    

  await sendEmailWithTwilio({
    to_email: args.to_email,
    html: htmlContent,
    subject: `Here is a ${args.email_type} for you!`
  });

  let toolResult = { message: `Email with a ${args.email_type} has been sent!` };

  await saveToolResult(tool, toolResult);

  return true;

}


================================================
FILE: server/lib/tools/tool-calling-example/send-message.mjs
================================================
import { returnQuote } from "./tool-calling-example-resources.mjs";
import { saveToolResult } from "../save-tool-result.mjs";
import pkg from "../twilio-send-message.cjs";
const { sendMessageWithTwilio } = pkg;

export async function SendSMS(tool) {

  console.info("in SendSMS and tool\n" + JSON.stringify(tool, null, 2));    
  
  let args = JSON.parse(tool.function.arguments);

  console.info("args\n" + JSON.stringify(args, null, 2));  

  const randomQuote = await returnQuote();

  let messageObject = {
    To: args.to_phone,
    MessageBody: randomQuote
  };

  await sendMessageWithTwilio(messageObject);

  let toolResult = { message: "SMS with a quote has been sent!" };

  await saveToolResult(tool, toolResult);

  return true;

}


================================================
FILE: server/lib/tools/tool-calling-example/tool-calling-example-resources.mjs
================================================
import axios from "axios";

export async function returnQuote() {

  const quotes = [

    "The only limit to our realization of tomorrow is our doubts of today. - Franklin D. Roosevelt",
    "In the middle of every difficulty lies opportunity. - Albert Einstein",
    "Success is not final, failure is not fatal: It is the courage to continue that counts. - Winston S. Churchill",
    "The future belongs to those who believe in the beauty of their dreams. - Eleanor Roosevelt",
    "It does not matter how slowly you go as long as you do not stop. - Confucius",
    "You are never too old to set another goal or to dream a new dream. - C.S. Lewis",
    "The best way to predict the future is to create it. - Peter Drucker",
    "Believe you can and you're halfway there. - Theodore Roosevelt",
    "Act as if what you do makes a difference. - William James",
    "Success usually comes to those who are too busy to be looking for it. - Henry David Thoreau",
    "Don't watch the clock; do what it does. Keep going. - Sam Levenson",
    "The only way to do great work is to love what you do. - Steve Jobs",
    "You miss 100% of the shots you don't take. - Wayne Gretzky",
    "The only impossible journey is the one you never begin. - Tony Robbins",
    "Your time is limited, so don't waste it living someone else's life. - Steve Jobs",
    "The best revenge is massive success. - Frank Sinatra",
    "Success is walking from failure to failure with no loss of enthusiasm. - Winston S. Churchill",
    "What lies behind us and what lies before us are tiny matters compared to what lies within us. - Ralph Waldo Emerson",
    "The only way to achieve the impossible is to believe it is possible. - Charles Kingsleigh (Alice in Wonderland)",
    "The only person you are destined to become is the person you decide to be. - Ralph Waldo Emerson",
    "The future depends on what you do today. - Mahatma Gandhi",
    "It is never too late to be what you might have been. - George Eliot",
    "The only limit to our realization of tomorrow will be our doubts of today. - Franklin D. Roosevelt",
    "You cannot change your future, but you can change your habits, and surely your habits will change your future. - A.P.J. Abdul Kalam",
    "The only thing we have to fear is fear itself. - Franklin D. Roosevelt", 
    "That's one small step for a man, one giant leap for mankind. - Neil Armstrong",
    "I think, therefore I am. - René Descartes",
    "To be or not to be, that is the question. - William Shakespeare",
    "All the world's a stage, and all the men and women merely players. - William Shakespeare",
    "Ask not what your country can do for you, ask what you can do for your country. - John F. Kennedy ",
    "Life is like riding a bicycle. To keep your balance, you must keep moving. - Albert Einstein", 
    "Not all those who wander are lost. - J.R.R. Tolkien ",
    "The only impossible journey is the one you never begin. - Tony Robbins ",    
    "Love all, trust a few, do wrong to none. - William Shakespeare", 
    "The greatest happiness of life is the conviction that we are loved; loved for ourselves, or rather, loved in spite of ourselves. - Victor Hugo ",
    "Love is friendship that has caught fire. - Ann Landers ",
    "Being deeply loved by someone gives you strength, while loving someone deeply gives you courage. - Lao Tzu ",    
    "I have a dream. - Martin Luther King Jr.", 
    "The only way to do great work is to love what you do. - Steve Jobs ",
    "Believe you can and you're halfway there. - Theodore Roosevelt", 
    "Strive not to be a success, but rather to be of value. - Albert Einstein", 
    "The future belongs to those who believe in the beauty of their dreams. - Eleanor Roosevelt", 
    "The only limit to our realization of tomorrow will be our doubts of today. - Franklin D. Roosevelt",
    "A friend is one who knows you and loves you just the same. - Elbert Hubbard ",
    "Friendship is the only cement that will ever hold the world together. - Woodrow Wilson",
    "Success is not final, failure is not fatal: It is the courage to continue that counts. - Winston Churchill",
    "The difference between ordinary and extraordinary is that little extra. - Jimmy Johnson", 
    "The only place where success comes before work is in the dictionary. - Vidal Sassoon", 
    "Genius is one percent inspiration and ninety-nine percent perspiration. - Thomas Edison"
  ];

  // Select a random quote from the array
  const randomIndex = Math.floor(Math.random() * quotes.length);
  return quotes[randomIndex];

}

export async function returnJoke() {
  

  let config = {
    method: 'get',
    maxBodyLength: Infinity,
    url: 'https://official-joke-api.appspot.com/random_joke',
    headers: { 
      'Accept': 'application/json'
    }
  };

  let jokeResponse = "No joke found";

  await axios.request(config).then((resp) => {
    console.info("resp\n" + JSON.stringify(resp.data, null, 2));
    jokeResponse = resp.data.setup + " - " + resp.data.punchline;
  });
  
  return jokeResponse;

}


export async function returnCityFromZip(zip) {
  
  let zipUrl = `https://api.zippopotam.us/us/${zip}`;

  let config = {
    method: 'get',
    maxBodyLength: Infinity,
    url: zipUrl,
    headers: { 
      'Accept': 'application/json'
    }
  };

  let zipResponse = "Zip Code not found";

  await axios.request(config).then((resp) => {
    console.info("resp\n" + JSON.stringify(resp.data, null, 2));
    zipResponse = resp.data ? resp.data.places[0]['place name'] + ", " + resp.data.places[0]['state'] : "Zip Code not found";
  });
  
  return zipResponse;

}


================================================
FILE: server/lib/tools/tool-calling-example/tools.mjs
================================================
// This file needs to be imported in lib/default-websocket-handler.mjs
// and added to the switch (sessionDetails.useCase) in that file.

import { GetJoke } from './get-joke.mjs';
import { GetQuote } from './get-quote.mjs';
import { SendSMS } from './send-message.mjs';
import { SendEmail } from './send-email.mjs';
import { GetZip } from './get-zip-code.mjs';

// Tools are called dynamically but ONLY if they match a function
// in this object.
export const ToolHandler = {
    GetJoke,
    GetQuote,
    SendSMS,
    SendEmail,
    GetZip
};

export async function makeToolCallingExampleToolCalls(tool_calls_object, callSid, sessionDetails) {

  console.log("In makeToolCallingExampleToolCalls...");

  try {
    const tool_calls = Object.values(tool_calls_object).map(tool => {                
        return {             
            ...tool, 
            callSid: callSid, 
            userContext: sessionDetails.userContext,
            call_details: {
                to_phone: sessionDetails.To,
                from_phone: sessionDetails.From,
                twilio_call_sid: sessionDetails.CallSid,
                twilio_account_sid: sessionDetails.AccountSid                            
            }
        };                                                
    });          

    await Promise.all(tool_calls.map(async (tool) => {
      
      try {

        console.log("tool in promise all => ", tool);
        await ToolHandler[tool.function.name](tool);
      
      } catch (error) {
      
        console.error(`Error calling tool ${tool.name}: `, error);
        throw new Error(`Error calling tool ${tool.name}: ` + error.message);
      
      }

    }));
    
    return true;

  } catch (error) {
    
    console.error("Error in makeToolCallingExampleToolCalls: ", error);
    throw new Error('Error in makeToolCallingExampleToolCalls: ' + error.message);

  }
}



================================================
FILE: server/routes/client-app.js
================================================
import express from "express";
const router = express.Router();
import cors from "cors";
import path from "path";
import { fileURLToPath } from 'url';

router.use(cors()); // Enable CORS for all routes
router.use(express.json()); // for parsing application/json

const __filename = fileURLToPath(import.meta.url); // get the resolved path to the file
const __dirname = path.dirname(__filename); // get the name of the directory

router.get('/app', (req, res) => {
  console.log("/client/app and dirname ==> ", __dirname);
  res.sendFile(path.join(__dirname, '../../client/build', 'index.html'));
});

export default router;


================================================
FILE: server/routes/client-data.js
================================================
import express from "express";
const router = express.Router();
import cors from "cors";
import url from "url";
//import path from "path";
//import { fileURLToPath } from 'url';

router.use(cors()); // Enable CORS for all routes
router.use(express.json()); // for parsing application/json
import { FSDB } from "file-system-db";

// Route retrieve all useCases from data/useCases.json
// URI:  <server>/client-data/get-use-cases
// Method: GET
// Description: This route retrieves all use cases from the useCases.json file and sends them as a response.
router.get("/get-use-cases", async (req, res) => {
  const useCases = new FSDB(`../data/use-cases.json`, false);
  const allUseCases = useCases.getAll();
  res.send(allUseCases);
});

// URI:  <server>/client-data/update-use-case
// Method: POST
// Description: This route updates specific use case from data passed in the request.
router.post("/update-use-case", async (req, res) => {
  const useCases = new FSDB(`../data/use-cases.json`, false);
  const useCaseKey = req.body.key;

  useCases.set(useCaseKey, {
    name: req.body.value.name,
    role: req.body.value.role,
    title: req.body.value.title, // webRtc, sip, phone
    description: req.body.value.description,
    prompt: req.body.value.prompt,
    tools: req.body.value.tools,
    dtmf: req.body.value.dtmf,
    conversationRelayParams: req.body.value.conversationRelayParams,
  });
  res.send({ status: "success", data: useCases.get(req.body.key) });
});

// URI:  <server>/client-data/delete-use-case
// Method: POST
// Description: This route delete specific use case given the key of the object.
router.post("/delete-use-case", async (req, res) => {
  const useCases = new FSDB(`../data/use-cases.json`, false);
  const useCaseKey = req.body.key;

  console.log("delete-use-case called with key: ", useCaseKey);

  useCases.delete(useCaseKey);
  res.send({ status: "success", data: { key: useCaseKey } });

})

// URI:  <server>/client-data/get-users
// Method: GET
// Description: Retrieve list of all users.
router.get("/get-users", async (req, res) => {
  const users = new FSDB(`../data/users.json`, false);
  const allUsers = users.getAll();
  res.send(allUsers);
});

// URI:  <server>/client-data/update-user
// Method: POST
// Description: This route updates specific user from data passed in the request.
router.post("/update-user", async (req, res) => {
  console.log("update-user called with body: ", req.body);

  const users = new FSDB(`../data/users.json`, false);

  const userIdentity = req.body.identity;
  users.set(userIdentity, {
    from: req.body.from,
    role: req.body.role,
    type: req.body.type, // webRtc, sip, phone
    identity: req.body.identity,
    firstName: req.body.firstName,
    lastName: req.body.lastName,
    phone: req.body.phone,
    email: req.body.email,
    useCase: req.body.useCase,
    conversationRelayParamsOverride: req.body.conversationRelayParamsOverride,
  });
  res.send({ status: "success", data: users.get(userIdentity) });
});

// URI:  <server>/client-data/create-user
// Method: POST
// Description: API to create a new application user
//  create user with defaults for CR Params Override
//
router.post("/create-user", async (req, res) => {
  const users = new FSDB(`../data/users.json`, false);

  let userIdentity = "";
  if (req.body.type === "sip") {
    userIdentity = req.body.identity.replace(/\./g, "<>");
  } else {
    userIdentity = req.body.identity; // webRtc or phone
  }
  users.set(userIdentity, {
    from: req.body.from,
    role: req.body.role,
    type: req.body.type, // webRtc, sip, phone
    identity: req.body.identity,
    firstName: req.body.firstName,
    lastName: req.body.lastName,
    phone: req.body.phone,
    email: req.body.email,
    useCase: req.body.useCase,
    conversationRelayParamsOverride: {
      language: "en-US",
      ttsProvider: "ElevenLabs",
      voice: "UgBBYS2sOqTuMpoF3BR0",
      transcriptionProvider: "Google",
      speechModel: "telephony",
      interruptible: true,
      welcomeGreetingInterruptible: true,
    },
  });

  res.send({ status: "success", data: users.get(userIdentity) });
});

// URI:  <server>/client-data/delete-user
// Method: POST
// Description: API to delete an application user
router.post("/delete-user", async (req, res) => {
  // get users.json
  const users = new FSDB(`../data/users.json`, false);
  let userIdentity = "";

  // format identity based on user connection type
  if (req.body.type === "sip") {
    userIdentity = req.body.identity.replace(/\./g, "<>");
  } else {
    userIdentity = req.body.identity; // webRtc or phone
  }
  users.delete(userIdentity);

  res.send({ status: "success", data: { identity: userIdentity } });
});

// URI:  <server>/client-data/get-transcription-voices
// Method: GET
// Description: This route updates specific user from data passed in the request.
router.get("/get-tts-voices", async (req, res) => {
  const voices = new FSDB(`../data/tts-providers.json`, false);
  const allVoices = voices.getAll();
  res.send(allVoices);
});

// URI:  <server>/client-data/get-sessions
// Method: GET
// Description: Gets all session from the local database
router.get("/get-sessions", async (req, res) => {
  const sessions = new FSDB(`../data/cr-sessions.json`, false);
  res.send(sessions.getAll().reverse());
});

// URI:  <server>/client-data/get-session?callSid=<callSid>
// Method: GET
// Description: Returns the session data for a specific callSid (details and chats)
router.get("/get-session", async (req, res) => {
  const URLparams = url.parse(req.url, true).query;
  //console.log("URLparams => ", URLparams);
  const crSession = new FSDB(
    `../data/sessions/${URLparams.callSid}/session.json`,
    false
  );
  const sessionChats = new FSDB(
    `../data/sessions/${URLparams.callSid}/chats.json`,
    false
  );

  res.send({
    sessionData: {
      sessionData: crSession.getAll(),
      sessionChats: sessionChats.getAll().reverse(),
    },
  });
});

router.post("/delete-session", async (req, res) => {
  // get users.json
  const callSid = req.body.callSid;
  console.log("Request to delete callSid: ", callSid);

  // delete session from cr-sessions.json
  const sessions = new FSDB(`../data/cr-sessions.json`, false);
  sessions.delete(callSid);

  // delete session folder
  let deleteFolder = `../data/sessions/${callSid}`;
  await import("node:fs").then((fs) =>
    fs.rmSync(deleteFolder, { recursive: true, force: true })
  );
  res.send({ status: "success", data: { callSid: callSid } });
});

export default router;



================================================
FILE: server/routes/client-token.js
================================================
import express from "express";
const router = express.Router();
import cors from "cors";

import pkg from '../services/twilio-service.cjs';
const { registerVoiceClient } = pkg;

router.use(cors()); // Enable CORS for all routes
router.use(express.json()); // for parsing application/json

// Route to register voice client (get token from Twilio)
router.get("/register-voice-client", async (req, res) => {
  const phone = req.query.phone;
  const identity = phone.replace(" ", "+"); //quirk passing in from UI
  const token = await registerVoiceClient(identity);
  console.log("Registered voice client");
  res.send(token.body);
});

export default router;


================================================
FILE: server/routes/twiml.js
================================================
import express from "express";
const router = express.Router();
import { setupCallPostHandler } from '../lib/setup-call-post-handler.mjs';

/**
 * Twilio will send a POST request to this endpoint when estabilishing a call
 * Twilio expects a TwiML response to be sent back to it 
 */ 
router.post('/', async (req, res) => {
  console.log("POST /twiml => ", req.body);
  try {
    
    // Parse BODY of request to extract Call Details
    console.log("Twilio Body: ", JSON.stringify(req.body));
    const twilioBody = req.body;

    // Call the setupCallPostHandler function to dynamically generate the 
    // TwiML needed for this Csession handle the Twilio request and return a TwiML response    
    const twimlResponse = await setupCallPostHandler(twilioBody);
    console.log("TwiML Response: ", twimlResponse);

    res.status(200).type('application/xml').send(twimlResponse);

  } catch (error) {
    console.error("Error in POST /twiml => ", error);
    res.status(500).send("An error occurred while processing your request.");
  }
  
});

export default router;


================================================
FILE: server/services/twilio-service.cjs
================================================
const AccessToken = require("twilio").jwt.AccessToken;
const VoiceGrant = AccessToken.VoiceGrant;

const client = require("twilio")(
  process.env.TWILIO_ACCOUNT_SID,
  process.env.TWILIO_AUTH_TOKEN
);

/*const startRecording = async (textService, callSid) => {
  try {
    // textService.sendText({partialResponseIndex: null, partialResponse: 'This call will be recorded.'}, 0);
    const recording = await client.calls(callSid).recordings.create({
      recordingChannels: "dual",
      recordingStatusCallback: `https://${process.env.SERVER}/recording-complete`,
      recordingStatusCallbackEvent: ["completed"],
    });

    console.log(`Recording Created: ${recording.sid}`.red);
  } catch (err) {
    console.log(err);
  }
};*/

const registerVoiceClient = async (identity) => {
  try {
    const accessToken = new AccessToken(
      process.env.TWILIO_ACCOUNT_SID,
      process.env.TWILIO_API_KEY,
      process.env.TWILIO_API_SECRET,
      { identity: identity }
    );

    const grant = new VoiceGrant({
      outgoingApplicationSid: process.env.TWILIO_TWIML_APP_SID,
      incomingAllow: true,
    });
    accessToken.addGrant(grant);

    const headers = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Credentials": true,
    };
    return {
      statusCode: 200,
      headers: headers,
      body: accessToken.toJwt(),
    };
  } catch (err) {
    console.log(err);
  }
};
/*
const getRecording = async (callSid) => {
  try {
    const recordings = await client.recordings.list({
      callSid: callSid,
      limit: 1,
    });

    return {
      accSid: process.env.TWILIO_ACCOUNT_SID,
      recordingSid: recordings[0].sid,
    };
  } catch (e) {
    console.log(e);
    return {
      accSid: process.env.TWILIO_ACCOUNT_SID,
      recordingSid: "",
    };
  }
};

const voiceIntelligenceHandler = async (transcriptSid) => {
  console.log(
    "voiceIntelligenceHandler : Twilio Processing - " + transcriptSid
  );

  const recordingSid = await getRecordingSid(transcriptSid);
  const callSid = await getCallSid(recordingSid);

  try {
    // 1. Fetch the Transcript
    const transcriptResponse = await client.intelligence.v2
      .transcripts(transcriptSid)
      .fetch();

    // 2. Fetch the Transcript text
    let transcriptText = "";

    const sentences = await client.intelligence.v2
      .transcripts(transcriptSid)
      .sentences.list({ limit: 20 });

    sentences.forEach((s) => console.log(s.mediaChannel));

    sentences.forEach((sentence) => {
      transcriptText = transcriptText + sentence.transcript;
    });
    console.log(transcriptText);

    //3. Get agent, customer profile id
    console.log(transcriptResponse);
    const agent = transcriptResponse.channel.participants.find(
      (p) => p.role === "Agent"
    );
    const customer = transcriptResponse.channel.participants.find(
      (p) => p.role === "Customer"
    );
    console.log(agent);
    console.log(customer);
    const agentUniqueId = customer.user_id.replace("client", "agent");
    const customerUniqueId = customer.user_id;
    console.log("agent Id " + agentUniqueId);
    console.log("customer Id " + customerUniqueId);

    // 4. Fetch the Operator Results
    const operatorResultsResponse = await client.intelligence.v2
      .transcripts(transcriptSid)
      .operatorResults.list();

    //const viOperators = operatorResultsResponse;
    operatorResultsResponse.forEach((o) => {
      console.log(o.operatorType);
    });

    const sentimentAnalysisOR = operatorResultsResponse.find(
      (or) => or.name === "Sentiment Analysis"
    );
    const sentimentAnalysisVal = sentimentAnalysisOR?.predictedLabel;

    const CSAT = operatorResultsResponse.find((or) => or.name === "CSAT");

    const conversationSummary = operatorResultsResponse.find(
      (or) => or.operatorSid === "LY8d2be74b94a34733b28594fadf331f0c"
    );

    console.log("CSAT" + CSAT);

    //const competitorReferenceOR = operatorResultsResponse.find(or => or.name === "Competitor References");
    //const competitorReferenceVal =  competitorReferenceOR.predictedLabel ;

    // console.log("Sentiment analysis " + sentimentAnalysisVal);

    let call = {
      type: "Voice Intelligence Results",
      callSid: callSid, // @TODO get callsid from viTranscript
      viTranscriptSid: transcriptSid,
      callerProfileId: customerUniqueId,
      agentId: agentUniqueId,
      //viOperators: operatorResultsResponse,
      viOperators: {
        "Sentiment Analysis": `${sentimentAnalysisVal}`,
        CSAT: `${CSAT?.textGenerationResults?.result}`,
        "Conversation Summary": `${conversationSummary?.textGenerationResults?.result}`,
      },
      transcript: transcriptText,
    };
    return call;
  } catch (error) {
    console.error("Error:", error);
    return "error";
  }
};

const fetchCall = async (callSid) => {
  return (call = await client.calls(callSid).fetch());
};

const createTranscript = async (recordingSid, callSid) => {
  try {
    const call = await fetchCall(callSid);
    const participants = [
      {
        user_id: call.from.replace("client", "agent"),
        channel_participant: 2,
        full_name: call.from.replace("client", "agent"),
        image_url: "https://images.unsplash.com/photo-1554384645-13eab165c24b",
        role: "Agent",
      },
      {
        user_id: call.from,
        channel_participant: 1,
        full_name: call.from,
        role: "Customer",
      },
    ];

    const transcript = await client.intelligence.v2.transcripts.create({
      channel: {
        media_properties: {
          source_sid: recordingSid,
        },
        participants: participants,
      },
      serviceSid: process.env.TWILIO_VOICE_INTELLIGENCE_SID,
    });

    return transcript;
  } catch (e) {
    console.log(e);
  }
};

const getRecordingSid = async (transcriptSid) => {
  const media = await client.intelligence.v2.transcripts(transcriptSid).fetch();
  const recordingSid = media.channel.media_properties.source_sid;
  console.log(recordingSid);
  return recordingSid;
};

const getCallSid = async (recordingSid) => {
  const recording = await client.recordings(recordingSid).fetch();
  const callSid = recording.callSid;
  console.log(callSid);
  return callSid;
};*/

//module.exports = {
/*export default {
  registerVoiceClient,
  getRecording,
  startRecording,
  createTranscript,
  voiceIntelligenceHandler,
};*/
module.exports = { registerVoiceClient };


